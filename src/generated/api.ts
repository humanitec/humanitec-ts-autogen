/* tslint:disable */
/* eslint-disable */
/**
 * Humanitec API
 * # Introduction The *Humanitec API* allows you to automate and integrate Humanitec into your developer and operational workflows. The API is a REST based API. It is based around a set of concepts:  * Core * External Resources * Sets and Deltas  ## Authentication  Almost all requests made to the Humanitec API require Authentication. See our [Developer Docs on API Authentication](https://developer.humanitec.com/platform-orchestrator/reference/api-references/#authentication) for instructions.  ## Content Types All of the Humanitec API unless explicitly only accepts content types of `application/json` and will always return valid `application/json` or an empty response.  ## Response Codes ### Success Any response code in the `2xx` range should be regarded as success.  | **Code** | **Meaning** | | --- | --- | | `200` | Success | | `201` | Success (In future, `201` will be replaced by `200`) | | `204` | Success, but no content in response |  _Note: We plan to simplify the interface by replacing 201 with 200 status codes._  ### Failure Any response code in the `4xx` should be regarded as an error which can be rectified by the client. `5xx` error codes indicate errors that cannot be corrected by the client.  | **Code** | **Meaning** | | --- | --- | | `400` | General error. (Body will contain details) | | `401` | Attempt to access protected resource without `Authorization` Header. | | `403` | The `Bearer` or `JWT` does not grant access to the requested resource. | | `404` | Resource not found. | | `405` | Method not allowed | | `409` | Conflict. Usually indicated a resource with that ID already exists. | | `422` | Unprocessable Entity. The body was not valid JSON, was empty or contained an object different from what was expected. | | `429` | Too many requests - request rate limit has been reached. | | `500` | Internal Error. If it occurs repeatedly, contact support. | 
 *
 * The version of the OpenAPI document: 0.25.14
 * Contact: apiteam@humanitec.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
import FormData from 'form-data'
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Credentials to authenticate AWS Secret Manager.
 * @export
 * @interface AWSAuthRequest
 */
export interface AWSAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof AWSAuthRequest
     */
    'access_key_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AWSAuthRequest
     */
    'secret_access_key'?: string;
}
/**
 * AWS Secret Manager specification.
 * @export
 * @interface AWSSMRequest
 */
export interface AWSSMRequest {
    /**
     * 
     * @type {AWSAuthRequest}
     * @memberof AWSSMRequest
     */
    'auth'?: AWSAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof AWSSMRequest
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof AWSSMRequest
     */
    'region'?: string;
}
/**
 * AWS Secret Manager specification.
 * @export
 * @interface AWSSMResponse
 */
export interface AWSSMResponse {
    /**
     * 
     * @type {string}
     * @memberof AWSSMResponse
     */
    'endpoint'?: string;
    /**
     * 
     * @type {string}
     * @memberof AWSSMResponse
     */
    'region'?: string;
}
/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsRequest
 */
export interface AccountCredsRequest {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'username': string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeRequest
 */
export interface AccountTypeRequest {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'name': string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'type': string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeResponse
 */
export interface AccountTypeResponse {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'name': string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'type': string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceRequest
 */
export interface ActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'app_id': string;
    /**
     * The Resource Class of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'class': string;
    /**
     * The Matching Criteria ID.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'criteria_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'def_id': string;
    /**
     * The deployment that the resource was last provisioned in.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'deploy_id': string;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'driver_account'?: string;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'driver_type': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_type': string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'gu_res_id': string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'res_id': string;
    /**
     * The resource provisioning outputs (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceRequest
     */
    'resource': { [key: string]: any; };
    /**
     * Secret references from the resource provisioning output.
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceRequest
     */
    'secret_refs'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'status': string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'updated_at': string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceResponse
 */
export interface ActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Class of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'class': string;
    /**
     * The Matching Criteria ID.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'criteria_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'def_id': string;
    /**
     * The deployment that the resource was last provisioned in.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'deploy_id': string;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'driver_account'?: string;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'driver_type': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_type': string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'gu_res_id': string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'res_id': string;
    /**
     * The resource provisioning outputs (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Secret references from the resource provisioning output.
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceResponse
     */
    'secret_refs': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * An object containing the details of an Agent.
 * @export
 * @interface Agent
 */
export interface Agent {
    /**
     * The Agent id.
     * @type {string}
     * @memberof Agent
     */
    'id': string;
    /**
     * A description to show future users. It can be empty.
     * @type {string}
     * @memberof Agent
     */
    'description'?: string;
    /**
     * Time of the Agent being registered.
     * @type {string}
     * @memberof Agent
     */
    'created_at': string;
    /**
     * User ID of user that added the Agent.
     * @type {string}
     * @memberof Agent
     */
    'created_by': string;
}
/**
 * An object containing data needed to register an Agent.
 * @export
 * @interface AgentCreateBody
 */
export interface AgentCreateBody {
    /**
     * The Agent id. It can\'t be empty and should contain only url safe characters.
     * @type {string}
     * @memberof AgentCreateBody
     */
    'id': string;
    /**
     * A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits.
     * @type {string}
     * @memberof AgentCreateBody
     */
    'public_key': string;
    /**
     * An optional description to show future users.
     * @type {string}
     * @memberof AgentCreateBody
     */
    'description'?: string;
}
/**
 * An object containing data to update the description field of an Agent.
 * @export
 * @interface AgentPatchBody
 */
export interface AgentPatchBody {
    /**
     * A description to show future users. It can be empty.
     * @type {string}
     * @memberof AgentPatchBody
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ApplicationCreationRequest
 */
export interface ApplicationCreationRequest {
    /**
     * 
     * @type {EnvironmentBaseRequest}
     * @memberof ApplicationCreationRequest
     */
    'env'?: EnvironmentBaseRequest;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationCreationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationCreationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Workloads that work together. When deployed, all Workloads in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Workloads that work together. When deployed, all Workloads in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * The timestamp in UTC indicates when the Application was created.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_at': string;
    /**
     * The user who created the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_by': string;
    /**
     * The Environments associated with the Application.
     * @type {Array<EnvironmentBaseResponse>}
     * @memberof ApplicationResponse
     */
    'envs': Array<EnvironmentBaseResponse>;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name': string;
    /**
     * The Organization id of this Application
     * @type {string}
     * @memberof ApplicationResponse
     */
    'org_id': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactResponse
 */
export interface ArtefactResponse {
    /**
     * The time when the Artefact was added to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'type': string;
    /**
     * The time when the Artefact was updated for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who updated the Artefact for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_by'?: string;
}
/**
 * @type ArtefactVersion
 * The details of an Artefact Version. The type field dictates the type of Artefact along with any additional fields.
 * @export
 */
export type ArtefactVersion = { type: 'container' } & ContainerArtefactVersion | { type: 'workload' } & WorkloadArtefactVersion;

/**
 * 
 * @export
 * @interface ArtefactVersionBase
 */
export interface ArtefactVersionBase {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionBase
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'commit'?: string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'ref'?: string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionBase
     */
    'version'?: string;
}
/**
 * An entry in the audit log
 * @export
 * @interface AuditLogEntry
 */
export interface AuditLogEntry {
    /**
     * The date and time when the event was recorded.
     * @type {string}
     * @memberof AuditLogEntry
     */
    'at': string;
    /**
     * The id of the Organization this event occurred in.
     * @type {string}
     * @memberof AuditLogEntry
     */
    'org_id'?: string;
    /**
     * The id of the User who triggered the event.
     * @type {string}
     * @memberof AuditLogEntry
     */
    'user_id': string;
    /**
     * The HTTP method that was requested. Only POST, PATCH, PUT, and DELETE are audited.
     * @type {string}
     * @memberof AuditLogEntry
     */
    'request_method': string;
    /**
     * The URL path that was called.
     * @type {string}
     * @memberof AuditLogEntry
     */
    'request_path': string;
    /**
     * The status code of the response. Only successful responses are audited.
     * @type {number}
     * @memberof AuditLogEntry
     */
    'response_status': number;
}
/**
 * An Automation Rule defining how and when artefacts in an environment should be updated.
 * @export
 * @interface AutomationRuleRequest
 */
export interface AutomationRuleRequest {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'active'?: boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'artefacts_filter'?: Array<string>;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_artefacts_filter'?: boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_images_filter'?: boolean;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'images_filter'?: Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match'?: string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match_ref'?: string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'update_to'?: string;
}
/**
 * An Automation Rule defining how and when artefacts in an environment should be updated.
 * @export
 * @interface AutomationRuleResponse
 */
export interface AutomationRuleResponse {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'active': boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'artefacts_filter': Array<string>;
    /**
     * The timestamp in UTC of when the Automation Rule was created.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'created_at': string;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_artefacts_filter': boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_images_filter': boolean;
    /**
     * The unique ID for this rule.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'id': string;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'images_filter': Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match': string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match_ref': string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'update_to': string;
    /**
     * The timestamp in UTC of when the Automation Rule was updated.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'updated_at': string;
}
/**
 * Credentials to authenticate Azure Key Vault.
 * @export
 * @interface AzureAuthRequest
 */
export interface AzureAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof AzureAuthRequest
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureAuthRequest
     */
    'client_secret'?: string;
}
/**
 * Azure Key Vault specification.
 * @export
 * @interface AzureKVRequest
 */
export interface AzureKVRequest {
    /**
     * 
     * @type {AzureAuthRequest}
     * @memberof AzureKVRequest
     */
    'auth'?: AzureAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof AzureKVRequest
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureKVRequest
     */
    'url'?: string;
}
/**
 * Azure Key Vault specification.
 * @export
 * @interface AzureKVResponse
 */
export interface AzureKVResponse {
    /**
     * 
     * @type {string}
     * @memberof AzureKVResponse
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureKVResponse
     */
    'url'?: string;
}
/**
 * A batch of items that are being collected for a upcoming run.
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * The list of item ids that are currently contained in this batch.
     * @type {Array<BatchItem>}
     * @memberof Batch
     */
    'items': Array<BatchItem>;
    /**
     * The time at which this batch is scheduled to trigger the pipeline.
     * @type {string}
     * @memberof Batch
     */
    'scheduled_at'?: string;
}
/**
 * 
 * @export
 * @interface BatchItem
 */
export interface BatchItem {
    /**
     * The type of item in the batch
     * @type {string}
     * @memberof BatchItem
     */
    'type': string;
    /**
     * The reference id of the item
     * @type {string}
     * @memberof BatchItem
     */
    'ref': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretRequest
 */
export interface ClusterSecretRequest {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'secret': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretResponse
 */
export interface ClusterSecretResponse {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'secret': string;
}
/**
 * Details of a Container Artefact Version
 * @export
 * @interface ContainerArtefactVersion
 */
export interface ContainerArtefactVersion {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ContainerArtefactVersion
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'commit': string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'ref': string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'version'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ContainerArtefactVersion
     */
    'digest': string;
}
/**
 * 
 * @export
 * @interface ContainerArtefactVersionAllOf
 */
export interface ContainerArtefactVersionAllOf {
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ContainerArtefactVersionAllOf
     */
    'digest': string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerResponse
 */
export interface ControllerResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<PodStateResponse>}
     * @memberof ControllerResponse
     */
    'pods': Array<PodStateResponse>;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'replicas': number;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'status': string;
}
/**
 * @type CreateArtefactVersion
 * The details of a new Artefact Version to register. The type field is required and dictates the type of Artefact to register.
 * @export
 */
export type CreateArtefactVersion = { type: 'container' } & CreateContainerArtefactVersion | { type: 'workload' } & CreateWorkloadArtefactVersion;

/**
 * 
 * @export
 * @interface CreateArtefactVersionBase
 */
export interface CreateArtefactVersionBase {
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof CreateArtefactVersionBase
     */
    'type': string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof CreateArtefactVersionBase
     */
    'name': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof CreateArtefactVersionBase
     */
    'version'?: string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof CreateArtefactVersionBase
     */
    'ref'?: string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof CreateArtefactVersionBase
     */
    'commit'?: string;
}
/**
 * Details for creating a new Container Artefact Version
 * @export
 * @interface CreateContainerArtefactVersion
 */
export interface CreateContainerArtefactVersion {
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'type': string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'name': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'version'?: string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'ref'?: string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof CreateContainerArtefactVersion
     */
    'digest'?: string;
}
/**
 * 
 * @export
 * @interface CreateContainerArtefactVersionAllOf
 */
export interface CreateContainerArtefactVersionAllOf {
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof CreateContainerArtefactVersionAllOf
     */
    'digest'?: string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestRequest
 */
export interface CreateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateDriverRequestRequest
     * @deprecated
     */
    'is_public'?: boolean;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestRequest
 */
export interface CreateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestRequest
     */
    'credentials': { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'id': string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'type': string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestRequest
 */
export interface CreateResourceDefinitionRequestRequest {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRuleRequest>}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'criteria'?: Array<MatchingCriteriaRuleRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRefsRequest}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRefsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'type': string;
}
/**
 * Secret Store represents external secret management system used by an organization to store secrets referenced in Humanitec. It must contain exactly one of the following elements to define Secret Store specification: `awssm` (AWS Secret Manager), `azurekv` (Azure Key Vault), `gcpsm` (GCP Secret Manager), `vault` (HashiCorp Vault).
 * @export
 * @interface CreateSecretStorePayloadRequest
 */
export interface CreateSecretStorePayloadRequest {
    /**
     * 
     * @type {AWSSMRequest}
     * @memberof CreateSecretStorePayloadRequest
     */
    'awssm'?: AWSSMRequest;
    /**
     * 
     * @type {AzureKVRequest}
     * @memberof CreateSecretStorePayloadRequest
     */
    'azurekv'?: AzureKVRequest;
    /**
     * 
     * @type {GCPSMRequest}
     * @memberof CreateSecretStorePayloadRequest
     */
    'gcpsm'?: GCPSMRequest;
    /**
     * The Secret Store ID.
     * @type {string}
     * @memberof CreateSecretStorePayloadRequest
     */
    'id': string;
    /**
     * Defines whether the Secret Store is the primary secret management system for the organization.
     * @type {boolean}
     * @memberof CreateSecretStorePayloadRequest
     */
    'primary': boolean;
    /**
     * 
     * @type {VaultRequest}
     * @memberof CreateSecretStorePayloadRequest
     */
    'vault'?: VaultRequest;
}
/**
 * Details for creating a new Workload Artefact Version
 * @export
 * @interface CreateWorkloadArtefactVersion
 */
export interface CreateWorkloadArtefactVersion {
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'type': string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'name': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'version'?: string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'ref'?: string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'commit'?: string;
    /**
     * A Json object containing the workload specification. Score v1b1 is expected.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersion
     */
    'spec': { [key: string]: any; };
    /**
     * An optional default image to assign to any containers in the workload that do not have an image set or whose image is \'.\'
     * @type {string}
     * @memberof CreateWorkloadArtefactVersion
     */
    'image'?: string;
    /**
     * An optional Json object containing the workload overrides. Score v1b1 is expected.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersion
     */
    'overrides'?: { [key: string]: any; };
    /**
     * An optional set of path overrides that will be applied to the workload.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersion
     */
    'property_overrides'?: { [key: string]: any; };
    /**
     * 
     * @type {CreateWorkloadArtefactVersionExtensions}
     * @memberof CreateWorkloadArtefactVersion
     */
    'extensions'?: CreateWorkloadArtefactVersionExtensions;
}
/**
 * 
 * @export
 * @interface CreateWorkloadArtefactVersionAllOf
 */
export interface CreateWorkloadArtefactVersionAllOf {
    /**
     * A Json object containing the workload specification. Score v1b1 is expected.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersionAllOf
     */
    'spec': { [key: string]: any; };
    /**
     * An optional default image to assign to any containers in the workload that do not have an image set or whose image is \'.\'
     * @type {string}
     * @memberof CreateWorkloadArtefactVersionAllOf
     */
    'image'?: string;
    /**
     * An optional Json object containing the workload overrides. Score v1b1 is expected.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersionAllOf
     */
    'overrides'?: { [key: string]: any; };
    /**
     * An optional set of path overrides that will be applied to the workload.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersionAllOf
     */
    'property_overrides'?: { [key: string]: any; };
    /**
     * 
     * @type {CreateWorkloadArtefactVersionExtensions}
     * @memberof CreateWorkloadArtefactVersionAllOf
     */
    'extensions'?: CreateWorkloadArtefactVersionExtensions;
}
/**
 * Humanitec workload extensions for the Workload Artefact Version. These can be used to override the profile, or workload module spec and resource attributes.
 * @export
 * @interface CreateWorkloadArtefactVersionExtensions
 */
export interface CreateWorkloadArtefactVersionExtensions {
    /**
     * The api version describing the format of the extensions.
     * @type {string}
     * @memberof CreateWorkloadArtefactVersionExtensions
     */
    'apiVersion': string;
    /**
     * An optional override for the workload profile
     * @type {string}
     * @memberof CreateWorkloadArtefactVersionExtensions
     */
    'profile'?: string;
    /**
     * A map of additional workload spec fields that will be merged.
     * @type {{ [key: string]: any; }}
     * @memberof CreateWorkloadArtefactVersionExtensions
     */
    'spec'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateWorkloadProfileChartVersionRequest
 */
export interface CreateWorkloadProfileChartVersionRequest {
    /**
     * 
     * @type {File}
     * @memberof CreateWorkloadProfileChartVersionRequest
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface DeltaMetadataRequest
 */
export interface DeltaMetadataRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataRequest
     */
    'contributers'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'last_modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'shared'?: boolean;
}
/**
 * 
 * @export
 * @interface DeltaMetadataResponse
 */
export interface DeltaMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'archived': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataResponse
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'last_modified_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'shared'?: boolean;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaRequest
 */
export interface DeltaRequest {
    /**
     * Ignored, but can be provided.
     * @type {string}
     * @memberof DeltaRequest
     */
    'id'?: string;
    /**
     * 
     * @type {DeltaMetadataRequest}
     * @memberof DeltaRequest
     */
    'metadata'?: DeltaMetadataRequest;
    /**
     * 
     * @type {ModuleDeltasRequest}
     * @memberof DeltaRequest
     */
    'modules'?: ModuleDeltasRequest;
    /**
     * 
     * @type {Array<UpdateActionRequest>}
     * @memberof DeltaRequest
     */
    'shared'?: Array<UpdateActionRequest> | null;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaResponse
 */
export interface DeltaResponse {
    /**
     * A unique ID for the Delta
     * @type {string}
     * @memberof DeltaResponse
     */
    'id': string;
    /**
     * 
     * @type {DeltaMetadataResponse}
     * @memberof DeltaResponse
     */
    'metadata': DeltaMetadataResponse;
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof DeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof DeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionRequest
 */
export interface DeployConditionRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'success'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionRequest
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'when'?: string;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionResponse
 */
export interface DeployConditionResponse {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'success': string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionResponse
     */
    'timeout': number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'when': string;
}
/**
 * Error happening during deployment.
 * @export
 * @interface DeploymentErrorRequest
 */
export interface DeploymentErrorRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'error_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'object_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'summary'?: string;
}
/**
 * Error happening during deployment.
 * @export
 * @interface DeploymentErrorResponse
 */
export interface DeploymentErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'error_type': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'object_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'summary': string;
}
/**
 * 
 * @export
 * @interface DeploymentPipelineReferenceRequest
 */
export interface DeploymentPipelineReferenceRequest {
    /**
     * The ID of the Pipeline
     * @type {string}
     * @memberof DeploymentPipelineReferenceRequest
     */
    'id'?: string;
    /**
     * The ID of the Pipeline Job within the Run.
     * @type {string}
     * @memberof DeploymentPipelineReferenceRequest
     */
    'job_id'?: string;
    /**
     * The ID of the Pipeline Run
     * @type {string}
     * @memberof DeploymentPipelineReferenceRequest
     */
    'run_id'?: string;
    /**
     * The index of the step with in the Job.
     * @type {number}
     * @memberof DeploymentPipelineReferenceRequest
     */
    'step_index'?: number;
}
/**
 * 
 * @export
 * @interface DeploymentPipelineReferenceResponse
 */
export interface DeploymentPipelineReferenceResponse {
    /**
     * The ID of the Pipeline
     * @type {string}
     * @memberof DeploymentPipelineReferenceResponse
     */
    'id': string;
    /**
     * The ID of the Pipeline Job within the Run.
     * @type {string}
     * @memberof DeploymentPipelineReferenceResponse
     */
    'job_id': string;
    /**
     * The ID of the Pipeline Run
     * @type {string}
     * @memberof DeploymentPipelineReferenceResponse
     */
    'run_id': string;
    /**
     * The index of the step with in the Job.
     * @type {number}
     * @memberof DeploymentPipelineReferenceResponse
     */
    'step_index': number;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentRequest
 */
export interface DeploymentRequest {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'comment'?: string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'delta_id'?: string;
    /**
     * 
     * @type {DeploymentPipelineReferenceRequest}
     * @memberof DeploymentRequest
     */
    'pipeline'?: DeploymentPipelineReferenceRequest;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'set_id'?: string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'value_set_version_id'?: string | null;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentResponse
 */
export interface DeploymentResponse {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'comment': string;
    /**
     * The Timestamp of when the Deployment was initiated.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_at': string;
    /**
     * The user who initiated the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_by': string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'delta_id'?: string;
    /**
     * The Environment where the Deployment occurred.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'env_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_file': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_status': string;
    /**
     * The ID of the Deployment that this Deployment was based on.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'from_id': string;
    /**
     * The ID of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'id': string;
    /**
     * 
     * @type {DeploymentPipelineReferenceResponse}
     * @memberof DeploymentResponse
     */
    'pipeline'?: DeploymentPipelineReferenceResponse;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'set_id': string;
    /**
     * The current status of the Deployment. Can be `pending`, `in progress`, `succeeded`, or `failed`.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status': string;
    /**
     * The timestamp of the last `status` change. If `status` is `succeeded` or `failed` it it will indicate when the Deployment finished.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status_changed_at': string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'value_set_version_id'?: string | null;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionResponse
 */
export interface DriverDefinitionResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'org_id': string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionResponse
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseRequest
 */
export interface EnvironmentBaseRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseResponse
 */
export interface EnvironmentBaseResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseUpdateRequest
 */
export interface EnvironmentBaseUpdateRequest {
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseUpdateRequest
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionRequest
 */
export interface EnvironmentDefinitionRequest {
    /**
     * Defines the existing Deployment the new Environment will be based on.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'from_deploy_id': string;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'type'?: string;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentResponse
 */
export interface EnvironmentResponse {
    /**
     * The timestamp in UTC of when the Environment was created.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_at': string;
    /**
     * The user who created the Environment
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_by': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'from_deploy'?: DeploymentResponse;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'last_deploy'?: DeploymentResponse;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'type': string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoResponse
 */
export interface EnvironmentRuntimeInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'paused': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'status'?: string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeRequest
 */
export interface EnvironmentTypeRequest {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'description'?: string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'id': string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeResponse
 */
export interface EnvironmentTypeResponse {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'description': string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'id': string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoResponse
 */
export interface ErrorInfoResponse {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoResponse
     */
    'error': string;
}
/**
 * A standard error response
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * A short code representing the class of error. This code can be used for tracking and observability or to find appropriate troubleshooting documentation. 
     * @type {string}
     * @memberof ErrorResponse
     */
    'error': string;
    /**
     * A human-readable explanation of the error.
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * An optional payload of metadata associated with the error.
     * @type {{ [key: string]: any; }}
     * @memberof ErrorResponse
     */
    'details'?: { [key: string]: any; };
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseRequest
 */
export interface EventBaseRequest {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseRequest
     */
    'type'?: string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseResponse
 */
export interface EventBaseResponse {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseResponse
     */
    'type': string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventResponse
     */
    'properties': Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
}
/**
 * Credentials to authenticate GCP Secret Manager.
 * @export
 * @interface GCPAuthRequest
 */
export interface GCPAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof GCPAuthRequest
     */
    'secret_access_key'?: string;
}
/**
 * GCP Secret Manager specification.
 * @export
 * @interface GCPSMRequest
 */
export interface GCPSMRequest {
    /**
     * 
     * @type {GCPAuthRequest}
     * @memberof GCPSMRequest
     */
    'auth'?: GCPAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof GCPSMRequest
     */
    'project_id'?: string;
}
/**
 * GCP Secret Manager specification.
 * @export
 * @interface GCPSMResponse
 */
export interface GCPSMResponse {
    /**
     * 
     * @type {string}
     * @memberof GCPSMResponse
     */
    'project_id'?: string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorResponse
 */
export interface HumanitecErrorResponse {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorResponse
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'error': string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'message': string;
}
/**
 * HumanitecPublicKey stores a Public Key Humanitec shared with an organization.
 * @export
 * @interface HumanitecPublicKey
 */
export interface HumanitecPublicKey {
    /**
     * 
     * @type {string}
     * @memberof HumanitecPublicKey
     */
    'pub_key': string;
    /**
     * 
     * @type {boolean}
     * @memberof HumanitecPublicKey
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof HumanitecPublicKey
     */
    'created_at': string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildRequest
 */
export interface ImageBuildRequest {
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'branch'?: string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'commit'?: string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'image'?: string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildRequest
     */
    'tags'?: Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildResponse
 */
export interface ImageBuildResponse {
    /**
     * The time when the build was added to Humanitec.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'added_at'?: string;
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'branch': string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'commit': string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'image': string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildResponse
     */
    'tags': Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageRequest
 */
export interface ImageRequest {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageRequest
     */
    'added_at'?: string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildRequest>}
     * @memberof ImageRequest
     */
    'builds'?: Array<ImageBuildRequest>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageRequest
     */
    'id'?: string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageRequest
     */
    'source'?: string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageResponse
     */
    'added_at': string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildResponse>}
     * @memberof ImageResponse
     */
    'builds': Array<ImageBuildResponse>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageResponse
     */
    'id': string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageResponse
     */
    'source': string;
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsRequest
 */
export interface ImagesRegistryCredsRequest {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsRequest
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof ImagesRegistryCredsRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsResponse
 */
export interface ImagesRegistryCredsResponse {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsResponse
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof ImagesRegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
}
/**
 * 
 * @export
 * @interface JSONPatchRequest
 */
export interface JSONPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchRequest
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface JSONPatchResponse
 */
export interface JSONPatchResponse {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchResponse
     */
    'value'?: any;
}
/**
 * JSON Web Key
 * @export
 * @interface Jwk
 */
export interface Jwk {
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'alg': string;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'kty': string;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'use': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Jwk
     */
    'x5c'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'n': string;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'e': string;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'kid': string;
    /**
     * 
     * @type {string}
     * @memberof Jwk
     */
    'x5t'?: string;
}
/**
 * An object containing the details of a Key.
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * The Key fingerprint (sha256 hash of the DER representation of the key).
     * @type {string}
     * @memberof Key
     */
    'fingerprint': string;
    /**
     * A pcks8 RSA ublic key PEM encoded.
     * @type {string}
     * @memberof Key
     */
    'public_key': string;
    /**
     * Time of the Key being registered.
     * @type {string}
     * @memberof Key
     */
    'created_at': string;
    /**
     * User ID of user that added the Key.
     * @type {string}
     * @memberof Key
     */
    'created_by': string;
    /**
     * Time when the Key should be replaced (2 years after its creation).
     * @type {string}
     * @memberof Key
     */
    'expired_at': string;
}
/**
 * 
 * @export
 * @interface KeyCreateBody
 */
export interface KeyCreateBody {
    /**
     * A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits.
     * @type {string}
     * @memberof KeyCreateBody
     */
    'public_key': string;
}
/**
 * 
 * @export
 * @interface LogoResponse
 */
export interface LogoResponse {
    /**
     * 
     * @type {string}
     * @memberof LogoResponse
     */
    'dark_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogoResponse
     */
    'light_url'?: string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestResponse
     */
    'data': any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestResponse
     */
    'location': string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaResponse
 */
export interface MatchingCriteriaResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The class of the Resource in the Deployment Set. Can not be empty, if is not defined, set to `default`.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'class': string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'id': string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleRequest
 */
export interface MatchingCriteriaRuleRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The class of the Resource in the Deployment Set. Can not be empty, if is not defined, set to `default`.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'class'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'res_id'?: string;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasRequest
 */
export interface ModuleDeltasRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof ModuleDeltasRequest
     */
    'add'?: { [key: string]: ModuleRequest; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasRequest
     */
    'remove'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionRequest>; }}
     * @memberof ModuleDeltasRequest
     */
    'update'?: { [key: string]: Array<UpdateActionRequest>; } | null;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasResponse
 */
export interface ModuleDeltasResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof ModuleDeltasResponse
     */
    'add': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasResponse
     */
    'remove': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionResponse>; }}
     * @memberof ModuleDeltasResponse
     */
    'update': { [key: string]: Array<UpdateActionResponse>; };
}
/**
 * Module single workload data
 * @export
 * @interface ModuleRequest
 */
export interface ModuleRequest {
    /**
     * 
     * @type {DeployConditionRequest}
     * @memberof ModuleRequest
     */
    'deploy'?: DeployConditionRequest;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'externals'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ModuleRequest
     */
    'profile'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'spec'?: { [key: string]: any; } | null;
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleResponse
 */
export interface ModuleResponse {
    [key: string]: ControllerResponse | any;

    /**
     * 
     * @type {DeployConditionResponse}
     * @memberof ModuleResponse
     */
    'deploy'?: DeployConditionResponse;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'externals': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleResponse
     */
    'profile': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'spec': { [key: string]: any; };
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserRequest
 */
export interface NewServiceUserRequest {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'name': string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'role': string;
}
/**
 * NodeBody represents a node of a Resource Dependency Graph.
 * @export
 * @interface NodeBodyResponse
 */
export interface NodeBodyResponse {
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'class': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'criteria_id': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'def_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeBodyResponse
     */
    'depends_on': Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'driver': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'driver_account'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'driver_type': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'guresid': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'resource': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'resource_schema': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'type': string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Timestamp when the Organization was created.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_at': string | null;
    /**
     * User ID that created the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_by': string;
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'id': string;
    /**
     * 
     * @type {LogoResponse}
     * @memberof OrganizationResponse
     */
    'logo': LogoResponse;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'name': string;
    /**
     * Timestamp the trial expires at.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'trial_expires_at': string | null;
    /**
     * URL of the scaffolding service.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'scaffolding_url'?: string;
}
/**
 * @type OrgsOrgIdAppsAppIdDeltasPost200Response
 * @export
 */
export type OrgsOrgIdAppsAppIdDeltasPost200Response = DeltaResponse | string;

/**
 * @type OrgsOrgIdAppsAppIdSetsSetIdGet200Response
 * @export
 */
export type OrgsOrgIdAppsAppIdSetsSetIdGet200Response = PlainDeltaResponse | SetResponse;

/**
 * PatchResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface PatchResourceDefinitionRequestRequest
 */
export interface PatchResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRefsRequest}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRefsRequest;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'name'?: string | null;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource or if they have the same dependent resources.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
}
/**
 * An object containing the details of a Pipeline.
 * @export
 * @interface Pipeline
 */
export interface Pipeline {
    /**
     * The id of the Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'id': string;
    /**
     * The current entity tag value for this Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'etag': string;
    /**
     * The id of the Organization containing this Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'org_id': string;
    /**
     * The id of the Application containing this Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'app_id': string;
    /**
     * The name of the Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'name': string;
    /**
     * The current status of the Pipeline.
     * @type {string}
     * @memberof Pipeline
     */
    'status': string;
    /**
     * The unique id of the current Pipeline Version.
     * @type {string}
     * @memberof Pipeline
     */
    'version': string;
    /**
     * The date and time when the Pipeline was created.
     * @type {string}
     * @memberof Pipeline
     */
    'created_at': string;
    /**
     * The list of trigger types in the current schema.
     * @type {Array<string>}
     * @memberof Pipeline
     */
    'trigger_types': Array<string>;
    /**
     * The map of key value pipeline additional information
     * @type {{ [key: string]: string; }}
     * @memberof Pipeline
     */
    'metadata'?: { [key: string]: string; };
}
/**
 * An approval object
 * @export
 * @interface PipelineApprovalRequest
 */
export interface PipelineApprovalRequest {
    /**
     * The id of the approval object.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'id': string;
    /**
     * The id of the Organization.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'org_id': string;
    /**
     * The id of the Application.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'app_id': string;
    /**
     * The id of the Pipeline.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'pipeline_id': string;
    /**
     * The id of the Pipeline\'s Run.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'run_id': string;
    /**
     * The id of the Run\'s Job.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'job_id': string;
    /**
     * The environment for which the approver needs to have deploy permission to approve the job.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'env_id': string;
    /**
     * A human-readable message indicating the reason for approval.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'message': string;
    /**
     * The date and time when the approval request was created.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'created_at': string;
    /**
     * The current status of the approval request.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'status': PipelineApprovalRequestStatusEnum;
    /**
     * The user who approved or denied the request.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'approved_by'?: string;
    /**
     * The date and time when the request was approved or denied.
     * @type {string}
     * @memberof PipelineApprovalRequest
     */
    'approved_at'?: string;
}

export const PipelineApprovalRequestStatusEnum = {
    Waiting: 'waiting',
    Approved: 'approved',
    Denied: 'denied',
    Cancelled: 'cancelled'
} as const;

export type PipelineApprovalRequestStatusEnum = typeof PipelineApprovalRequestStatusEnum[keyof typeof PipelineApprovalRequestStatusEnum];

/**
 * @type PipelineCriteria
 * @export
 */
export type PipelineCriteria = { trigger: 'deployment_request' } & PipelineDeploymentRequestCriteria;

/**
 * @type PipelineCriteriaCreateBody
 * @export
 */
export type PipelineCriteriaCreateBody = { trigger: 'deployment_request' } & PipelineDeploymentRequestCriteriaCreateBody;

/**
 * A deployment request matching criteria for a Pipeline.
 * @export
 * @interface PipelineDeploymentRequestCriteria
 */
export interface PipelineDeploymentRequestCriteria {
    /**
     * The trigger to call
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'trigger': string;
    /**
     * The unique id of the criteria within this Pipeline.
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'id': string;
    /**
     * The id of the Pipeline tied to this deployment request criteria.
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'pipeline_id': string;
    /**
     * The current display name of the Pipeline.
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'pipeline_name': string;
    /**
     * The Environment Type that this criteria will match. If defined, this criteria will only apply to Environments that have this type. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'env_type'?: string;
    /**
     * The id of the Application for which this criteria matches. If this Pipeline is defined in an Application, then this value can only be null or the id of the Application. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'app_id'?: string;
    /**
     * The exact id of the Environment which this criteria will match. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'env_id'?: string;
    /**
     * The type of deployment that this criteria will match. Valid values are \"deploy\" and \"redeploy\". \"redeploy\"  applies only to deployment request to redeploy a previous deployment id while \"deploy\" will apply to all other requests that include a Delta or Deployment Set. If not defined, all deployment types will match. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteria
     */
    'deployment_type'?: string;
}
/**
 * The details required to create a new deployment request matching criteria for a Pipeline.
 * @export
 * @interface PipelineDeploymentRequestCriteriaCreateBody
 */
export interface PipelineDeploymentRequestCriteriaCreateBody {
    /**
     * The Environment Type that this criteria will match. If defined, this criteria will only apply to Environments that have this type. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteriaCreateBody
     */
    'env_type'?: string;
    /**
     * The id of the Application for which this criteria matches. If this Pipeline is defined in an Application, then this value can only be null or the id of the Application. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteriaCreateBody
     */
    'app_id'?: string;
    /**
     * The exact id of the Environment which this criteria will match. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteriaCreateBody
     */
    'env_id'?: string;
    /**
     * The type of deployment that this criteria will match. Valid values are \"deploy\" and \"redeploy\". \"redeploy\"  applies only to deployment request to redeploy a previous deployment id while \"deploy\" will apply to all other requests that include a Delta or Deployment Set. If not defined, all deployment types will match. 
     * @type {string}
     * @memberof PipelineDeploymentRequestCriteriaCreateBody
     */
    'deployment_type'?: string;
}
/**
 * A response containing all of the details of an executing or completed Job including Step information.
 * @export
 * @interface PipelineJob
 */
export interface PipelineJob {
    /**
     * The id of the Job within the Run.
     * @type {string}
     * @memberof PipelineJob
     */
    'id': string;
    /**
     * The current entity tag value for this Job.
     * @type {string}
     * @memberof PipelineJob
     */
    'etag': string;
    /**
     * The id of the Organization containing this Job.
     * @type {string}
     * @memberof PipelineJob
     */
    'org_id': string;
    /**
     * The id of the Application containing this Job.
     * @type {string}
     * @memberof PipelineJob
     */
    'app_id': string;
    /**
     * The id of the Pipeline.
     * @type {string}
     * @memberof PipelineJob
     */
    'pipeline_id': string;
    /**
     * The id of the Pipeline Version associated with the Run.
     * @type {string}
     * @memberof PipelineJob
     */
    'pipeline_version': string;
    /**
     * The id of the Run containing this Job.
     * @type {string}
     * @memberof PipelineJob
     */
    'run_id': string;
    /**
     * The current status of this Job.
     * @type {string}
     * @memberof PipelineJob
     */
    'status': string;
    /**
     * An event on which job is waiting
     * @type {string}
     * @memberof PipelineJob
     */
    'waiting_for'?: string;
    /**
     * A human-readable message indicating the reason for the status.
     * @type {string}
     * @memberof PipelineJob
     */
    'status_message': string;
    /**
     * The date and time when this Job was first created within the Run.
     * @type {string}
     * @memberof PipelineJob
     */
    'created_at': string;
    /**
     * The date and time when this Job was updated while executing.
     * @type {string}
     * @memberof PipelineJob
     */
    'updated_at': string;
    /**
     * The date and time when cancellation of this Job was requested.
     * @type {string}
     * @memberof PipelineJob
     */
    'cancellation_requested_at'?: string;
    /**
     * The date and time when this Job entered a successful, failed, or cancelled status.
     * @type {string}
     * @memberof PipelineJob
     */
    'completed_at'?: string;
    /**
     * The timeout for this Job.
     * @type {number}
     * @memberof PipelineJob
     */
    'timeout_seconds': number;
    /**
     * The collection of Steps that completed along with the current Step being executed.
     * @type {Array<PipelineStep>}
     * @memberof PipelineJob
     */
    'steps': Array<PipelineStep>;
}
/**
 * 
 * @export
 * @interface PipelineJobAllOf
 */
export interface PipelineJobAllOf {
    /**
     * The collection of Steps that completed along with the current Step being executed.
     * @type {Array<PipelineStep>}
     * @memberof PipelineJobAllOf
     */
    'steps': Array<PipelineStep>;
}
/**
 * Partial details of a Job within the Run. The full details, including steps, can be retrieved using the GetPipelineJob operation.
 * @export
 * @interface PipelineJobPartial
 */
export interface PipelineJobPartial {
    /**
     * The id of the Job within the Run.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'id': string;
    /**
     * The current entity tag value for this Job.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'etag': string;
    /**
     * The id of the Organization containing this Job.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'org_id': string;
    /**
     * The id of the Application containing this Job.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'app_id': string;
    /**
     * The id of the Pipeline.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'pipeline_id': string;
    /**
     * The id of the Pipeline Version associated with the Run.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'pipeline_version': string;
    /**
     * The id of the Run containing this Job.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'run_id': string;
    /**
     * The current status of this Job.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'status': string;
    /**
     * An event on which job is waiting
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'waiting_for'?: string;
    /**
     * A human-readable message indicating the reason for the status.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'status_message': string;
    /**
     * The date and time when this Job was first created within the Run.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'created_at': string;
    /**
     * The date and time when this Job was updated while executing.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'updated_at': string;
    /**
     * The date and time when cancellation of this Job was requested.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'cancellation_requested_at'?: string;
    /**
     * The date and time when this Job entered a successful, failed, or cancelled status.
     * @type {string}
     * @memberof PipelineJobPartial
     */
    'completed_at'?: string;
    /**
     * The timeout for this Job.
     * @type {number}
     * @memberof PipelineJobPartial
     */
    'timeout_seconds': number;
}
/**
 * Details of a Run within the Pipeline.
 * @export
 * @interface PipelineRun
 */
export interface PipelineRun {
    /**
     * The unique id of the Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'id': string;
    /**
     * The current entity tag value for this Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'etag': string;
    /**
     * The id of the Organization containing this Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'org_id': string;
    /**
     * The id of the Application containing this Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'app_id': string;
    /**
     * Environments linked to this Pipeline Run through input parameters or step executions.
     * @type {Array<string>}
     * @memberof PipelineRun
     */
    'env_ids': Array<string>;
    /**
     * The id of the Pipeline associated with the Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'pipeline_id': string;
    /**
     * The id of the Pipeline Version associated with the Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'pipeline_version': string;
    /**
     * The current status of this Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'status': string;
    /**
     * A human-readable message indicating the reason for the status.
     * @type {string}
     * @memberof PipelineRun
     */
    'status_message': string;
    /**
     * The date and time when this Run was first created.
     * @type {string}
     * @memberof PipelineRun
     */
    'created_at': string;
    /**
     * User id that created or triggered the Run.
     * @type {string}
     * @memberof PipelineRun
     */
    'created_by': string;
    /**
     * The date and time when this Run entered executing status.
     * @type {string}
     * @memberof PipelineRun
     */
    'executing_at'?: string;
    /**
     * The date and time when cancellation of this Run was requested.
     * @type {string}
     * @memberof PipelineRun
     */
    'cancellation_requested_at'?: string;
    /**
     * The date and time when this Run entered a successful, failed, or cancelled status.
     * @type {string}
     * @memberof PipelineRun
     */
    'completed_at'?: string;
    /**
     * The timeout for this Run.
     * @type {number}
     * @memberof PipelineRun
     */
    'timeout_seconds': number;
    /**
     * The trigger type that was triggered this Run to start.
     * @type {string}
     * @memberof PipelineRun
     */
    'trigger': string;
    /**
     * The inputs that were provided for this Run.
     * @type {{ [key: string]: any; }}
     * @memberof PipelineRun
     */
    'inputs': { [key: string]: any; };
    /**
     * The user id that the pipeline run is executing as when it calls Humanitec APIs.
     * @type {string}
     * @memberof PipelineRun
     */
    'run_as': string;
    /**
     * The optional concurrency group for this run within the application
     * @type {string}
     * @memberof PipelineRun
     */
    'concurrency_group'?: string;
    /**
     * Aggregated events on which run\'s jobs are waiting for
     * @type {{ [key: string]: string; }}
     * @memberof PipelineRun
     */
    'waiting_for': { [key: string]: string; };
}
/**
 * The parameters for creating a new Run for the Pipeline.
 * @export
 * @interface PipelineRunCreateBody
 */
export interface PipelineRunCreateBody {
    /**
     * The inputs provided for this Run.
     * @type {{ [key: string]: any; }}
     * @memberof PipelineRunCreateBody
     */
    'inputs': { [key: string]: any; };
}
/**
 * Trigger the pipeline that has a deployment_request trigger and criteria that match this target environment. If \"delta_id\" or \"set_id\" is provided, the matching criteria must support deployment type \"deploy\". If \"deployment_id\" is provided, the matching criteria must support deployment type \"re-deploy\". When \"delta_id\" is provided, the inputs to the Pipeline Run will be \"env_id\", \"comment\", \"delta_id\" and \"value_set_version_id\" if provided. When \"deployment_id\" is provided, the inputs to the Pipeline Run will be \"env_id\", \"comment\", \"deployment_id\", with \"set_id\", \"value_set_version_id\" being retrieved from the deployment itself. When \"set_id\" is provided, the inputs to the Pipeline Run will be \"env_id\", \"comment\", \"set_id\", and \"value_set_version_id\" if provided. 
 * @export
 * @interface PipelineRunCreateByDeploymentRequestCriteriaBody
 */
export interface PipelineRunCreateByDeploymentRequestCriteriaBody {
    /**
     * The target environment within the Application to deploy to.
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'env_id'?: string;
    /**
     * The target environment within the Application to deploy to.
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     * @deprecated
     */
    'environment'?: string;
    /**
     * A deployment delta to apply to the target environment. This delta must already exist. This field is mutually exclusive with \"deployment_id\" and \"set_id\".
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'delta_id'?: string;
    /**
     * An existing deployment to redeploy into the target environment. The deployment set and value set will be copied. This field is mutually exclusive with \"delta_id\" and \"set_id\".
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'deployment_id'?: string;
    /**
     * A direct deployment set to apply to the target environment. This deployment set must already exist. This field is mutually exclusive with \"delta_id\" and \"set_id\".
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'set_id'?: string;
    /**
     * The exact value set version to use when deploying to the target environment. This value set version must exist. This field can only be used when \"delta_id\" or \"set_id\" is specified.
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'value_set_version_id'?: string;
    /**
     * An optional comment to apply to the Deployment.
     * @type {string}
     * @memberof PipelineRunCreateByDeploymentRequestCriteriaBody
     */
    'comment'?: string;
}
/**
 * @type PipelineRunCreateByTriggerCriteriaBody
 * The parameters for creating a new Run based on trigger and inputs.
 * @export
 */
export type PipelineRunCreateByTriggerCriteriaBody = { trigger: 'deployment_request' } & PipelineRunCreateByDeploymentRequestCriteriaBody;

/**
 * A Step within a Job.
 * @export
 * @interface PipelineStep
 */
export interface PipelineStep {
    /**
     * The index of the Step within the Pipeline Schema.
     * @type {number}
     * @memberof PipelineStep
     */
    'index': number;
    /**
     * The name of the step or a generated default.
     * @type {string}
     * @memberof PipelineStep
     */
    'name': string;
    /**
     * The action used by this step.
     * @type {string}
     * @memberof PipelineStep
     */
    'uses': string;
    /**
     * The current status of this Step within the Job.
     * @type {string}
     * @memberof PipelineStep
     */
    'status': string;
    /**
     * A human-readable message indicating the reason for the status.
     * @type {string}
     * @memberof PipelineStep
     */
    'status_message': string;
    /**
     * The date and time when this Step was first created within the Job.
     * @type {string}
     * @memberof PipelineStep
     */
    'created_at': string;
    /**
     * The date and time when this Step entered a successful, failed, or cancelled status.
     * @type {string}
     * @memberof PipelineStep
     */
    'completed_at'?: string;
    /**
     * The timeout for this Step.
     * @type {number}
     * @memberof PipelineStep
     */
    'timeout_seconds': number;
    /**
     * A map of related object ids that this step created or interacted with.
     * @type {{ [key: string]: string; }}
     * @memberof PipelineStep
     */
    'related_entities': { [key: string]: string; };
}
/**
 * An item from the logs of a Step.
 * @export
 * @interface PipelineStepLog
 */
export interface PipelineStepLog {
    /**
     * The date and time when this message was emitted or captured.
     * @type {string}
     * @memberof PipelineStepLog
     */
    'at': string;
    /**
     * The log level of the message.
     * @type {string}
     * @memberof PipelineStepLog
     */
    'level': string;
    /**
     * The content of the message.
     * @type {string}
     * @memberof PipelineStepLog
     */
    'message': string;
}
/**
 * An object containing the details of a Pipeline.
 * @export
 * @interface PipelineVersion
 */
export interface PipelineVersion {
    /**
     * The unique id of the current Pipeline Version.
     * @type {string}
     * @memberof PipelineVersion
     */
    'id': string;
    /**
     * The id of the Organization containing this Run.
     * @type {string}
     * @memberof PipelineVersion
     */
    'org_id': string;
    /**
     * The id of the Application containing this Run.
     * @type {string}
     * @memberof PipelineVersion
     */
    'app_id': string;
    /**
     * The id of the Pipeline associated with the Run.
     * @type {string}
     * @memberof PipelineVersion
     */
    'pipeline_id': string;
    /**
     * User id of the pipeline version.
     * @type {string}
     * @memberof PipelineVersion
     */
    'created_by': string;
    /**
     * The date and time when the specific pipeline version was created.
     * @type {string}
     * @memberof PipelineVersion
     */
    'created_at': string;
}
/**
 * Similar to the delta response, except the id and metadata properties.  **Basic Structure**  ```  {    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface PlainDeltaResponse
 */
export interface PlainDeltaResponse {
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof PlainDeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof PlainDeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateResponse
 */
export interface PodStateResponse {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateResponse
     */
    'containerStatuses': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'phase': string;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'podName': string;
    /**
     * 
     * @type {number}
     * @memberof PodStateResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'status': string;
}
/**
 * ProvisionDependencies defines resources which are needed to be co-provisioned with the current resource.
 * @export
 * @interface ProvisionDependenciesRequest
 */
export interface ProvisionDependenciesRequest {
    /**
     * If the co-provisioned resource is dependendent on the current one.
     * @type {boolean}
     * @memberof ProvisionDependenciesRequest
     */
    'is_dependent'?: boolean;
    /**
     * If the resources dependant on the main resource, are also dependant on the co-provisioned one.
     * @type {boolean}
     * @memberof ProvisionDependenciesRequest
     */
    'match_dependents'?: boolean;
}
/**
 * ProvisionDependencies defines resources which are needed to be co-provisioned with the current resource.
 * @export
 * @interface ProvisionDependenciesResponse
 */
export interface ProvisionDependenciesResponse {
    /**
     * If the co-provisioned resource is dependendent on the current one.
     * @type {boolean}
     * @memberof ProvisionDependenciesResponse
     */
    'is_dependent': boolean;
    /**
     * If the resources dependant on the main resource, are also dependant on the co-provisioned one.
     * @type {boolean}
     * @memberof ProvisionDependenciesResponse
     */
    'match_dependents'?: boolean;
}
/**
 * PublicKey stores a Public Key an organization shares with Humanitec.
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'expired_at': string;
    /**
     * It\'s the hexadecimal representation of the sha256 hash of the DER representation of the key, it\'s computed and stored when a new key is uploaded.
     * @type {string}
     * @memberof PublicKey
     */
    'fingerprint': string;
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsResponse
 */
export interface RegistryCredsResponse {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'password': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
    /**
     * Security account login or token.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'username': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryRequest
 */
export interface RegistryRequest {
    /**
     * 
     * @type {AccountCredsRequest}
     * @memberof RegistryRequest
     */
    'creds'?: AccountCredsRequest;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryRequest
     */
    'enable_ci'?: boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryRequest
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryRequest
     */
    'type': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryResponse
 */
export interface RegistryResponse {
    /**
     * The timestamp of when this record was created.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_at'?: string | null;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_by'?: string;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryResponse
     */
    'enable_ci': boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryResponse
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryResponse
     */
    'secrets'?: { [key: string]: ClusterSecretResponse; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryResponse
     */
    'type': string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountResponse
 */
export interface ResourceAccountResponse {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_by': string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'id': string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountResponse
     */
    'is_used': boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'type': string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeResponse
 */
export interface ResourceDefinitionChangeResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'app_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'env_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'from_def': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'res_id': string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'to_def': string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionResponse
 */
export interface ResourceDefinitionResponse {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_at': string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_by': string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof ResourceDefinitionResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRefsResponse}
     * @memberof ResourceDefinitionResponse
     */
    'driver_inputs'?: ValuesSecretsRefsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'id': string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_default': boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_deleted': boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'name': string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'org_id': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource.
     * @type {{ [key: string]: ProvisionDependenciesResponse; }}
     * @memberof ResourceDefinitionResponse
     */
    'provision'?: { [key: string]: ProvisionDependenciesResponse; };
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner, specifying the resources to be provisioned.
 * @export
 * @interface ResourceProvisionRequestRequest
 */
export interface ResourceProvisionRequestRequest {
    /**
     * (Optional) A resource class
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'class'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set.
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'type': string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeRequest
 */
export interface ResourceTypeRequest {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'category'?: string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'name'?: string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'outputs_schema'?: { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'type': string;
    /**
     * Kind of dependency between resource of this type and a workload. It should be one of: `direct`, `indirect`, `implicit`.
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'use': string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeResponse
 */
export interface ResourceTypeResponse {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'category': string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'name': string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'outputs_schema': { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'type': string;
    /**
     * Kind of dependency between resource of this type and a workload. It should be one of: `direct`, `indirect`, `implicit`.
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'use': string;
}
/**
 * Role defines the role that will be used in request
 * @export
 * @interface RoleRequest
 */
export interface RoleRequest {
    /**
     * 
     * @type {string}
     * @memberof RoleRequest
     */
    'role'?: string;
}
/**
 * Details about the container\'s current condition.
 * @export
 * @interface RuntimeInfoContainerState
 */
export interface RuntimeInfoContainerState {
    /**
     * 
     * @type {RuntimeInfoControllerStateWaiting}
     * @memberof RuntimeInfoContainerState
     */
    'waiting'?: RuntimeInfoControllerStateWaiting;
    /**
     * 
     * @type {RuntimeInfoContainerStateRunning}
     * @memberof RuntimeInfoContainerState
     */
    'running'?: RuntimeInfoContainerStateRunning;
    /**
     * 
     * @type {RuntimeInfoContainerStateTerminated}
     * @memberof RuntimeInfoContainerState
     */
    'terminated'?: RuntimeInfoContainerStateTerminated;
}
/**
 * Details about a running container.
 * @export
 * @interface RuntimeInfoContainerStateRunning
 */
export interface RuntimeInfoContainerStateRunning {
    /**
     * Time at which the container was last (re-)started.
     * @type {string}
     * @memberof RuntimeInfoContainerStateRunning
     */
    'started_at'?: string;
}
/**
 * Details about a terminated container.
 * @export
 * @interface RuntimeInfoContainerStateTerminated
 */
export interface RuntimeInfoContainerStateTerminated {
    /**
     * Exit status from the last termination of the container.
     * @type {number}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'exit_code'?: number;
    /**
     * Signal from the last termination of the container.
     * @type {number}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'signal'?: number;
    /**
     * Reason from the last termination of the container.
     * @type {string}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'reason'?: string;
    /**
     * Message regarding the last termination of the container.
     * @type {string}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'message'?: string;
    /**
     * Time at which previous execution of the container started.
     * @type {string}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'started_at'?: string;
    /**
     * Time at which the container last terminated.
     * @type {string}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'finished_at'?: string;
    /**
     * Container\'s ID in the format \'<type>://<container_id>\'.
     * @type {string}
     * @memberof RuntimeInfoContainerStateTerminated
     */
    'container_id'?: string;
}
/**
 * Container status.
 * @export
 * @interface RuntimeInfoContainerStatus
 */
export interface RuntimeInfoContainerStatus {
    /**
     * Container name.
     * @type {string}
     * @memberof RuntimeInfoContainerStatus
     */
    'name': string;
    /**
     * If a container is ready to start accept traffic.
     * @type {boolean}
     * @memberof RuntimeInfoContainerStatus
     */
    'ready': boolean;
    /**
     * The number of times the container has been restarted.
     * @type {number}
     * @memberof RuntimeInfoContainerStatus
     */
    'restart_count'?: number;
    /**
     * Container status derived from its state and readiness.
     * @type {string}
     * @memberof RuntimeInfoContainerStatus
     */
    'status': RuntimeInfoContainerStatusStatusEnum;
    /**
     * 
     * @type {RuntimeInfoContainerState}
     * @memberof RuntimeInfoContainerStatus
     */
    'state': RuntimeInfoContainerState;
}

export const RuntimeInfoContainerStatusStatusEnum = {
    Failure: 'Failure',
    Success: 'Success',
    Pending: 'Pending',
    Unknown: 'Unknown'
} as const;

export type RuntimeInfoContainerStatusStatusEnum = typeof RuntimeInfoContainerStatusStatusEnum[keyof typeof RuntimeInfoContainerStatusStatusEnum];

/**
 * Details about a waiting container
 * @export
 * @interface RuntimeInfoControllerStateWaiting
 */
export interface RuntimeInfoControllerStateWaiting {
    /**
     * Reason the container is not yet running.
     * @type {string}
     * @memberof RuntimeInfoControllerStateWaiting
     */
    'reason'?: string;
    /**
     * Message regarding why the container is not yet running.
     * @type {string}
     * @memberof RuntimeInfoControllerStateWaiting
     */
    'message'?: string;
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module.
 * @export
 * @interface RuntimeInfoModule
 */
export interface RuntimeInfoModule {
    /**
     * 
     * @type {RuntimeInfoStatus}
     * @memberof RuntimeInfoModule
     */
    'status': RuntimeInfoStatus;
    /**
     * 
     * @type {RuntimeInfoStatusClass}
     * @memberof RuntimeInfoModule
     */
    'status_class': RuntimeInfoStatusClass;
    /**
     * A collection of workload controllers.
     * @type {{ [key: string]: RuntimeInfoModuleController; }}
     * @memberof RuntimeInfoModule
     */
    'controllers': { [key: string]: RuntimeInfoModuleController; };
}


/**
 * K8s controller.
 * @export
 * @interface RuntimeInfoModuleController
 */
export interface RuntimeInfoModuleController {
    /**
     * Controller kind.
     * @type {string}
     * @memberof RuntimeInfoModuleController
     */
    'kind': string;
    /**
     * The most recently observed number of replicas.
     * @type {number}
     * @memberof RuntimeInfoModuleController
     */
    'replicas'?: number;
    /**
     * 
     * @type {RuntimeInfoStatus}
     * @memberof RuntimeInfoModuleController
     */
    'status': RuntimeInfoStatus;
    /**
     * If a controller is not in a successful status, the reason from its condition.
     * @type {string}
     * @memberof RuntimeInfoModuleController
     */
    'message'?: string;
    /**
     * List of pods which belong to the controller.
     * @type {Array<RuntimeInfoPod>}
     * @memberof RuntimeInfoModuleController
     */
    'pods'?: Array<RuntimeInfoPod>;
    /**
     * Revision of the controller.
     * @type {number}
     * @memberof RuntimeInfoModuleController
     */
    'revision'?: number;
}


/**
 * k8s pod.
 * @export
 * @interface RuntimeInfoPod
 */
export interface RuntimeInfoPod {
    /**
     * Pod name.
     * @type {string}
     * @memberof RuntimeInfoPod
     */
    'podName': string;
    /**
     * Revision of the pod.
     * @type {number}
     * @memberof RuntimeInfoPod
     */
    'revision'?: number;
    /**
     * A simple, high-level summary of where the Pod is in its lifecycle.
     * @type {string}
     * @memberof RuntimeInfoPod
     */
    'phase': RuntimeInfoPodPhaseEnum;
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoPod
     */
    'status': RuntimeInfoPodStatusEnum;
    /**
     * The list has one entry per container in the manifest.
     * @type {Array<RuntimeInfoContainerStatus>}
     * @memberof RuntimeInfoPod
     */
    'containerStatuses': Array<RuntimeInfoContainerStatus>;
}

export const RuntimeInfoPodPhaseEnum = {
    Pending: 'Pending',
    Running: 'Running',
    Succeeded: 'Succeeded',
    Failed: 'Failed',
    Unknown: 'Unknown'
} as const;

export type RuntimeInfoPodPhaseEnum = typeof RuntimeInfoPodPhaseEnum[keyof typeof RuntimeInfoPodPhaseEnum];
export const RuntimeInfoPodStatusEnum = {
    Failure: 'Failure',
    Success: 'Success',
    Pending: 'Pending',
    Unknown: 'Unknown'
} as const;

export type RuntimeInfoPodStatusEnum = typeof RuntimeInfoPodStatusEnum[keyof typeof RuntimeInfoPodStatusEnum];

/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoResponseV1
 */
export interface RuntimeInfoResponseV1 {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof RuntimeInfoResponseV1
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoResponseV1
     */
    'namespace': string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoResponseV2
 */
export interface RuntimeInfoResponseV2 {
    /**
     * Modules represent a collection of workloads for the application.
     * @type {{ [key: string]: RuntimeInfoModule; }}
     * @memberof RuntimeInfoResponseV2
     */
    'modules': { [key: string]: RuntimeInfoModule; };
    /**
     * The namespace where the application runs.
     * @type {string}
     * @memberof RuntimeInfoResponseV2
     */
    'namespace': string;
}
/**
 * Workload status.
 * @export
 * @enum {string}
 */

export const RuntimeInfoStatus = {
    Running: 'Running',
    Succeeded: 'Succeeded',
    Starting: 'Starting',
    PartiallySucceeded: 'Partially Succeeded',
    Failed: 'Failed',
    Stopped: 'Stopped',
    Unknown: 'Unknown'
} as const;

export type RuntimeInfoStatus = typeof RuntimeInfoStatus[keyof typeof RuntimeInfoStatus];


/**
 * Status class, statuses are aggregated into classes
 * @export
 * @enum {string}
 */

export const RuntimeInfoStatusClass = {
    Success: 'Success',
    Failure: 'Failure',
    Warning: 'Warning',
    Stopped: 'Stopped',
    Unknown: 'Unknown'
} as const;

export type RuntimeInfoStatusClass = typeof RuntimeInfoStatusClass[keyof typeof RuntimeInfoStatusClass];


/**
 * It stores sensitive value in the organization primary store or a reference to a sensitive value stored in a store registered under the organization.
 * @export
 * @interface SecretReference
 */
export interface SecretReference {
    /**
     * Secret Store id. This can\'t be `humanitec` (our internal Secret Store). It\'s mandatory if `ref` is defined and can\'t be used if `value` is defined.
     * @type {string}
     * @memberof SecretReference
     */
    'store'?: string;
    /**
     * Secret reference in the format of the target store. It can\'t be defined if `value` is defined.
     * @type {string}
     * @memberof SecretReference
     */
    'ref'?: string;
    /**
     * Optional, only valid if `ref` is defined. It\'s the version of the secret as defined in the target store.
     * @type {string}
     * @memberof SecretReference
     */
    'version'?: string;
    /**
     * Value to store in the secret store. It can\'t be defined if `ref` is defined.
     * @type {string}
     * @memberof SecretReference
     */
    'value'?: string;
}
/**
 * Secret Store represents external secret management system used by an organization to store secrets referenced in Humanitec.
 * @export
 * @interface SecretStoreRequest
 */
export interface SecretStoreRequest {
    /**
     * 
     * @type {AWSSMRequest}
     * @memberof SecretStoreRequest
     */
    'awssm'?: AWSSMRequest;
    /**
     * 
     * @type {AzureKVRequest}
     * @memberof SecretStoreRequest
     */
    'azurekv'?: AzureKVRequest;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {GCPSMRequest}
     * @memberof SecretStoreRequest
     */
    'gcpsm'?: GCPSMRequest;
    /**
     * Humanitec built-in Secret Store specification.
     * @type {object}
     * @memberof SecretStoreRequest
     */
    'humanitec'?: object;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SecretStoreRequest
     */
    'primary'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreRequest
     */
    'updated_by'?: string;
    /**
     * 
     * @type {VaultRequest}
     * @memberof SecretStoreRequest
     */
    'vault'?: VaultRequest;
}
/**
 * Secret Store represents external secret management system used by an organization to store secrets referenced in Humanitec.
 * @export
 * @interface SecretStoreResponse
 */
export interface SecretStoreResponse {
    /**
     * 
     * @type {AWSSMResponse}
     * @memberof SecretStoreResponse
     */
    'awssm'?: AWSSMResponse;
    /**
     * 
     * @type {AzureKVResponse}
     * @memberof SecretStoreResponse
     */
    'azurekv'?: AzureKVResponse;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreResponse
     */
    'created_by': string;
    /**
     * 
     * @type {GCPSMResponse}
     * @memberof SecretStoreResponse
     */
    'gcpsm'?: GCPSMResponse;
    /**
     * Humanitec built-in Secret Store specification.
     * @type {object}
     * @memberof SecretStoreResponse
     */
    'humanitec'?: object;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof SecretStoreResponse
     */
    'primary': boolean;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof SecretStoreResponse
     */
    'updated_by': string;
    /**
     * 
     * @type {VaultResponse}
     * @memberof SecretStoreResponse
     */
    'vault'?: VaultResponse;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetRequest
 */
export interface SetRequest {
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof SetRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetRequest
     */
    'shared'?: { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetRequest
     */
    'version'?: number;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetResponse
 */
export interface SetResponse {
    /**
     * The ID which is a hash of the content of the Deployment Set.
     * @type {string}
     * @memberof SetResponse
     */
    'id': string;
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof SetResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetResponse
     */
    'shared': { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetResponse
     */
    'version': number;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionRequest
 */
export interface TokenDefinitionRequest {
    /**
     * A description of the token. (Optional)
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'description'?: string;
    /**
     * The time the token expires. If not set, the token will not expire. (Optional)
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'expires_at'?: string;
    /**
     * Identifier of the token. Must be unique for the user.
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'id': string;
    /**
     * The type of the token. Can only be \"static\".
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'type': string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoResponse
 */
export interface TokenInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'type': string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'type'?: string;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionRequest
 */
export interface UpdateActionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionRequest
     */
    'value'?: any | null;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionResponse
 */
export interface UpdateActionResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionResponse
     */
    'value'?: any;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadRequest
 */
export interface UpdateArtefactVersionPayloadRequest {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadRequest
     */
    'archived': boolean | null;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestRequest
 */
export interface UpdateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDriverRequestRequest
     * @deprecated
     */
    'is_public'?: boolean;
}
/**
 * UpdateEnvironmentTypePayload contains the `description` field that should be set in the Environment Type to update.
 * @export
 * @interface UpdateEnvironmentTypePayloadRequest
 */
export interface UpdateEnvironmentTypePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateEnvironmentTypePayloadRequest
     */
    'description'?: string | null;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestRequest
 */
export interface UpdateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'name'?: string;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestRequest
 */
export interface UpdateResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRefsRequest}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRefsRequest;
    /**
     * The display name.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource or if they have the same dependent resources.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
}
/**
 * Secret Store represents external secret management system used by an organization to store secrets referenced in Humanitec.
 * @export
 * @interface UpdateSecretStorePayloadRequest
 */
export interface UpdateSecretStorePayloadRequest {
    /**
     * 
     * @type {AWSSMRequest}
     * @memberof UpdateSecretStorePayloadRequest
     */
    'awssm'?: AWSSMRequest;
    /**
     * 
     * @type {AzureKVRequest}
     * @memberof UpdateSecretStorePayloadRequest
     */
    'azurekv'?: AzureKVRequest;
    /**
     * 
     * @type {GCPSMRequest}
     * @memberof UpdateSecretStorePayloadRequest
     */
    'gcpsm'?: GCPSMRequest;
    /**
     * Defines whether the Secret Store is the primary secret management system for the organization.
     * @type {boolean}
     * @memberof UpdateSecretStorePayloadRequest
     */
    'primary'?: boolean | null;
    /**
     * 
     * @type {VaultRequest}
     * @memberof UpdateSecretStorePayloadRequest
     */
    'vault'?: VaultRequest;
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestRequest
 */
export interface UserInviteRequestRequest {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'role': string;
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteResponse
 */
export interface UserInviteResponse {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_by': string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'expires_at': string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'user_id': string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedRequest
 */
export interface UserProfileExtendedRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedRequest
     */
    'properties'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedRequest
     */
    'roles'?: { [key: string]: string; };
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'type'?: string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedResponse
 */
export interface UserProfileExtendedResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedResponse
     */
    'properties': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedResponse
     */
    'roles': { [key: string]: string; };
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'type': string;
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileResponse
     */
    'type': string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleRequest
 */
export interface UserRoleRequest {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleRequest
     */
    'role'?: string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleRequest
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleRequest
     */
    'id'?: string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleRequest
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleRequest
     */
    'name'?: string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserRoleRequest
     */
    'type'?: string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleResponse
 */
export interface UserRoleResponse {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleResponse
     */
    'role': string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleResponse
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleResponse
     */
    'id': string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleResponse
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleResponse
     */
    'name': string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserRoleResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadRequest
 */
export interface ValueCreatePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'value'?: string | null;
    /**
     * 
     * @type {SecretReference}
     * @memberof ValueCreatePayloadRequest
     */
    'secret_ref'?: SecretReference | null;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadRequest
 */
export interface ValueEditPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'value'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueEditPayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'key'?: string;
    /**
     * 
     * @type {SecretReference}
     * @memberof ValueEditPayloadRequest
     */
    'secret_ref'?: SecretReference | null;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadRequest
 */
export interface ValuePatchPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'value'?: string | null;
    /**
     * 
     * @type {SecretReference}
     * @memberof ValuePatchPayloadRequest
     */
    'secret_ref'?: SecretReference | null;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueRequest
 */
export interface ValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueRequest
     */
    'key'?: string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueRequest
     */
    'value'?: string;
    /**
     * 
     * @type {SecretReference}
     * @memberof ValueRequest
     */
    'secret_ref'?: SecretReference | null;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueResponse
 */
export interface ValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueResponse
     */
    'key': string;
    /**
     * Location of the secret value in the secret store.
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_key': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_store_id': string | null;
    /**
     * Version of the current secret value as returned by the secret store.
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_version': string | null;
    /**
     * 
     * @type {ValueSource}
     * @memberof ValueResponse
     */
    'source': ValueSource;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ValueSetActionPayloadRequest
 */
export interface ValueSetActionPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadRequest
     */
    'comment'?: string;
}
/**
 * A Value Set Version can be used as a track record of Shared Values changes, to restore a previous version of a Shared Value or Value Set, or to purge a Shared Value if it shouldn\'t be accessible anymore.
 * @export
 * @interface ValueSetVersionResponse
 */
export interface ValueSetVersionResponse {
    /**
     * 
     * @type {Array<JSONPatchResponse>}
     * @memberof ValueSetVersionResponse
     */
    'change': Array<JSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {ValueSetVersionResultOf}
     * @memberof ValueSetVersionResponse
     */
    'result_of': ValueSetVersionResultOf | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: ValueResponse; }}
     * @memberof ValueSetVersionResponse
     */
    'values': { [key: string]: ValueResponse; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ValueSetVersionResultOf = {
    AppValueCreate: 'app_value_create',
    AppValueUpdate: 'app_value_update',
    AppValueDelete: 'app_value_delete',
    AppValuesDelete: 'app_values_delete',
    AppValueSetVersionRestore: 'app_value_set_version_restore',
    AppValueSetVersionPurge: 'app_value_set_version_purge',
    EnvValueCreate: 'env_value_create',
    EnvValueUpdate: 'env_value_update',
    EnvValueDelete: 'env_value_delete',
    EnvValuesDelete: 'env_values_delete',
    EnvValueSetVersionRestore: 'env_value_set_version_restore',
    EnvValueSetVersionPurge: 'env_value_set_version_purge'
} as const;

export type ValueSetVersionResultOf = typeof ValueSetVersionResultOf[keyof typeof ValueSetVersionResultOf];


/**
 * Source of the value, \"app\" for app level, \"env\" for app env level.
 * @export
 * @enum {string}
 */

export const ValueSource = {
    App: 'app',
    Env: 'env'
} as const;

export type ValueSource = typeof ValueSource[keyof typeof ValueSource];


/**
 * ValuesSecretsRefs stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsRefsRequest
 */
export interface ValuesSecretsRefsRequest {
    /**
     * Secrets section of the data set. They can hold sensitive information that will be stored in the primary organization secret store and replaced with the secret store paths when sent outside, or secret references stored in a defined secret store. Can\'t be used together with `secrets`.  They can hold a nested structure but leaf objects need to be of type SecretReference, where:  - `store` is a Secret Store id. It can\'t be `humanitec`. It\'s mandatory if `ref` is defined and can\'t be used in request payloads if `value` is defined.  - `ref` is the secret key in the format of the target store. It can\'t be used in request payloads if `value` is defined.  - `version` is the version of the secret as defined in the target store. It can be defined only if `ref` is defined.  - `value` is the value to store in the organizations primary secret store. It can\'t be used in request payloads if `ref` is defined.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsRequest
     */
    'secret_refs'?: { [key: string]: any; };
    /**
     * Secrets section of the data set. Sensitive information is stored in the primary organization secret store and replaced with the secret store paths when sent outside. Can\'t be used together with `secret_refs`.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsRequest
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsRequest
     */
    'values'?: { [key: string]: any; };
}
/**
 * ValuesSecretsRefs stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsRefsResponse
 */
export interface ValuesSecretsRefsResponse {
    /**
     * Secrets section of the data set. They can hold sensitive information that will be stored in the primary organization secret store and replaced with the secret store paths when sent outside, or secret references stored in a defined secret store. Can\'t be used together with `secrets`.  They can hold a nested structure but leaf objects need to be of type SecretReference, where:  - `store` is a Secret Store id. It can\'t be `humanitec`. It\'s mandatory if `ref` is defined and can\'t be used in request payloads if `value` is defined.  - `ref` is the secret key in the format of the target store. It can\'t be used in request payloads if `value` is defined.  - `version` is the version of the secret as defined in the target store. It can be defined only if `ref` is defined.  - `value` is the value to store in the organizations primary secret store. It can\'t be used in request payloads if `ref` is defined.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsResponse
     */
    'secret_refs'?: { [key: string]: any; };
    /**
     * Secrets section of the data set. Sensitive information is stored in the primary organization secret store and replaced with the secret store paths when sent outside. Can\'t be used together with `secret_refs`.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsResponse
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRefsResponse
     */
    'values'?: { [key: string]: any; };
}
/**
 * Credentials to authenticate Vault.
 * @export
 * @interface VaultAuthRequest
 */
export interface VaultAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultAuthRequest
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultAuthRequest
     */
    'token'?: string;
}
/**
 * Vault specification.
 * @export
 * @interface VaultRequest
 */
export interface VaultRequest {
    /**
     * 
     * @type {string}
     * @memberof VaultRequest
     */
    'agent_id'?: string;
    /**
     * 
     * @type {VaultAuthRequest}
     * @memberof VaultRequest
     */
    'auth'?: VaultAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof VaultRequest
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultRequest
     */
    'url'?: string;
}
/**
 * Vault specification.
 * @export
 * @interface VaultResponse
 */
export interface VaultResponse {
    /**
     * 
     * @type {string}
     * @memberof VaultResponse
     */
    'agent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultResponse
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultResponse
     */
    'url'?: string;
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookRequest
 */
export interface WebhookRequest {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'headers'?: { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookRequest
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'payload'?: { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseRequest>}
     * @memberof WebhookRequest
     */
    'triggers'?: Array<EventBaseRequest>;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported).
     * @type {string}
     * @memberof WebhookRequest
     */
    'url'?: string | null;
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The timestamp of when this Job was created.
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_at'?: string;
    /**
     * The user who created this Job
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_by'?: string;
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'headers': { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookResponse
     */
    'triggers': Array<EventBaseResponse>;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported).
     * @type {string}
     * @memberof WebhookResponse
     */
    'url': string | null;
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookUpdateResponse
 */
export interface WebhookUpdateResponse {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookUpdateResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookUpdateResponse
     */
    'headers': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookUpdateResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookUpdateResponse
     */
    'triggers': Array<EventBaseResponse> | null;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookUpdateResponse
     */
    'url': string | null;
}
/**
 * Details of a Workload Artefact Version
 * @export
 * @interface WorkloadArtefactVersion
 */
export interface WorkloadArtefactVersion {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof WorkloadArtefactVersion
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'commit'?: string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'ref'?: string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof WorkloadArtefactVersion
     */
    'version'?: string;
}
/**
 * Humanitec definition for a Workload Artefact.
 * @export
 * @interface WorkloadArtefactVersionDeploymentSet
 */
export interface WorkloadArtefactVersionDeploymentSet {
    /**
     * The set of workloads to add when deployed, the key is the name of the workload.
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof WorkloadArtefactVersionDeploymentSet
     */
    'modules': { [key: string]: { [key: string]: any; }; };
    /**
     * The set of shared resources to depend on, the key is the resource identifier.
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof WorkloadArtefactVersionDeploymentSet
     */
    'shared': { [key: string]: { [key: string]: any; }; };
}
/**
 * References a workload profile chart.
 * @export
 * @interface WorkloadProfileChartReference
 */
export interface WorkloadProfileChartReference {
    /**
     * Workload Profile Chart ID
     * @type {string}
     * @memberof WorkloadProfileChartReference
     */
    'id': string;
    /**
     * Version
     * @type {string}
     * @memberof WorkloadProfileChartReference
     */
    'version': string;
}
/**
 * Each Workload Profile Chart has one or more Versions associated with it.
 * @export
 * @interface WorkloadProfileChartVersionResponse
 */
export interface WorkloadProfileChartVersionResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileChartVersionResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileChartVersionResponse
     */
    'created_by': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileChartVersionResponse
     */
    'org_id': string;
    /**
     * Workload Profile Chart Version ID
     * @type {string}
     * @memberof WorkloadProfileChartVersionResponse
     */
    'id': string;
    /**
     * Version
     * @type {string}
     * @memberof WorkloadProfileChartVersionResponse
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface WorkloadProfileFeatureResponse
 */
export interface WorkloadProfileFeatureResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileFeatureResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileFeatureResponse
     */
    'org_id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileFeatureResponse
     */
    'schema': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileFeatureResponse
     */
    'version': string;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileRequest
 */
export interface WorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'id': string;
    /**
     * Describes the workload profile
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'description'?: string;
    /**
     * A not-empty string indicates that the workload profile is deprecated.
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'deprecation_message'?: string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinition}
     * @memberof WorkloadProfileRequest
     */
    'spec_definition': WorkloadProfileSpecDefinition;
    /**
     * Version identifier. The version must be unique, but the API doesn\'t not enforce any ordering. Currently workloads will always use the latest update.  If no identifier is provided, the each update will generate a random version identifier.
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileChartReference}
     * @memberof WorkloadProfileRequest
     */
    'workload_profile_chart': WorkloadProfileChartReference;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileResponse
 */
export interface WorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Describes the workload profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'description': string;
    /**
     * A not-empty string indicates that the workload profile is deprecated.
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'deprecation_message'?: string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'id': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'org_id': string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinition}
     * @memberof WorkloadProfileResponse
     */
    'spec_definition': WorkloadProfileSpecDefinition;
    /**
     * OpenAPI schema used to validate the spec.
     * @type {any}
     * @memberof WorkloadProfileResponse
     */
    'spec_schema': any;
    /**
     * Timestamp when the entity was last updated.
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'updated_at': string;
    /**
     * User who last updated the entity.
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'updated_by': string;
    /**
     * Version identifier.
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'version': string;
    /**
     * 
     * @type {WorkloadProfileChartReference}
     * @memberof WorkloadProfileResponse
     */
    'workload_profile_chart': WorkloadProfileChartReference;
}
/**
 * Workload spec definition
 * @export
 * @interface WorkloadProfileSpecDefinition
 */
export interface WorkloadProfileSpecDefinition {
    /**
     * Workload spec definition
     * @type {{ [key: string]: WorkloadProfileSpecDefinitionProperty; }}
     * @memberof WorkloadProfileSpecDefinition
     */
    'properties'?: { [key: string]: WorkloadProfileSpecDefinitionProperty; };
    /**
     * 
     * @type {Array<WorkloadProfileSpecDefinitionRuntimeProperty>}
     * @memberof WorkloadProfileSpecDefinition
     */
    'runtime_properties'?: Array<WorkloadProfileSpecDefinitionRuntimeProperty>;
}
/**
 * 
 * @export
 * @interface WorkloadProfileSpecDefinitionProperty
 */
export interface WorkloadProfileSpecDefinitionProperty {
    /**
     * 
     * @type {WorkloadProfileSpecDefinitionPropertyType}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'type': WorkloadProfileSpecDefinitionPropertyType;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'feature_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinitionPropertyUIHints}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'ui_hints'?: WorkloadProfileSpecDefinitionPropertyUIHints;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'schema'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<WorkloadProfileSpecDefinitionRuntimeProperty>}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'runtime_properties'?: Array<WorkloadProfileSpecDefinitionRuntimeProperty>;
    /**
     * Workload spec definition
     * @type {{ [key: string]: WorkloadProfileSpecDefinitionProperty; }}
     * @memberof WorkloadProfileSpecDefinitionProperty
     */
    'properties'?: { [key: string]: WorkloadProfileSpecDefinitionProperty; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkloadProfileSpecDefinitionPropertyType = {
    Feature: 'feature',
    Collection: 'collection',
    Schema: 'schema'
} as const;

export type WorkloadProfileSpecDefinitionPropertyType = typeof WorkloadProfileSpecDefinitionPropertyType[keyof typeof WorkloadProfileSpecDefinitionPropertyType];


/**
 * 
 * @export
 * @interface WorkloadProfileSpecDefinitionPropertyUIHints
 */
export interface WorkloadProfileSpecDefinitionPropertyUIHints {
    /**
     * 
     * @type {number}
     * @memberof WorkloadProfileSpecDefinitionPropertyUIHints
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkloadProfileSpecDefinitionPropertyUIHints
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkloadProfileSpecDefinitionRuntimeProperty
 */
export interface WorkloadProfileSpecDefinitionRuntimeProperty {
    /**
     * 
     * @type {WorkloadProfileSpecDefinitionRuntimePropertyType}
     * @memberof WorkloadProfileSpecDefinitionRuntimeProperty
     */
    'type': WorkloadProfileSpecDefinitionRuntimePropertyType;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionRuntimeProperty
     */
    'feature_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionRuntimeProperty
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileSpecDefinitionRuntimeProperty
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinitionPropertyUIHints}
     * @memberof WorkloadProfileSpecDefinitionRuntimeProperty
     */
    'ui_hints'?: WorkloadProfileSpecDefinitionPropertyUIHints;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkloadProfileSpecDefinitionRuntimePropertyType = {
    Feature: 'feature',
    Collection: 'collection'
} as const;

export type WorkloadProfileSpecDefinitionRuntimePropertyType = typeof WorkloadProfileSpecDefinitionRuntimePropertyType[keyof typeof WorkloadProfileSpecDefinitionRuntimePropertyType];


/**
 * The proposed properties to update a workload profile.
 * @export
 * @interface WorkloadProfileUpdateRequest
 */
export interface WorkloadProfileUpdateRequest {
    /**
     * Describes the workload profile
     * @type {string}
     * @memberof WorkloadProfileUpdateRequest
     */
    'description'?: string;
    /**
     * A not-empty string indicates that the workload profile is deprecated.
     * @type {string}
     * @memberof WorkloadProfileUpdateRequest
     */
    'deprecation_message'?: string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinition}
     * @memberof WorkloadProfileUpdateRequest
     */
    'spec_definition': WorkloadProfileSpecDefinition;
    /**
     * Version identifier. The version must be unique, but the API doesn\'t not enforce any ordering. Currently workloads will always use the latest update.  If no identifier is provided, the each update will generate a random version identifier.
     * @type {string}
     * @memberof WorkloadProfileUpdateRequest
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileChartReference}
     * @memberof WorkloadProfileUpdateRequest
     */
    'workload_profile_chart': WorkloadProfileChartReference;
}
/**
 * A version of a workload profile.
 * @export
 * @interface WorkloadProfileVersionResponse
 */
export interface WorkloadProfileVersionResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_by': string;
    /**
     * Describes the workload profile
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'description': string;
    /**
     * A not-empty string indicates that the workload profile is deprecated.
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'deprecation_message'?: string;
    /**
     * ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'id': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'org_id': string;
    /**
     * 
     * @type {WorkloadProfileSpecDefinition}
     * @memberof WorkloadProfileVersionResponse
     */
    'spec_definition': WorkloadProfileSpecDefinition;
    /**
     * OpenAPI schema used to validate the spec.
     * @type {any}
     * @memberof WorkloadProfileVersionResponse
     */
    'spec_schema': any;
    /**
     * 
     * @type {WorkloadProfileChartReference}
     * @memberof WorkloadProfileVersionResponse
     */
    'workload_profile_chart': WorkloadProfileChartReference;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'workload_profile_id': string;
}

/**
 * AccountTypeApi - axios parameter creator
 * @export
 */
export const AccountTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccountTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceAccountTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTypeApi - functional programming interface
 * @export
 */
export const AccountTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceAccountTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAccountTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountTypeApi - factory interface
 * @export
 */
export const AccountTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {AccountTypeApiListResourceAccountTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccountTypes(requestParameters: AccountTypeApiListResourceAccountTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.listResourceAccountTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listResourceAccountTypes operation in AccountTypeApi.
 * @export
 * @interface AccountTypeApiListResourceAccountTypesRequest
 */
export interface AccountTypeApiListResourceAccountTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AccountTypeApiListResourceAccountTypes
     */
    readonly orgId: string
}

/**
 * AccountTypeApi - object-oriented interface
 * @export
 * @class AccountTypeApi
 * @extends {BaseAPI}
 */
export class AccountTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {AccountTypeApiListResourceAccountTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTypeApi
     */
    public listResourceAccountTypes(requestParameters: AccountTypeApiListResourceAccountTypesRequest, options?: AxiosRequestConfig) {
        return AccountTypeApiFp(this.configuration).listResourceAccountTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActiveResourceApi - axios parameter creator
 * @export
 */
export const ActiveResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type, may include a resource class: {type}.{class}.  
         * @param {string} resId The Resource ID.  
         * @param {boolean} [detach] If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActiveResource: async (orgId: string, appId: string, envId: string, type: string, resId: string, detach?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteActiveResource', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteActiveResource', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteActiveResource', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteActiveResource', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('deleteActiveResource', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (detach !== undefined) {
                localVarQueryParameter['detach'] = detach;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResources: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listActiveResources', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listActiveResources', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listActiveResources', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveResourceApi - functional programming interface
 * @export
 */
export const ActiveResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActiveResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type, may include a resource class: {type}.{class}.  
         * @param {string} resId The Resource ID.  
         * @param {boolean} [detach] If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActiveResource(orgId: string, appId: string, envId: string, type: string, resId: string, detach?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActiveResource(orgId, appId, envId, type, resId, detach, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveResourceByDefinition(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveResourceByDefinition(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveResources(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveResources(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActiveResourceApi - factory interface
 * @export
 */
export const ActiveResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActiveResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {ActiveResourceApiDeleteActiveResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActiveResource(requestParameters: ActiveResourceApiDeleteActiveResourceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteActiveResource(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, requestParameters.detach, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {ActiveResourceApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition(requestParameters: ActiveResourceApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {ActiveResourceApiListActiveResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResources(requestParameters: ActiveResourceApiListActiveResourcesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.listActiveResources(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteActiveResource operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiDeleteActiveResourceRequest
 */
export interface ActiveResourceApiDeleteActiveResourceRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly envId: string

    /**
     * The Resource Type, may include a resource class: {type}.{class}.  
     * @type {string}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly type: string

    /**
     * The Resource ID.  
     * @type {string}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly resId: string

    /**
     * If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
     * @type {boolean}
     * @memberof ActiveResourceApiDeleteActiveResource
     */
    readonly detach?: boolean
}

/**
 * Request parameters for listActiveResourceByDefinition operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiListActiveResourceByDefinitionRequest
 */
export interface ActiveResourceApiListActiveResourceByDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiListActiveResourceByDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ActiveResourceApiListActiveResourceByDefinition
     */
    readonly defId: string
}

/**
 * Request parameters for listActiveResources operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiListActiveResourcesRequest
 */
export interface ActiveResourceApiListActiveResourcesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiListActiveResources
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ActiveResourceApiListActiveResources
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ActiveResourceApiListActiveResources
     */
    readonly envId: string
}

/**
 * ActiveResourceApi - object-oriented interface
 * @export
 * @class ActiveResourceApi
 * @extends {BaseAPI}
 */
export class ActiveResourceApi extends BaseAPI {
    /**
     * 
     * @summary Delete Active Resources.
     * @param {ActiveResourceApiDeleteActiveResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public deleteActiveResource(requestParameters: ActiveResourceApiDeleteActiveResourceRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).deleteActiveResource(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, requestParameters.detach, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {ActiveResourceApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public listActiveResourceByDefinition(requestParameters: ActiveResourceApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {ActiveResourceApiListActiveResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public listActiveResources(requestParameters: ActiveResourceApiListActiveResourcesRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).listActiveResources(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {string} orgId The Organization ID
         * @param {AgentCreateBody} agentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent: async (orgId: string, agentCreateBody: AgentCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createAgent', 'orgId', orgId)
            // verify required parameter 'agentCreateBody' is not null or undefined
            assertParamExists('createAgent', 'agentCreateBody', agentCreateBody)
            const localVarPath = `/orgs/{orgId}/agents`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {KeyCreateBody} keyCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (orgId: string, agentId: string, keyCreateBody: KeyCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createKey', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('createKey', 'agentId', agentId)
            // verify required parameter 'keyCreateBody' is not null or undefined
            assertParamExists('createKey', 'keyCreateBody', keyCreateBody)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent: async (orgId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteAgent', 'agentId', agentId)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {string} fingerprint The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyInAgent: async (orgId: string, agentId: string, fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'agentId', agentId)
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'fingerprint', fingerprint)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys/{fingerprint}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} [fingerprint] The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents: async (orgId: string, fingerprint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAgents', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/agents`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeysInAgent: async (orgId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listKeysInAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('listKeysInAgent', 'agentId', agentId)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {AgentPatchBody} agentPatchBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent: async (orgId: string, agentId: string, agentPatchBody: AgentPatchBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('patchAgent', 'agentId', agentId)
            // verify required parameter 'agentPatchBody' is not null or undefined
            assertParamExists('patchAgent', 'agentPatchBody', agentPatchBody)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentPatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {string} orgId The Organization ID
         * @param {AgentCreateBody} agentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgent(orgId: string, agentCreateBody: AgentCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgent(orgId, agentCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {KeyCreateBody} keyCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(orgId: string, agentId: string, keyCreateBody: KeyCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Key>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(orgId, agentId, keyCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgent(orgId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgent(orgId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {string} fingerprint The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKeyInAgent(orgId: string, agentId: string, fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKeyInAgent(orgId, agentId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} [fingerprint] The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgents(orgId: string, fingerprint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgents(orgId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeysInAgent(orgId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Key>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeysInAgent(orgId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {AgentPatchBody} agentPatchBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAgent(orgId: string, agentId: string, agentPatchBody: AgentPatchBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAgent(orgId, agentId, agentPatchBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {AgentsApiCreateAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(requestParameters: AgentsApiCreateAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Agent> {
            return localVarFp.createAgent(requestParameters.orgId, requestParameters.agentCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {AgentsApiCreateKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(requestParameters: AgentsApiCreateKeyRequest, options?: AxiosRequestConfig): AxiosPromise<Key> {
            return localVarFp.createKey(requestParameters.orgId, requestParameters.agentId, requestParameters.keyCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {AgentsApiDeleteAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(requestParameters: AgentsApiDeleteAgentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {AgentsApiDeleteKeyInAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyInAgent(requestParameters: AgentsApiDeleteKeyInAgentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteKeyInAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {AgentsApiListAgentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(requestParameters: AgentsApiListAgentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Agent>> {
            return localVarFp.listAgents(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {AgentsApiListKeysInAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeysInAgent(requestParameters: AgentsApiListKeysInAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Key>> {
            return localVarFp.listKeysInAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {AgentsApiPatchAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(requestParameters: AgentsApiPatchAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Agent> {
            return localVarFp.patchAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.agentPatchBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAgent operation in AgentsApi.
 * @export
 * @interface AgentsApiCreateAgentRequest
 */
export interface AgentsApiCreateAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiCreateAgent
     */
    readonly orgId: string

    /**
     * 
     * @type {AgentCreateBody}
     * @memberof AgentsApiCreateAgent
     */
    readonly agentCreateBody: AgentCreateBody
}

/**
 * Request parameters for createKey operation in AgentsApi.
 * @export
 * @interface AgentsApiCreateKeyRequest
 */
export interface AgentsApiCreateKeyRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiCreateKey
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof AgentsApiCreateKey
     */
    readonly agentId: string

    /**
     * 
     * @type {KeyCreateBody}
     * @memberof AgentsApiCreateKey
     */
    readonly keyCreateBody: KeyCreateBody
}

/**
 * Request parameters for deleteAgent operation in AgentsApi.
 * @export
 * @interface AgentsApiDeleteAgentRequest
 */
export interface AgentsApiDeleteAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiDeleteAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof AgentsApiDeleteAgent
     */
    readonly agentId: string
}

/**
 * Request parameters for deleteKeyInAgent operation in AgentsApi.
 * @export
 * @interface AgentsApiDeleteKeyInAgentRequest
 */
export interface AgentsApiDeleteKeyInAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiDeleteKeyInAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof AgentsApiDeleteKeyInAgent
     */
    readonly agentId: string

    /**
     * The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
     * @type {string}
     * @memberof AgentsApiDeleteKeyInAgent
     */
    readonly fingerprint: string
}

/**
 * Request parameters for listAgents operation in AgentsApi.
 * @export
 * @interface AgentsApiListAgentsRequest
 */
export interface AgentsApiListAgentsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiListAgents
     */
    readonly orgId: string

    /**
     * The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
     * @type {string}
     * @memberof AgentsApiListAgents
     */
    readonly fingerprint?: string
}

/**
 * Request parameters for listKeysInAgent operation in AgentsApi.
 * @export
 * @interface AgentsApiListKeysInAgentRequest
 */
export interface AgentsApiListKeysInAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiListKeysInAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof AgentsApiListKeysInAgent
     */
    readonly agentId: string
}

/**
 * Request parameters for patchAgent operation in AgentsApi.
 * @export
 * @interface AgentsApiPatchAgentRequest
 */
export interface AgentsApiPatchAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AgentsApiPatchAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof AgentsApiPatchAgent
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentPatchBody}
     * @memberof AgentsApiPatchAgent
     */
    readonly agentPatchBody: AgentPatchBody
}

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI {
    /**
     * 
     * @summary Register a new Agent under an Organization.
     * @param {AgentsApiCreateAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAgent(requestParameters: AgentsApiCreateAgentRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).createAgent(requestParameters.orgId, requestParameters.agentCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Key under an Agent in an Organization.
     * @param {AgentsApiCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createKey(requestParameters: AgentsApiCreateKeyRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).createKey(requestParameters.orgId, requestParameters.agentId, requestParameters.keyCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Agent (and its keys) stored under an Organization.
     * @param {AgentsApiDeleteAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAgent(requestParameters: AgentsApiDeleteAgentRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).deleteAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key registered under a Agent.
     * @param {AgentsApiDeleteKeyInAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteKeyInAgent(requestParameters: AgentsApiDeleteKeyInAgentRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).deleteKeyInAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the agents in an Organization.
     * @param {AgentsApiListAgentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAgents(requestParameters: AgentsApiListAgentsRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).listAgents(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the keys registered under an Agent in an Organization.
     * @param {AgentsApiListKeysInAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listKeysInAgent(requestParameters: AgentsApiListKeysInAgentRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).listKeysInAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of an Agent.
     * @param {AgentsApiPatchAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public patchAgent(requestParameters: AgentsApiPatchAgentRequest, options?: AxiosRequestConfig) {
        return AgentsApiFp(this.configuration).patchAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.agentPatchBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (orgId: string, applicationCreationRequest: ApplicationCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createApplication', 'orgId', orgId)
            // verify required parameter 'applicationCreationRequest' is not null or undefined
            assertParamExists('createApplication', 'applicationCreationRequest', applicationCreationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteApplication', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteApplication', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getApplication', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getApplication', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listApplications', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(orgId: string, applicationCreationRequest: ApplicationCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(orgId, applicationCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {ApplicationApiCreateApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(requestParameters: ApplicationApiCreateApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.createApplication(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {ApplicationApiDeleteApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(requestParameters: ApplicationApiDeleteApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {ApplicationApiGetApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(requestParameters: ApplicationApiGetApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.getApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {ApplicationApiListApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(requestParameters: ApplicationApiListApplicationsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.listApplications(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApplication operation in ApplicationApi.
 * @export
 * @interface ApplicationApiCreateApplicationRequest
 */
export interface ApplicationApiCreateApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiCreateApplication
     */
    readonly orgId: string

    /**
     * The request ID, Human-friendly name and environment of the Application.  
     * @type {ApplicationCreationRequest}
     * @memberof ApplicationApiCreateApplication
     */
    readonly applicationCreationRequest: ApplicationCreationRequest
}

/**
 * Request parameters for deleteApplication operation in ApplicationApi.
 * @export
 * @interface ApplicationApiDeleteApplicationRequest
 */
export interface ApplicationApiDeleteApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiDeleteApplication
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ApplicationApiDeleteApplication
     */
    readonly appId: string
}

/**
 * Request parameters for getApplication operation in ApplicationApi.
 * @export
 * @interface ApplicationApiGetApplicationRequest
 */
export interface ApplicationApiGetApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiGetApplication
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ApplicationApiGetApplication
     */
    readonly appId: string
}

/**
 * Request parameters for listApplications operation in ApplicationApi.
 * @export
 * @interface ApplicationApiListApplicationsRequest
 */
export interface ApplicationApiListApplicationsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiListApplications
     */
    readonly orgId: string
}

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {ApplicationApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createApplication(requestParameters: ApplicationApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).createApplication(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {ApplicationApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public deleteApplication(requestParameters: ApplicationApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).deleteApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {ApplicationApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplication(requestParameters: ApplicationApiGetApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).getApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {ApplicationApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public listApplications(requestParameters: ApplicationApiListApplicationsRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).listApplications(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactApi - axios parameter creator
 * @export
 */
export const ArtefactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtefact: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteArtefact', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('deleteArtefact', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionDeploymentSet: async (orgId: string, artefactVersionId: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionDeploymentSet', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionDeploymentSet', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-deployment-set`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionSpec: async (orgId: string, artefactVersionId: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionSpec', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionSpec', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-spec`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.
         * @param {string} [type] (Optional) Filter Artefacts by type.
         * @param {string} [name] (Optional) Filter Artefacts by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefacts: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefacts', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactApi - functional programming interface
 * @export
 */
export const ArtefactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtefact(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtefact(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadArtefactVersionDeploymentSet(orgId: string, artefactVersionId: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadArtefactVersionDeploymentSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadArtefactVersionDeploymentSet(orgId, artefactVersionId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadArtefactVersionSpec(orgId: string, artefactVersionId: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadArtefactVersionSpec(orgId, artefactVersionId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.
         * @param {string} [type] (Optional) Filter Artefacts by type.
         * @param {string} [name] (Optional) Filter Artefacts by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefacts(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefacts(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactApi - factory interface
 * @export
 */
export const ArtefactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactApiFp(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {ArtefactApiDeleteArtefactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtefact(requestParameters: ArtefactApiDeleteArtefactRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteArtefact(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionDeploymentSet(requestParameters: ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadArtefactVersionDeploymentSet> {
            return localVarFp.getWorkloadArtefactVersionDeploymentSet(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {ArtefactApiGetWorkloadArtefactVersionSpecRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionSpec(requestParameters: ArtefactApiGetWorkloadArtefactVersionSpecRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getWorkloadArtefactVersionSpec(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {ArtefactApiListArtefactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefacts(requestParameters: ArtefactApiListArtefactsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.listArtefacts(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteArtefact operation in ArtefactApi.
 * @export
 * @interface ArtefactApiDeleteArtefactRequest
 */
export interface ArtefactApiDeleteArtefactRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactApiDeleteArtefact
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof ArtefactApiDeleteArtefact
     */
    readonly artefactId: string
}

/**
 * Request parameters for getWorkloadArtefactVersionDeploymentSet operation in ArtefactApi.
 * @export
 * @interface ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest
 */
export interface ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly artefactVersionId: string

    /**
     * The accepted content type.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly accept?: string
}

/**
 * Request parameters for getWorkloadArtefactVersionSpec operation in ArtefactApi.
 * @export
 * @interface ArtefactApiGetWorkloadArtefactVersionSpecRequest
 */
export interface ArtefactApiGetWorkloadArtefactVersionSpecRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionSpec
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionSpec
     */
    readonly artefactVersionId: string

    /**
     * The accepted content type.
     * @type {string}
     * @memberof ArtefactApiGetWorkloadArtefactVersionSpec
     */
    readonly accept?: string
}

/**
 * Request parameters for listArtefacts operation in ArtefactApi.
 * @export
 * @interface ArtefactApiListArtefactsRequest
 */
export interface ArtefactApiListArtefactsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactApiListArtefacts
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefacts by type.
     * @type {string}
     * @memberof ArtefactApiListArtefacts
     */
    readonly type?: string

    /**
     * (Optional) Filter Artefacts by name.
     * @type {string}
     * @memberof ArtefactApiListArtefacts
     */
    readonly name?: string
}

/**
 * ArtefactApi - object-oriented interface
 * @export
 * @class ArtefactApi
 * @extends {BaseAPI}
 */
export class ArtefactApi extends BaseAPI {
    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {ArtefactApiDeleteArtefactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public deleteArtefact(requestParameters: ArtefactApiDeleteArtefactRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).deleteArtefact(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
     * @param {ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public getWorkloadArtefactVersionDeploymentSet(requestParameters: ArtefactApiGetWorkloadArtefactVersionDeploymentSetRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).getWorkloadArtefactVersionDeploymentSet(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * @summary Get the spec of this Workload Artefact Version
     * @param {ArtefactApiGetWorkloadArtefactVersionSpecRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public getWorkloadArtefactVersionSpec(requestParameters: ArtefactApiGetWorkloadArtefactVersionSpecRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).getWorkloadArtefactVersionSpec(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {ArtefactApiListArtefactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public listArtefacts(requestParameters: ArtefactApiListArtefactsRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).listArtefacts(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactVersionApi - axios parameter creator
 * @export
 */
export const ArtefactVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.
         * @param {CreateArtefactVersion} createArtefactVersion The data needed to register a new Artefact Version within the organization.
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
         * @param {string} [accept] Indicates which content types the client is able to understand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtefactVersion: async (orgId: string, createArtefactVersion: CreateArtefactVersion, vcs?: string, dryRun?: boolean, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createArtefactVersion', 'orgId', orgId)
            // verify required parameter 'createArtefactVersion' is not null or undefined
            assertParamExists('createArtefactVersion', 'createArtefactVersion', createArtefactVersion)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createArtefactVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactVersion: async (orgId: string, artefactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getArtefactVersion', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getArtefactVersion', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.
         * @param {number} [limit] (Optional) Limit the number of versions returned by the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersions: async (orgId: string, artefactId: string, archived?: boolean, reference?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefactVersions', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('listArtefactVersions', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {string} orgId The organization ID.
         * @param {string} [name] (Optional) Filter Artefact Versions by name.
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [type] (Optional) Filter by artefact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersionsInOrg: async (orgId: string, name?: string, reference?: string, archived?: boolean, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefactVersionsInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {string} versionId The Version ID.
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtefactVersion: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('patchArtefactVersion', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactVersionApi - functional programming interface
 * @export
 */
export const ArtefactVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.
         * @param {CreateArtefactVersion} createArtefactVersion The data needed to register a new Artefact Version within the organization.
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
         * @param {string} [accept] Indicates which content types the client is able to understand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtefactVersion(orgId: string, createArtefactVersion: CreateArtefactVersion, vcs?: string, dryRun?: boolean, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtefactVersion(orgId, createArtefactVersion, vcs, dryRun, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtefactVersion(orgId: string, artefactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtefactVersion(orgId, artefactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.
         * @param {number} [limit] (Optional) Limit the number of versions returned by the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefactVersions(orgId: string, artefactId: string, archived?: boolean, reference?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefactVersions(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {string} orgId The organization ID.
         * @param {string} [name] (Optional) Filter Artefact Versions by name.
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [type] (Optional) Filter by artefact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefactVersionsInOrg(orgId: string, name?: string, reference?: string, archived?: boolean, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefactVersionsInOrg(orgId, name, reference, archived, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {string} versionId The Version ID.
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchArtefactVersion(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchArtefactVersion(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactVersionApi - factory interface
 * @export
 */
export const ArtefactVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactVersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {ArtefactVersionApiCreateArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtefactVersion(requestParameters: ArtefactVersionApiCreateArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.createArtefactVersion(requestParameters.orgId, requestParameters.createArtefactVersion, requestParameters.vcs, requestParameters.dryRun, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {ArtefactVersionApiGetArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactVersion(requestParameters: ArtefactVersionApiGetArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.getArtefactVersion(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {ArtefactVersionApiListArtefactVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersions(requestParameters: ArtefactVersionApiListArtefactVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersion>> {
            return localVarFp.listArtefactVersions(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {ArtefactVersionApiListArtefactVersionsInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersionsInOrg(requestParameters: ArtefactVersionApiListArtefactVersionsInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersion>> {
            return localVarFp.listArtefactVersionsInOrg(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {ArtefactVersionApiPatchArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtefactVersion(requestParameters: ArtefactVersionApiPatchArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.patchArtefactVersion(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createArtefactVersion operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiCreateArtefactVersionRequest
 */
export interface ArtefactVersionApiCreateArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactVersionApiCreateArtefactVersion
     */
    readonly orgId: string

    /**
     * The data needed to register a new Artefact Version within the organization.
     * @type {CreateArtefactVersion}
     * @memberof ArtefactVersionApiCreateArtefactVersion
     */
    readonly createArtefactVersion: CreateArtefactVersion

    /**
     * (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
     * @type {string}
     * @memberof ArtefactVersionApiCreateArtefactVersion
     */
    readonly vcs?: string

    /**
     * Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
     * @type {boolean}
     * @memberof ArtefactVersionApiCreateArtefactVersion
     */
    readonly dryRun?: boolean

    /**
     * Indicates which content types the client is able to understand.
     * @type {string}
     * @memberof ArtefactVersionApiCreateArtefactVersion
     */
    readonly accept?: string
}

/**
 * Request parameters for getArtefactVersion operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiGetArtefactVersionRequest
 */
export interface ArtefactVersionApiGetArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactVersionApiGetArtefactVersion
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof ArtefactVersionApiGetArtefactVersion
     */
    readonly artefactVersionId: string
}

/**
 * Request parameters for listArtefactVersions operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiListArtefactVersionsRequest
 */
export interface ArtefactVersionApiListArtefactVersionsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersions
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersions
     */
    readonly artefactId: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
     * @type {boolean}
     * @memberof ArtefactVersionApiListArtefactVersions
     */
    readonly archived?: boolean

    /**
     * (Optional) Filter Artefact Versions by by name including a version or digest.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersions
     */
    readonly reference?: string

    /**
     * (Optional) Limit the number of versions returned by the endpoint.
     * @type {number}
     * @memberof ArtefactVersionApiListArtefactVersions
     */
    readonly limit?: number
}

/**
 * Request parameters for listArtefactVersionsInOrg operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiListArtefactVersionsInOrgRequest
 */
export interface ArtefactVersionApiListArtefactVersionsInOrgRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersionsInOrg
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefact Versions by name.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersionsInOrg
     */
    readonly name?: string

    /**
     * (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersionsInOrg
     */
    readonly reference?: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
     * @type {boolean}
     * @memberof ArtefactVersionApiListArtefactVersionsInOrg
     */
    readonly archived?: boolean

    /**
     * (Optional) Filter by artefact type.
     * @type {string}
     * @memberof ArtefactVersionApiListArtefactVersionsInOrg
     */
    readonly type?: string
}

/**
 * Request parameters for patchArtefactVersion operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiPatchArtefactVersionRequest
 */
export interface ArtefactVersionApiPatchArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ArtefactVersionApiPatchArtefactVersion
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof ArtefactVersionApiPatchArtefactVersion
     */
    readonly artefactId: string

    /**
     * The Version ID.
     * @type {string}
     * @memberof ArtefactVersionApiPatchArtefactVersion
     */
    readonly versionId: string

    /**
     * The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
     * @type {UpdateArtefactVersionPayloadRequest}
     * @memberof ArtefactVersionApiPatchArtefactVersion
     */
    readonly updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest
}

/**
 * ArtefactVersionApi - object-oriented interface
 * @export
 * @class ArtefactVersionApi
 * @extends {BaseAPI}
 */
export class ArtefactVersionApi extends BaseAPI {
    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {ArtefactVersionApiCreateArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public createArtefactVersion(requestParameters: ArtefactVersionApiCreateArtefactVersionRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).createArtefactVersion(requestParameters.orgId, requestParameters.createArtefactVersion, requestParameters.vcs, requestParameters.dryRun, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific Artefact Version.
     * @summary Get an Artefacts Versions.
     * @param {ArtefactVersionApiGetArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public getArtefactVersion(requestParameters: ArtefactVersionApiGetArtefactVersionRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).getArtefactVersion(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {ArtefactVersionApiListArtefactVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public listArtefactVersions(requestParameters: ArtefactVersionApiListArtefactVersionsRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).listArtefactVersions(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions in the org.
     * @param {ArtefactVersionApiListArtefactVersionsInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public listArtefactVersionsInOrg(requestParameters: ArtefactVersionApiListArtefactVersionsInOrgRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).listArtefactVersionsInOrg(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {ArtefactVersionApiPatchArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public patchArtefactVersion(requestParameters: ArtefactVersionApiPatchArtefactVersionRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).patchArtefactVersion(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditLogsApi - axios parameter creator
 * @export
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [from] Optional filter for entries created after the given time.
         * @param {string} [to] Optional filter for entries created before the given time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogEntries: async (orgId: string, perPage?: number, page?: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAuditLogEntries', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/audit-logs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 * @export
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [from] Optional filter for entries created after the given time.
         * @param {string} [to] Optional filter for entries created before the given time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuditLogEntries(orgId: string, perPage?: number, page?: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogEntries(orgId, perPage, page, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 * @export
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {AuditLogsApiListAuditLogEntriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogEntries(requestParameters: AuditLogsApiListAuditLogEntriesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AuditLogEntry>> {
            return localVarFp.listAuditLogEntries(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.from, requestParameters.to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listAuditLogEntries operation in AuditLogsApi.
 * @export
 * @interface AuditLogsApiListAuditLogEntriesRequest
 */
export interface AuditLogsApiListAuditLogEntriesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof AuditLogsApiListAuditLogEntries
     */
    readonly orgId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof AuditLogsApiListAuditLogEntries
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof AuditLogsApiListAuditLogEntries
     */
    readonly page?: string

    /**
     * Optional filter for entries created after the given time.
     * @type {string}
     * @memberof AuditLogsApiListAuditLogEntries
     */
    readonly from?: string

    /**
     * Optional filter for entries created before the given time.
     * @type {string}
     * @memberof AuditLogsApiListAuditLogEntries
     */
    readonly to?: string
}

/**
 * AuditLogsApi - object-oriented interface
 * @export
 * @class AuditLogsApi
 * @extends {BaseAPI}
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
     * @summary List audit log entries by Organization
     * @param {AuditLogsApiListAuditLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogsApi
     */
    public listAuditLogEntries(requestParameters: AuditLogsApiListAuditLogEntriesRequest, options?: AxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).listAuditLogEntries(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutomationRuleApi - axios parameter creator
 * @export
 */
export const AutomationRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationRuleApi - functional programming interface
 * @export
 */
export const AutomationRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomationRuleApi - factory interface
 * @export
 */
export const AutomationRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesGet operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesPost operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly envId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly ruleId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * AutomationRuleApi - object-oriented interface
 * @export
 * @class AutomationRuleApi
 * @extends {BaseAPI}
 */
export class AutomationRuleApi extends BaseAPI {
    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeltaApi - axios parameter creator
 * @export
 */
export const DeltaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta: async (orgId: string, appId: string, deltaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('getDelta', 'deltaId', deltaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta: async (orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('putDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('putDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('putDelta', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('putDelta', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeltaApi - functional programming interface
 * @export
 */
export const DeltaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeltaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelta(orgId: string, appId: string, deltaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelta(orgId, appId, deltaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDelta(orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDelta(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeltaApi - factory interface
 * @export
 */
export const DeltaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeltaApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {DeltaApiGetDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta(requestParameters: DeltaApiGetDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {DeltaApiPutDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta(requestParameters: DeltaApiPutDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDelta operation in DeltaApi.
 * @export
 * @interface DeltaApiGetDeltaRequest
 */
export interface DeltaApiGetDeltaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to fetch.  
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly deltaId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly deltaId: string

    /**
     * Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @type {boolean}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly deltaId: string

    /**
     * The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly deltaId: string

    /**
     * The new name.(NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdPatch operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {Array<DeltaRequest>}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaRequest: Array<DeltaRequest>
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasGet operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly appId: string

    /**
     * If true, return archived Deltas.  
     * @type {boolean}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly archived?: boolean

    /**
     * Only return Deltas associated with the specified Environment.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly env?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasPost operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly appId: string

    /**
     * A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @type {DeltaRequest}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for putDelta operation in DeltaApi.
 * @export
 * @interface DeltaApiPutDeltaRequest
 */
export interface DeltaApiPutDeltaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {DeltaRequest}
     * @memberof DeltaApiPutDelta
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * DeltaApi - object-oriented interface
 * @export
 * @class DeltaApi
 * @extends {BaseAPI}
 */
export class DeltaApi extends BaseAPI {
    /**
     * 
     * @summary Fetch an existing Delta
     * @param {DeltaApiGetDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public getDelta(requestParameters: DeltaApiGetDeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {DeltaApiPutDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public putDelta(requestParameters: DeltaApiPutDeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDeployment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createDeployment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('createDeployment', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('createDeployment', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDeployment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDeployment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getDeployment', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('getDeployment', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentErrors: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [pipelineRunId] An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments: async (orgId: string, appId: string, envId: string, pipelineRunId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeployments', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listDeployments', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listDeployments', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipelineRunId !== undefined) {
                localVarQueryParameter['pipelineRunId'] = pipelineRunId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeployment(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeployment(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeploymentErrors(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeploymentErrors(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [pipelineRunId] An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeployments(orgId: string, appId: string, envId: string, pipelineRunId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeployments(orgId, appId, envId, pipelineRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {DeploymentApiCreateDeploymentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(requestParameters: DeploymentApiCreateDeploymentRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.createDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {DeploymentApiGetDeploymentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(requestParameters: DeploymentApiGetDeploymentRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.getDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {DeploymentApiListDeploymentErrorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentErrors(requestParameters: DeploymentApiListDeploymentErrorsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.listDeploymentErrors(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {DeploymentApiListDeploymentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments(requestParameters: DeploymentApiListDeploymentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.listDeployments(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.pipelineRunId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDeployment operation in DeploymentApi.
 * @export
 * @interface DeploymentApiCreateDeploymentRequest
 */
export interface DeploymentApiCreateDeploymentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiCreateDeployment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiCreateDeployment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiCreateDeployment
     */
    readonly envId: string

    /**
     * The Delta describing the change to the Environment and a comment.  
     * @type {DeploymentRequest}
     * @memberof DeploymentApiCreateDeployment
     */
    readonly deploymentRequest: DeploymentRequest
}

/**
 * Request parameters for getDeployment operation in DeploymentApi.
 * @export
 * @interface DeploymentApiGetDeploymentRequest
 */
export interface DeploymentApiGetDeploymentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiGetDeployment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiGetDeployment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiGetDeployment
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof DeploymentApiGetDeployment
     */
    readonly deployId: string
}

/**
 * Request parameters for listDeploymentErrors operation in DeploymentApi.
 * @export
 * @interface DeploymentApiListDeploymentErrorsRequest
 */
export interface DeploymentApiListDeploymentErrorsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiListDeploymentErrors
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiListDeploymentErrors
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiListDeploymentErrors
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof DeploymentApiListDeploymentErrors
     */
    readonly deployId: string
}

/**
 * Request parameters for listDeployments operation in DeploymentApi.
 * @export
 * @interface DeploymentApiListDeploymentsRequest
 */
export interface DeploymentApiListDeploymentsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiListDeployments
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiListDeployments
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiListDeployments
     */
    readonly envId: string

    /**
     * An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
     * @type {string}
     * @memberof DeploymentApiListDeployments
     */
    readonly pipelineRunId?: string
}

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {DeploymentApiCreateDeploymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public createDeployment(requestParameters: DeploymentApiCreateDeploymentRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).createDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {DeploymentApiGetDeploymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployment(requestParameters: DeploymentApiGetDeploymentRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).getDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {DeploymentApiListDeploymentErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public listDeploymentErrors(requestParameters: DeploymentApiListDeploymentErrorsRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).listDeploymentErrors(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {DeploymentApiListDeploymentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public listDeployments(requestParameters: DeploymentApiListDeploymentsRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).listDeployments(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.pipelineRunId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverDefinitionApi - axios parameter creator
 * @export
 */
export const DriverDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDriver: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDriver', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('createResourceDriver', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDriver: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('deleteResourceDriver', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDriver: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('getResourceDriver', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDrivers: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceDrivers', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDriver: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('updateResourceDriver', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('updateResourceDriver', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverDefinitionApi - functional programming interface
 * @export
 */
export const DriverDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDriver(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDriver(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDriver(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDriver(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceDriver(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceDriver(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceDrivers(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceDrivers(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDriver(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDriver(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverDefinitionApi - factory interface
 * @export
 */
export const DriverDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {DriverDefinitionApiCreateResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDriver(requestParameters: DriverDefinitionApiCreateResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.createResourceDriver(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {DriverDefinitionApiDeleteResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDriver(requestParameters: DriverDefinitionApiDeleteResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {DriverDefinitionApiGetResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDriver(requestParameters: DriverDefinitionApiGetResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.getResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {DriverDefinitionApiListResourceDriversRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDrivers(requestParameters: DriverDefinitionApiListResourceDriversRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.listResourceDrivers(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {DriverDefinitionApiUpdateResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDriver(requestParameters: DriverDefinitionApiUpdateResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.updateResourceDriver(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourceDriver operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiCreateResourceDriverRequest
 */
export interface DriverDefinitionApiCreateResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiCreateResourceDriver
     */
    readonly orgId: string

    /**
     * Resources Driver details.  
     * @type {CreateDriverRequestRequest}
     * @memberof DriverDefinitionApiCreateResourceDriver
     */
    readonly createDriverRequestRequest: CreateDriverRequestRequest
}

/**
 * Request parameters for deleteResourceDriver operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiDeleteResourceDriverRequest
 */
export interface DriverDefinitionApiDeleteResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiDeleteResourceDriver
     */
    readonly orgId: string

    /**
     * The Resources Driver ID to delete.  
     * @type {string}
     * @memberof DriverDefinitionApiDeleteResourceDriver
     */
    readonly driverId: string
}

/**
 * Request parameters for getResourceDriver operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiGetResourceDriverRequest
 */
export interface DriverDefinitionApiGetResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiGetResourceDriver
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof DriverDefinitionApiGetResourceDriver
     */
    readonly driverId: string
}

/**
 * Request parameters for listResourceDrivers operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiListResourceDriversRequest
 */
export interface DriverDefinitionApiListResourceDriversRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiListResourceDrivers
     */
    readonly orgId: string
}

/**
 * Request parameters for updateResourceDriver operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiUpdateResourceDriverRequest
 */
export interface DriverDefinitionApiUpdateResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiUpdateResourceDriver
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof DriverDefinitionApiUpdateResourceDriver
     */
    readonly driverId: string

    /**
     * 
     * @type {UpdateDriverRequestRequest}
     * @memberof DriverDefinitionApiUpdateResourceDriver
     */
    readonly updateDriverRequestRequest: UpdateDriverRequestRequest
}

/**
 * DriverDefinitionApi - object-oriented interface
 * @export
 * @class DriverDefinitionApi
 * @extends {BaseAPI}
 */
export class DriverDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {DriverDefinitionApiCreateResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public createResourceDriver(requestParameters: DriverDefinitionApiCreateResourceDriverRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).createResourceDriver(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {DriverDefinitionApiDeleteResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public deleteResourceDriver(requestParameters: DriverDefinitionApiDeleteResourceDriverRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).deleteResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {DriverDefinitionApiGetResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public getResourceDriver(requestParameters: DriverDefinitionApiGetResourceDriverRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).getResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {DriverDefinitionApiListResourceDriversRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public listResourceDrivers(requestParameters: DriverDefinitionApiListResourceDriversRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).listResourceDrivers(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {DriverDefinitionApiUpdateResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public updateResourceDriver(requestParameters: DriverDefinitionApiUpdateResourceDriverRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).updateResourceDriver(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createEnvironment', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('createEnvironment', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listEnvironments', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listEnvironments', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaseEnvironment: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('rebaseEnvironment', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {EnvironmentBaseUpdateRequest} [environmentBaseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: async (orgId: string, appId: string, envId: string, environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('updateEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentBaseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironments(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebaseEnvironment(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebaseEnvironment(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {EnvironmentBaseUpdateRequest} [environmentBaseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironment(orgId: string, appId: string, envId: string, environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(orgId, appId, envId, environmentBaseUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {EnvironmentApiCreateEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(requestParameters: EnvironmentApiCreateEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.createEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {EnvironmentApiDeleteEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(requestParameters: EnvironmentApiDeleteEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {EnvironmentApiGetEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(requestParameters: EnvironmentApiGetEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.getEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {EnvironmentApiListEnvironmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(requestParameters: EnvironmentApiListEnvironmentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.listEnvironments(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {EnvironmentApiRebaseEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaseEnvironment(requestParameters: EnvironmentApiRebaseEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rebaseEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {EnvironmentApiUpdateEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(requestParameters: EnvironmentApiUpdateEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.updateEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.environmentBaseUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEnvironment operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiCreateEnvironmentRequest
 */
export interface EnvironmentApiCreateEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiCreateEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiCreateEnvironment
     */
    readonly appId: string

    /**
     * The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @type {EnvironmentDefinitionRequest}
     * @memberof EnvironmentApiCreateEnvironment
     */
    readonly environmentDefinitionRequest: EnvironmentDefinitionRequest
}

/**
 * Request parameters for deleteEnvironment operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiDeleteEnvironmentRequest
 */
export interface EnvironmentApiDeleteEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiDeleteEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiDeleteEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiDeleteEnvironment
     */
    readonly envId: string
}

/**
 * Request parameters for getEnvironment operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiGetEnvironmentRequest
 */
export interface EnvironmentApiGetEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiGetEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiGetEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiGetEnvironment
     */
    readonly envId: string
}

/**
 * Request parameters for listEnvironments operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiListEnvironmentsRequest
 */
export interface EnvironmentApiListEnvironmentsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiListEnvironments
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiListEnvironments
     */
    readonly appId: string
}

/**
 * Request parameters for rebaseEnvironment operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiRebaseEnvironmentRequest
 */
export interface EnvironmentApiRebaseEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiRebaseEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiRebaseEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiRebaseEnvironment
     */
    readonly envId: string

    /**
     * The Deployment ID to rebase to.  
     * @type {string}
     * @memberof EnvironmentApiRebaseEnvironment
     */
    readonly body: string
}

/**
 * Request parameters for updateEnvironment operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiUpdateEnvironmentRequest
 */
export interface EnvironmentApiUpdateEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiUpdateEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiUpdateEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiUpdateEnvironment
     */
    readonly envId: string

    /**
     * 
     * @type {EnvironmentBaseUpdateRequest}
     * @memberof EnvironmentApiUpdateEnvironment
     */
    readonly environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest
}

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {EnvironmentApiCreateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public createEnvironment(requestParameters: EnvironmentApiCreateEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).createEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {EnvironmentApiDeleteEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public deleteEnvironment(requestParameters: EnvironmentApiDeleteEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).deleteEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {EnvironmentApiGetEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getEnvironment(requestParameters: EnvironmentApiGetEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).getEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {EnvironmentApiListEnvironmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public listEnvironments(requestParameters: EnvironmentApiListEnvironmentsRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).listEnvironments(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {EnvironmentApiRebaseEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public rebaseEnvironment(requestParameters: EnvironmentApiRebaseEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).rebaseEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific Environment in an Application.
     * @summary Update a specific Environment.
     * @param {EnvironmentApiUpdateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public updateEnvironment(requestParameters: EnvironmentApiUpdateEnvironmentRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).updateEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.environmentBaseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentPausedInfoApi - axios parameter creator
 * @export
 */
export const EnvironmentPausedInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaused: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updatePaused', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatePaused', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('updatePaused', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePaused', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentPausedInfoApi - functional programming interface
 * @export
 */
export const EnvironmentPausedInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentPausedInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaused(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaused(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentPausedInfoApi - factory interface
 * @export
 */
export const EnvironmentPausedInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentPausedInfoApiFp(configuration)
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {EnvironmentPausedInfoApiUpdatePausedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaused(requestParameters: EnvironmentPausedInfoApiUpdatePausedRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePaused(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePaused operation in EnvironmentPausedInfoApi.
 * @export
 * @interface EnvironmentPausedInfoApiUpdatePausedRequest
 */
export interface EnvironmentPausedInfoApiUpdatePausedRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof EnvironmentPausedInfoApiUpdatePaused
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof EnvironmentPausedInfoApiUpdatePaused
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof EnvironmentPausedInfoApiUpdatePaused
     */
    readonly envId: string

    /**
     * If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
     * @type {boolean}
     * @memberof EnvironmentPausedInfoApiUpdatePaused
     */
    readonly body: boolean
}

/**
 * EnvironmentPausedInfoApi - object-oriented interface
 * @export
 * @class EnvironmentPausedInfoApi
 * @extends {BaseAPI}
 */
export class EnvironmentPausedInfoApi extends BaseAPI {
    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {EnvironmentPausedInfoApiUpdatePausedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentPausedInfoApi
     */
    public updatePaused(requestParameters: EnvironmentPausedInfoApiUpdatePausedRequest, options?: AxiosRequestConfig) {
        return EnvironmentPausedInfoApiFp(this.configuration).updatePaused(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentTypeApi - axios parameter creator
 * @export
 */
export const EnvironmentTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentType: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createEnvironmentType', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('createEnvironmentType', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentType: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('deleteEnvironmentType', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentType: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('getEnvironmentType', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listEnvironmentTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {UpdateEnvironmentTypePayloadRequest} updateEnvironmentTypePayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentType: async (orgId: string, envTypeId: string, updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('updateEnvironmentType', 'envTypeId', envTypeId)
            // verify required parameter 'updateEnvironmentTypePayloadRequest' is not null or undefined
            assertParamExists('updateEnvironmentType', 'updateEnvironmentTypePayloadRequest', updateEnvironmentTypePayloadRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentTypePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentTypeApi - functional programming interface
 * @export
 */
export const EnvironmentTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentType(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentType(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentType(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentType(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentType(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentType(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {UpdateEnvironmentTypePayloadRequest} updateEnvironmentTypePayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironmentType(orgId: string, envTypeId: string, updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironmentType(orgId, envTypeId, updateEnvironmentTypePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentTypeApi - factory interface
 * @export
 */
export const EnvironmentTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentTypeApiFp(configuration)
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {EnvironmentTypeApiCreateEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentType(requestParameters: EnvironmentTypeApiCreateEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.createEnvironmentType(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {EnvironmentTypeApiDeleteEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentType(requestParameters: EnvironmentTypeApiDeleteEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.deleteEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {EnvironmentTypeApiGetEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentType(requestParameters: EnvironmentTypeApiGetEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.getEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {EnvironmentTypeApiListEnvironmentTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentTypes(requestParameters: EnvironmentTypeApiListEnvironmentTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.listEnvironmentTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {EnvironmentTypeApiUpdateEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentType(requestParameters: EnvironmentTypeApiUpdateEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.updateEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, requestParameters.updateEnvironmentTypePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEnvironmentType operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiCreateEnvironmentTypeRequest
 */
export interface EnvironmentTypeApiCreateEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiCreateEnvironmentType
     */
    readonly orgId: string

    /**
     * New Environment Type.  
     * @type {EnvironmentTypeRequest}
     * @memberof EnvironmentTypeApiCreateEnvironmentType
     */
    readonly environmentTypeRequest: EnvironmentTypeRequest
}

/**
 * Request parameters for deleteEnvironmentType operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiDeleteEnvironmentTypeRequest
 */
export interface EnvironmentTypeApiDeleteEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiDeleteEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof EnvironmentTypeApiDeleteEnvironmentType
     */
    readonly envTypeId: string
}

/**
 * Request parameters for getEnvironmentType operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiGetEnvironmentTypeRequest
 */
export interface EnvironmentTypeApiGetEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiGetEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof EnvironmentTypeApiGetEnvironmentType
     */
    readonly envTypeId: string
}

/**
 * Request parameters for listEnvironmentTypes operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiListEnvironmentTypesRequest
 */
export interface EnvironmentTypeApiListEnvironmentTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiListEnvironmentTypes
     */
    readonly orgId: string
}

/**
 * Request parameters for updateEnvironmentType operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiUpdateEnvironmentTypeRequest
 */
export interface EnvironmentTypeApiUpdateEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiUpdateEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof EnvironmentTypeApiUpdateEnvironmentType
     */
    readonly envTypeId: string

    /**
     * 
     * @type {UpdateEnvironmentTypePayloadRequest}
     * @memberof EnvironmentTypeApiUpdateEnvironmentType
     */
    readonly updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest
}

/**
 * EnvironmentTypeApi - object-oriented interface
 * @export
 * @class EnvironmentTypeApi
 * @extends {BaseAPI}
 */
export class EnvironmentTypeApi extends BaseAPI {
    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {EnvironmentTypeApiCreateEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public createEnvironmentType(requestParameters: EnvironmentTypeApiCreateEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).createEnvironmentType(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {EnvironmentTypeApiDeleteEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public deleteEnvironmentType(requestParameters: EnvironmentTypeApiDeleteEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).deleteEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {EnvironmentTypeApiGetEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public getEnvironmentType(requestParameters: EnvironmentTypeApiGetEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).getEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {EnvironmentTypeApiListEnvironmentTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public listEnvironmentTypes(requestParameters: EnvironmentTypeApiListEnvironmentTypesRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).listEnvironmentTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates Environment Type.
     * @summary Updates Environment Type
     * @param {EnvironmentTypeApiUpdateEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public updateEnvironmentType(requestParameters: EnvironmentTypeApiUpdateEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).updateEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, requestParameters.updateEnvironmentTypePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookUpdateResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {EventApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(requestParameters: EventApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdJobsDelete operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdDelete operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdPatch operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly jobId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksPost operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly appId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdEventsGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdEventsGetRequest
 */
export interface EventApiOrgsOrgIdEventsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdEventsGet
     */
    readonly orgId: string
}

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {EventApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdEventsGet(requestParameters: EventApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanitecPublicKeysApi - axios parameter creator
 * @export
 */
export const HumanitecPublicKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {string} orgId The organization ID.
         * @param {boolean} [active] If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHumanitecPublicKeys: async (orgId: string, active?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listHumanitecPublicKeys', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/humanitec-keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanitecPublicKeysApi - functional programming interface
 * @export
 */
export const HumanitecPublicKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanitecPublicKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {string} orgId The organization ID.
         * @param {boolean} [active] If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHumanitecPublicKeys(orgId: string, active?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanitecPublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHumanitecPublicKeys(orgId, active, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanitecPublicKeysApi - factory interface
 * @export
 */
export const HumanitecPublicKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanitecPublicKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {HumanitecPublicKeysApiListHumanitecPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHumanitecPublicKeys(requestParameters: HumanitecPublicKeysApiListHumanitecPublicKeysRequest, options?: AxiosRequestConfig): AxiosPromise<Array<HumanitecPublicKey>> {
            return localVarFp.listHumanitecPublicKeys(requestParameters.orgId, requestParameters.active, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listHumanitecPublicKeys operation in HumanitecPublicKeysApi.
 * @export
 * @interface HumanitecPublicKeysApiListHumanitecPublicKeysRequest
 */
export interface HumanitecPublicKeysApiListHumanitecPublicKeysRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof HumanitecPublicKeysApiListHumanitecPublicKeys
     */
    readonly orgId: string

    /**
     * If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
     * @type {boolean}
     * @memberof HumanitecPublicKeysApiListHumanitecPublicKeys
     */
    readonly active?: boolean
}

/**
 * HumanitecPublicKeysApi - object-oriented interface
 * @export
 * @class HumanitecPublicKeysApi
 * @extends {BaseAPI}
 */
export class HumanitecPublicKeysApi extends BaseAPI {
    /**
     * 
     * @summary List all the public keys Humanitec shares with an organization.
     * @param {HumanitecPublicKeysApiListHumanitecPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanitecPublicKeysApi
     */
    public listHumanitecPublicKeys(requestParameters: HumanitecPublicKeysApiListHumanitecPublicKeysRequest, options?: AxiosRequestConfig) {
        return HumanitecPublicKeysApiFp(this.configuration).listHumanitecPublicKeys(requestParameters.orgId, requestParameters.active, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeprecatedImageBuild: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeprecatedImage: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDeprecatedImage', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getDeprecatedImage', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImageBuilds: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeprecatedImageBuilds', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('listDeprecatedImageBuilds', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImages: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeprecatedImages', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeprecatedImageBuild(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeprecatedImageBuild(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeprecatedImage(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeprecatedImage(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeprecatedImageBuilds(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeprecatedImageBuilds(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeprecatedImages(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeprecatedImages(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {ImageApiCreateDeprecatedImageBuildRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeprecatedImageBuild(requestParameters: ImageApiCreateDeprecatedImageBuildRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createDeprecatedImageBuild(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {ImageApiGetDeprecatedImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeprecatedImage(requestParameters: ImageApiGetDeprecatedImageRequest, options?: AxiosRequestConfig): AxiosPromise<ImageResponse> {
            return localVarFp.getDeprecatedImage(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {ImageApiListDeprecatedImageBuildsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImageBuilds(requestParameters: ImageApiListDeprecatedImageBuildsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.listDeprecatedImageBuilds(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {ImageApiListDeprecatedImagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImages(requestParameters: ImageApiListDeprecatedImagesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.listDeprecatedImages(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDeprecatedImageBuild operation in ImageApi.
 * @export
 * @interface ImageApiCreateDeprecatedImageBuildRequest
 */
export interface ImageApiCreateDeprecatedImageBuildRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ImageApiCreateDeprecatedImageBuild
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof ImageApiCreateDeprecatedImageBuild
     */
    readonly imageId: string

    /**
     * The metadata associated with the build.
     * @type {ImageBuildRequest}
     * @memberof ImageApiCreateDeprecatedImageBuild
     */
    readonly imageBuildRequest: ImageBuildRequest
}

/**
 * Request parameters for getDeprecatedImage operation in ImageApi.
 * @export
 * @interface ImageApiGetDeprecatedImageRequest
 */
export interface ImageApiGetDeprecatedImageRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ImageApiGetDeprecatedImage
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof ImageApiGetDeprecatedImage
     */
    readonly imageId: string
}

/**
 * Request parameters for listDeprecatedImageBuilds operation in ImageApi.
 * @export
 * @interface ImageApiListDeprecatedImageBuildsRequest
 */
export interface ImageApiListDeprecatedImageBuildsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ImageApiListDeprecatedImageBuilds
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof ImageApiListDeprecatedImageBuilds
     */
    readonly imageId: string
}

/**
 * Request parameters for listDeprecatedImages operation in ImageApi.
 * @export
 * @interface ImageApiListDeprecatedImagesRequest
 */
export interface ImageApiListDeprecatedImagesRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof ImageApiListDeprecatedImages
     */
    readonly orgId: string
}

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {ImageApiCreateDeprecatedImageBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public createDeprecatedImageBuild(requestParameters: ImageApiCreateDeprecatedImageBuildRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).createDeprecatedImageBuild(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {ImageApiGetDeprecatedImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getDeprecatedImage(requestParameters: ImageApiGetDeprecatedImageRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).getDeprecatedImage(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {ImageApiListDeprecatedImageBuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public listDeprecatedImageBuilds(requestParameters: ImageApiListDeprecatedImageBuildsRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).listDeprecatedImageBuilds(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {ImageApiListDeprecatedImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public listDeprecatedImages(requestParameters: ImageApiListDeprecatedImagesRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).listDeprecatedImages(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchingCriteriaApi - axios parameter creator
 * @export
 */
export const MatchingCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingCriteriaApi - functional programming interface
 * @export
 */
export const MatchingCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDefinitionCriteria(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDefinitionCriteria(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchingCriteriaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingCriteriaApi - factory interface
 * @export
 */
export const MatchingCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingCriteriaApiFp(configuration)
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<Array<MatchingCriteriaResponse>> {
            return localVarFp.updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourceDefinitionCriteria operation in MatchingCriteriaApi.
 * @export
 * @interface MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest
 */
export interface MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiCreateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiCreateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof MatchingCriteriaApiCreateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * Request parameters for deleteResourceDefinitionCriteria operation in MatchingCriteriaApi.
 * @export
 * @interface MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest
 */
export interface MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiDeleteResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiDeleteResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiDeleteResourceDefinitionCriteria
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof MatchingCriteriaApiDeleteResourceDefinitionCriteria
     */
    readonly force?: boolean
}

/**
 * Request parameters for updateResourceDefinitionCriteria operation in MatchingCriteriaApi.
 * @export
 * @interface MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest
 */
export interface MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiUpdateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiUpdateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {Array<MatchingCriteriaRuleRequest>}
     * @memberof MatchingCriteriaApiUpdateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>
}

/**
 * MatchingCriteriaApi - object-oriented interface
 * @export
 * @class MatchingCriteriaApi
 * @extends {BaseAPI}
 */
export class MatchingCriteriaApi extends BaseAPI {
    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public createResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public deleteResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Update all Matching Criteria of a Resource Definition.
     * @param {MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public updateResourceDefinitionCriteria(requestParameters: MatchingCriteriaApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getOrganization', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {OrganizationApiGetOrganizationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(requestParameters: OrganizationApiGetOrganizationRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationResponse> {
            return localVarFp.getOrganization(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: AxiosRequestConfig): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getOrganization operation in OrganizationApi.
 * @export
 * @interface OrganizationApiGetOrganizationRequest
 */
export interface OrganizationApiGetOrganizationRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof OrganizationApiGetOrganization
     */
    readonly orgId: string
}

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Get the specified Organization.
     * @param {OrganizationApiGetOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(requestParameters: OrganizationApiGetOrganizationRequest, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizations(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelineApprovalsApi - axios parameter creator
 * @export
 */
export const PipelineApprovalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/approve`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyPipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/deny`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {Array<string>} [run] An optional Pipeline Run ID.
         * @param {string} [status] Optional filter by status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineApprovalRequests: async (orgId: string, appId: string, perPage?: number, page?: string, pipeline?: Array<string>, run?: Array<string>, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineApprovalRequests', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineApprovalRequests', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/approvals`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pipeline) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (run) {
                localVarQueryParameter['run'] = run;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineApprovalsApi - functional programming interface
 * @export
 */
export const PipelineApprovalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineApprovalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyPipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyPipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {Array<string>} [run] An optional Pipeline Run ID.
         * @param {string} [status] Optional filter by status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineApprovalRequests(orgId: string, appId: string, perPage?: number, page?: string, pipeline?: Array<string>, run?: Array<string>, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineApprovalRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineApprovalRequests(orgId, appId, perPage, page, pipeline, run, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelineApprovalsApi - factory interface
 * @export
 */
export const PipelineApprovalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineApprovalsApiFp(configuration)
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {PipelineApprovalsApiApprovePipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePipelineApprovalRequest(requestParameters: PipelineApprovalsApiApprovePipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.approvePipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {PipelineApprovalsApiDenyPipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyPipelineApprovalRequest(requestParameters: PipelineApprovalsApiDenyPipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.denyPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {PipelineApprovalsApiGetPipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineApprovalRequest(requestParameters: PipelineApprovalsApiGetPipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.getPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {PipelineApprovalsApiListPipelineApprovalRequestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineApprovalRequests(requestParameters: PipelineApprovalsApiListPipelineApprovalRequestsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineApprovalRequest>> {
            return localVarFp.listPipelineApprovalRequests(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.pipeline, requestParameters.run, requestParameters.status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approvePipelineApprovalRequest operation in PipelineApprovalsApi.
 * @export
 * @interface PipelineApprovalsApiApprovePipelineApprovalRequestRequest
 */
export interface PipelineApprovalsApiApprovePipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PipelineApprovalsApiApprovePipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for denyPipelineApprovalRequest operation in PipelineApprovalsApi.
 * @export
 * @interface PipelineApprovalsApiDenyPipelineApprovalRequestRequest
 */
export interface PipelineApprovalsApiDenyPipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PipelineApprovalsApiDenyPipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for getPipelineApprovalRequest operation in PipelineApprovalsApi.
 * @export
 * @interface PipelineApprovalsApiGetPipelineApprovalRequestRequest
 */
export interface PipelineApprovalsApiGetPipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PipelineApprovalsApiGetPipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for listPipelineApprovalRequests operation in PipelineApprovalsApi.
 * @export
 * @interface PipelineApprovalsApiListPipelineApprovalRequestsRequest
 */
export interface PipelineApprovalsApiListPipelineApprovalRequestsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly appId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly page?: string

    /**
     * An optional list of Pipeline IDs.
     * @type {Array<string>}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly pipeline?: Array<string>

    /**
     * An optional Pipeline Run ID.
     * @type {Array<string>}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly run?: Array<string>

    /**
     * Optional filter by status.
     * @type {string}
     * @memberof PipelineApprovalsApiListPipelineApprovalRequests
     */
    readonly status?: string
}

/**
 * PipelineApprovalsApi - object-oriented interface
 * @export
 * @class PipelineApprovalsApi
 * @extends {BaseAPI}
 */
export class PipelineApprovalsApi extends BaseAPI {
    /**
     * Approve the approval requested.
     * @summary Approve the approval request
     * @param {PipelineApprovalsApiApprovePipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApprovalsApi
     */
    public approvePipelineApprovalRequest(requestParameters: PipelineApprovalsApiApprovePipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PipelineApprovalsApiFp(this.configuration).approvePipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deny the approval requested.
     * @summary Deny the approval request
     * @param {PipelineApprovalsApiDenyPipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApprovalsApi
     */
    public denyPipelineApprovalRequest(requestParameters: PipelineApprovalsApiDenyPipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PipelineApprovalsApiFp(this.configuration).denyPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an approval request.
     * @summary Get an approval request
     * @param {PipelineApprovalsApiGetPipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApprovalsApi
     */
    public getPipelineApprovalRequest(requestParameters: PipelineApprovalsApiGetPipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PipelineApprovalsApiFp(this.configuration).getPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the approval requests with in an app. 
     * @summary List of the approval requests
     * @param {PipelineApprovalsApiListPipelineApprovalRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineApprovalsApi
     */
    public listPipelineApprovalRequests(requestParameters: PipelineApprovalsApiListPipelineApprovalRequestsRequest, options?: AxiosRequestConfig) {
        return PipelineApprovalsApiFp(this.configuration).listPipelineApprovalRequests(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.pipeline, requestParameters.run, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelineRunsApi - axios parameter creator
 * @export
 */
export const PipelineRunsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/cancel`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineRunCreateBody} pipelineRunCreateBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRun: async (orgId: string, appId: string, pipelineId: string, pipelineRunCreateBody: PipelineRunCreateBody, idempotencyKey?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('createPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'pipelineRunCreateBody' is not null or undefined
            assertParamExists('createPipelineRun', 'pipelineRunCreateBody', pipelineRunCreateBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineRunCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {PipelineRunCreateByTriggerCriteriaBody} pipelineRunCreateByTriggerCriteriaBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRunByTriggerCriteria: async (orgId: string, appId: string, pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody, idempotencyKey?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'appId', appId)
            // verify required parameter 'pipelineRunCreateByTriggerCriteriaBody' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'pipelineRunCreateByTriggerCriteriaBody', pipelineRunCreateByTriggerCriteriaBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipeline-runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineRunCreateByTriggerCriteriaBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deletePipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineJob: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineJob', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineJob', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineJob', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineJob', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPipelineJob', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineJobs: async (orgId: string, appId: string, pipelineId: string, runId: string, status?: Array<string>, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineJobs', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineJobs', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineJobs', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('listPipelineJobs', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRuns: async (orgId: string, appId: string, pipelineId: string, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineRuns', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineRuns', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineRuns', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRunsByOrg: async (orgId: string, app?: Array<string>, pipeline?: Array<string>, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineRunsByOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipeline-runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app) {
                localVarQueryParameter['app'] = app;
            }

            if (pipeline) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {number} stepIndex The index of the step within the Job
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineStepLogs: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, stepIndex: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'jobId', jobId)
            // verify required parameter 'stepIndex' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'stepIndex', stepIndex)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/steps/{stepIndex}/logs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"stepIndex"}}`, encodeURIComponent(String(stepIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, idempotencyKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('restartPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('restartPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('restartPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('restartPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/restart`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelineRunsApi - functional programming interface
 * @export
 */
export const PipelineRunsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelineRunsApiAxiosParamCreator(configuration)
    return {
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPipelineRun(orgId, appId, pipelineId, runId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineRunCreateBody} pipelineRunCreateBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineRun(orgId: string, appId: string, pipelineId: string, pipelineRunCreateBody: PipelineRunCreateBody, idempotencyKey?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineRun(orgId, appId, pipelineId, pipelineRunCreateBody, idempotencyKey, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {PipelineRunCreateByTriggerCriteriaBody} pipelineRunCreateByTriggerCriteriaBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineRunByTriggerCriteria(orgId: string, appId: string, pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody, idempotencyKey?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineRunByTriggerCriteria(orgId, appId, pipelineRunCreateByTriggerCriteriaBody, idempotencyKey, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineRun(orgId, appId, pipelineId, runId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineJob(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineJob(orgId, appId, pipelineId, runId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRun(orgId, appId, pipelineId, runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineJobs(orgId: string, appId: string, pipelineId: string, runId: string, status?: Array<string>, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineJobPartial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineJobs(orgId, appId, pipelineId, runId, status, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineRuns(orgId: string, appId: string, pipelineId: string, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineRuns(orgId, appId, pipelineId, env, status, completed, createdAfter, createdBefore, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineRunsByOrg(orgId: string, app?: Array<string>, pipeline?: Array<string>, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineRunsByOrg(orgId, app, pipeline, env, status, completed, createdAfter, createdBefore, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {number} stepIndex The index of the step within the Job
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineStepLogs(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, stepIndex: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineStepLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineStepLogs(orgId, appId, pipelineId, runId, jobId, stepIndex, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, idempotencyKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartPipelineRun(orgId, appId, pipelineId, runId, idempotencyKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelineRunsApi - factory interface
 * @export
 */
export const PipelineRunsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelineRunsApiFp(configuration)
    return {
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {PipelineRunsApiCancelPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPipelineRun(requestParameters: PipelineRunsApiCancelPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {PipelineRunsApiCreatePipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRun(requestParameters: PipelineRunsApiCreatePipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.createPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineRunCreateBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRunByTriggerCriteria(requestParameters: PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.createPipelineRunByTriggerCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineRunCreateByTriggerCriteriaBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {PipelineRunsApiDeletePipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineRun(requestParameters: PipelineRunsApiDeletePipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {PipelineRunsApiGetPipelineJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineJob(requestParameters: PipelineRunsApiGetPipelineJobRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineJob> {
            return localVarFp.getPipelineJob(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {PipelineRunsApiGetPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(requestParameters: PipelineRunsApiGetPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {PipelineRunsApiListPipelineJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineJobs(requestParameters: PipelineRunsApiListPipelineJobsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineJobPartial>> {
            return localVarFp.listPipelineJobs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.status, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {PipelineRunsApiListPipelineRunsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRuns(requestParameters: PipelineRunsApiListPipelineRunsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.listPipelineRuns(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {PipelineRunsApiListPipelineRunsByOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRunsByOrg(requestParameters: PipelineRunsApiListPipelineRunsByOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.listPipelineRunsByOrg(requestParameters.orgId, requestParameters.app, requestParameters.pipeline, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {PipelineRunsApiListPipelineStepLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineStepLogs(requestParameters: PipelineRunsApiListPipelineStepLogsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineStepLog>> {
            return localVarFp.listPipelineStepLogs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.stepIndex, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {PipelineRunsApiRestartPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartPipelineRun(requestParameters: PipelineRunsApiRestartPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.restartPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelPipelineRun operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiCancelPipelineRunRequest
 */
export interface PipelineRunsApiCancelPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiCancelPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiCancelPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiCancelPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiCancelPipelineRun
     */
    readonly runId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PipelineRunsApiCancelPipelineRun
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for createPipelineRun operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiCreatePipelineRunRequest
 */
export interface PipelineRunsApiCreatePipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly pipelineId: string

    /**
     * 
     * @type {PipelineRunCreateBody}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly pipelineRunCreateBody: PipelineRunCreateBody

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly idempotencyKey?: string

    /**
     * Optionally validate the request but do not persist the actual Pipeline Run.
     * @type {boolean}
     * @memberof PipelineRunsApiCreatePipelineRun
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for createPipelineRunByTriggerCriteria operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest
 */
export interface PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRunByTriggerCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRunByTriggerCriteria
     */
    readonly appId: string

    /**
     * 
     * @type {PipelineRunCreateByTriggerCriteriaBody}
     * @memberof PipelineRunsApiCreatePipelineRunByTriggerCriteria
     */
    readonly pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PipelineRunsApiCreatePipelineRunByTriggerCriteria
     */
    readonly idempotencyKey?: string

    /**
     * Optionally validate the request but do not persist the actual Pipeline Run.
     * @type {boolean}
     * @memberof PipelineRunsApiCreatePipelineRunByTriggerCriteria
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for deletePipelineRun operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiDeletePipelineRunRequest
 */
export interface PipelineRunsApiDeletePipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiDeletePipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiDeletePipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiDeletePipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiDeletePipelineRun
     */
    readonly runId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PipelineRunsApiDeletePipelineRun
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for getPipelineJob operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiGetPipelineJobRequest
 */
export interface PipelineRunsApiGetPipelineJobRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineJob
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineJob
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineJob
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineJob
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineJob
     */
    readonly jobId: string
}

/**
 * Request parameters for getPipelineRun operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiGetPipelineRunRequest
 */
export interface PipelineRunsApiGetPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiGetPipelineRun
     */
    readonly runId: string
}

/**
 * Request parameters for listPipelineJobs operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiListPipelineJobsRequest
 */
export interface PipelineRunsApiListPipelineJobsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly runId: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly status?: Array<string>

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelineRunsApiListPipelineJobs
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineRuns operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiListPipelineRunsRequest
 */
export interface PipelineRunsApiListPipelineRunsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly pipelineId: string

    /**
     * An optional Environment ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly env?: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly status?: Array<string>

    /**
     * Optional filer by completed or not.
     * @type {boolean}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly completed?: boolean

    /**
     * Optional filter by creation after date time.
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly createdAfter?: string

    /**
     * Optional filter by creation before date time
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly createdBefore?: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRuns
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineRunsByOrg operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiListPipelineRunsByOrgRequest
 */
export interface PipelineRunsApiListPipelineRunsByOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly orgId: string

    /**
     * An optional list of Application IDs.
     * @type {Array<string>}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly app?: Array<string>

    /**
     * An optional list of Pipeline IDs.
     * @type {Array<string>}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly pipeline?: Array<string>

    /**
     * An optional Environment ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly env?: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly status?: Array<string>

    /**
     * Optional filer by completed or not.
     * @type {boolean}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly completed?: boolean

    /**
     * Optional filter by creation after date time.
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly createdAfter?: string

    /**
     * Optional filter by creation before date time
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly createdBefore?: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelineRunsApiListPipelineRunsByOrg
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineStepLogs operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiListPipelineStepLogsRequest
 */
export interface PipelineRunsApiListPipelineStepLogsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly jobId: string

    /**
     * The index of the step within the Job
     * @type {number}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly stepIndex: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelineRunsApiListPipelineStepLogs
     */
    readonly page?: string
}

/**
 * Request parameters for restartPipelineRun operation in PipelineRunsApi.
 * @export
 * @interface PipelineRunsApiRestartPipelineRunRequest
 */
export interface PipelineRunsApiRestartPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelineRunsApiRestartPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelineRunsApiRestartPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelineRunsApiRestartPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PipelineRunsApiRestartPipelineRun
     */
    readonly runId: string

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PipelineRunsApiRestartPipelineRun
     */
    readonly idempotencyKey?: string
}

/**
 * PipelineRunsApi - object-oriented interface
 * @export
 * @class PipelineRunsApi
 * @extends {BaseAPI}
 */
export class PipelineRunsApi extends BaseAPI {
    /**
     * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
     * @summary Cancel a Run within an Pipeline.
     * @param {PipelineRunsApiCancelPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public cancelPipelineRun(requestParameters: PipelineRunsApiCancelPipelineRunRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).cancelPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a run within a pipeline.
     * @param {PipelineRunsApiCreatePipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public createPipelineRun(requestParameters: PipelineRunsApiCreatePipelineRunRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).createPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineRunCreateBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
     * @param {PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public createPipelineRunByTriggerCriteria(requestParameters: PipelineRunsApiCreatePipelineRunByTriggerCriteriaRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).createPipelineRunByTriggerCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineRunCreateByTriggerCriteriaBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleting a completed Run within a Pipeline.
     * @param {PipelineRunsApiDeletePipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public deletePipelineRun(requestParameters: PipelineRunsApiDeletePipelineRunRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).deletePipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the details of a Job including Step information
     * @param {PipelineRunsApiGetPipelineJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public getPipelineJob(requestParameters: PipelineRunsApiGetPipelineJobRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).getPipelineJob(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a run within an pipeline.
     * @param {PipelineRunsApiGetPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public getPipelineRun(requestParameters: PipelineRunsApiGetPipelineRunRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).getPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the details of the jobs within a pipeline run.
     * @param {PipelineRunsApiListPipelineJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public listPipelineJobs(requestParameters: PipelineRunsApiListPipelineJobsRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).listPipelineJobs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.status, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List runs within a pipeline.
     * @param {PipelineRunsApiListPipelineRunsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public listPipelineRuns(requestParameters: PipelineRunsApiListPipelineRunsRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).listPipelineRuns(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
     * @param {PipelineRunsApiListPipelineRunsByOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public listPipelineRunsByOrg(requestParameters: PipelineRunsApiListPipelineRunsByOrgRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).listPipelineRunsByOrg(requestParameters.orgId, requestParameters.app, requestParameters.pipeline, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a page of log output for a given step within a job.
     * @param {PipelineRunsApiListPipelineStepLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public listPipelineStepLogs(requestParameters: PipelineRunsApiListPipelineStepLogsRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).listPipelineStepLogs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.stepIndex, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to copy and restart the specified Run. The run must be in a completed state. 
     * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
     * @param {PipelineRunsApiRestartPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelineRunsApi
     */
    public restartPipelineRun(requestParameters: PipelineRunsApiRestartPipelineRunRequest, options?: AxiosRequestConfig) {
        return PipelineRunsApiFp(this.configuration).restartPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.idempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PipelinesApi - axios parameter creator
 * @export
 */
export const PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {object} body 
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline: async (orgId: string, appId: string, body: object, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipeline', 'appId', appId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPipeline', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineCriteriaCreateBody} pipelineCriteriaCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineCriteria: async (orgId: string, appId: string, pipelineId: string, pipelineCriteriaCreateBody: PipelineCriteriaCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'pipelineCriteriaCreateBody' is not null or undefined
            assertParamExists('createPipelineCriteria', 'pipelineCriteriaCreateBody', pipelineCriteriaCreateBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineCriteriaCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline: async (orgId: string, appId: string, pipelineId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipeline', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineCriteria: async (orgId: string, appId: string, pipelineId: string, criteriaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} batchType The batch type, only artefact is implemented.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch: async (orgId: string, appId: string, pipelineId: string, batchType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getBatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBatch', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getBatch', 'pipelineId', pipelineId)
            // verify required parameter 'batchType' is not null or undefined
            assertParamExists('getBatch', 'batchType', batchType)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/batches/{batchType}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"batchType"}}`, encodeURIComponent(String(batchType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestPipelineDefinitionSchema: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestPipelineDefinitionSchema', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipeline-schemas/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (orgId: string, appId: string, pipelineId: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipeline', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineCriteria: async (orgId: string, appId: string, pipelineId: string, criteriaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDefinition: async (orgId: string, appId: string, pipelineId: string, version?: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/schema`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} [pipeline] An optional filter by Pipeline ID.
         * @param {{ [key: string]: string; }} [match] Optional key value match filters on the criteria.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineCriteriaInApp: async (orgId: string, appId: string, pipeline?: string, match?: { [key: string]: string; }, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineCriteriaInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineCriteriaInApp', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipeline-criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipeline !== undefined) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineVersions: async (orgId: string, appId: string, pipelineId: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineVersions', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineVersions', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineVersions', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines: async (orgId: string, appId: string, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelines', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelines', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelinesInOrg: async (orgId: string, app?: Array<string>, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelinesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app) {
                localVarQueryParameter['app'] = app;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {object} body 
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline: async (orgId: string, appId: string, pipelineId: string, body: object, ifMatch?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updatePipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatePipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updatePipeline', 'pipelineId', pipelineId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePipeline', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PipelinesApi - functional programming interface
 * @export
 */
export const PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {object} body 
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipeline(orgId: string, appId: string, body: object, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipeline(orgId, appId, body, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineCriteriaCreateBody} pipelineCriteriaCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineCriteria(orgId: string, appId: string, pipelineId: string, pipelineCriteriaCreateBody: PipelineCriteriaCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineCriteria(orgId, appId, pipelineId, pipelineCriteriaCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipeline(orgId: string, appId: string, pipelineId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipeline(orgId, appId, pipelineId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineCriteria(orgId: string, appId: string, pipelineId: string, criteriaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineCriteria(orgId, appId, pipelineId, criteriaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} batchType The batch type, only artefact is implemented.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatch(orgId: string, appId: string, pipelineId: string, batchType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(orgId, appId, pipelineId, batchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestPipelineDefinitionSchema(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestPipelineDefinitionSchema(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(orgId: string, appId: string, pipelineId: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(orgId, appId, pipelineId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineCriteria(orgId: string, appId: string, pipelineId: string, criteriaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineCriteria(orgId, appId, pipelineId, criteriaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineDefinition(orgId: string, appId: string, pipelineId: string, version?: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineDefinition(orgId, appId, pipelineId, version, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} [pipeline] An optional filter by Pipeline ID.
         * @param {{ [key: string]: string; }} [match] Optional key value match filters on the criteria.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineCriteriaInApp(orgId: string, appId: string, pipeline?: string, match?: { [key: string]: string; }, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineCriteria>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineCriteriaInApp(orgId, appId, pipeline, match, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineVersions(orgId: string, appId: string, pipelineId: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineVersions(orgId, appId, pipelineId, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelines(orgId: string, appId: string, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelines(orgId, appId, perPage, page, trigger, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelinesInOrg(orgId: string, app?: Array<string>, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelinesInOrg(orgId, app, perPage, page, trigger, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {object} body 
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipeline(orgId: string, appId: string, pipelineId: string, body: object, ifMatch?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipeline(orgId, appId, pipelineId, body, ifMatch, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PipelinesApi - factory interface
 * @export
 */
export const PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {PipelinesApiCreatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline(requestParameters: PipelinesApiCreatePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.createPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.body, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {PipelinesApiCreatePipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineCriteria(requestParameters: PipelinesApiCreatePipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineCriteria> {
            return localVarFp.createPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineCriteriaCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {PipelinesApiDeletePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(requestParameters: PipelinesApiDeletePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {PipelinesApiDeletePipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineCriteria(requestParameters: PipelinesApiDeletePipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {PipelinesApiGetBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch(requestParameters: PipelinesApiGetBatchRequest, options?: AxiosRequestConfig): AxiosPromise<Batch> {
            return localVarFp.getBatch(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.batchType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {PipelinesApiGetLatestPipelineDefinitionSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestPipelineDefinitionSchema(requestParameters: PipelinesApiGetLatestPipelineDefinitionSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getLatestPipelineDefinitionSchema(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {PipelinesApiGetPipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(requestParameters: PipelinesApiGetPipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {PipelinesApiGetPipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineCriteria(requestParameters: PipelinesApiGetPipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineCriteria> {
            return localVarFp.getPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {PipelinesApiGetPipelineDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDefinition(requestParameters: PipelinesApiGetPipelineDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPipelineDefinition(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {PipelinesApiListPipelineCriteriaInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineCriteriaInApp(requestParameters: PipelinesApiListPipelineCriteriaInAppRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineCriteria>> {
            return localVarFp.listPipelineCriteriaInApp(requestParameters.orgId, requestParameters.appId, requestParameters.pipeline, requestParameters.match, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {PipelinesApiListPipelineVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineVersions(requestParameters: PipelinesApiListPipelineVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineVersion>> {
            return localVarFp.listPipelineVersions(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {PipelinesApiListPipelinesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines(requestParameters: PipelinesApiListPipelinesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.listPipelines(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {PipelinesApiListPipelinesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelinesInOrg(requestParameters: PipelinesApiListPipelinesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.listPipelinesInOrg(requestParameters.orgId, requestParameters.app, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {PipelinesApiUpdatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(requestParameters: PipelinesApiUpdatePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.updatePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.body, requestParameters.ifMatch, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiCreatePipelineRequest
 */
export interface PipelinesApiCreatePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiCreatePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiCreatePipeline
     */
    readonly appId: string

    /**
     * 
     * @type {object}
     * @memberof PipelinesApiCreatePipeline
     */
    readonly body: object

    /**
     * Optionally validate the request but do not persist the actual Pipeline.
     * @type {boolean}
     * @memberof PipelinesApiCreatePipeline
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for createPipelineCriteria operation in PipelinesApi.
 * @export
 * @interface PipelinesApiCreatePipelineCriteriaRequest
 */
export interface PipelinesApiCreatePipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiCreatePipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiCreatePipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiCreatePipelineCriteria
     */
    readonly pipelineId: string

    /**
     * 
     * @type {PipelineCriteriaCreateBody}
     * @memberof PipelinesApiCreatePipelineCriteria
     */
    readonly pipelineCriteriaCreateBody: PipelineCriteriaCreateBody
}

/**
 * Request parameters for deletePipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiDeletePipelineRequest
 */
export interface PipelinesApiDeletePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiDeletePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiDeletePipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiDeletePipeline
     */
    readonly pipelineId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PipelinesApiDeletePipeline
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for deletePipelineCriteria operation in PipelinesApi.
 * @export
 * @interface PipelinesApiDeletePipelineCriteriaRequest
 */
export interface PipelinesApiDeletePipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiDeletePipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiDeletePipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiDeletePipelineCriteria
     */
    readonly pipelineId: string

    /**
     * The Criteria ID
     * @type {string}
     * @memberof PipelinesApiDeletePipelineCriteria
     */
    readonly criteriaId: string
}

/**
 * Request parameters for getBatch operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetBatchRequest
 */
export interface PipelinesApiGetBatchRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiGetBatch
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiGetBatch
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiGetBatch
     */
    readonly pipelineId: string

    /**
     * The batch type, only artefact is implemented.
     * @type {string}
     * @memberof PipelinesApiGetBatch
     */
    readonly batchType: string
}

/**
 * Request parameters for getLatestPipelineDefinitionSchema operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetLatestPipelineDefinitionSchemaRequest
 */
export interface PipelinesApiGetLatestPipelineDefinitionSchemaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiGetLatestPipelineDefinitionSchema
     */
    readonly orgId: string
}

/**
 * Request parameters for getPipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineRequest
 */
export interface PipelinesApiGetPipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiGetPipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiGetPipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiGetPipeline
     */
    readonly pipelineId: string

    /**
     * An optional Pipeline Version ID.
     * @type {string}
     * @memberof PipelinesApiGetPipeline
     */
    readonly version?: string
}

/**
 * Request parameters for getPipelineCriteria operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineCriteriaRequest
 */
export interface PipelinesApiGetPipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineCriteria
     */
    readonly pipelineId: string

    /**
     * The Criteria ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineCriteria
     */
    readonly criteriaId: string
}

/**
 * Request parameters for getPipelineDefinition operation in PipelinesApi.
 * @export
 * @interface PipelinesApiGetPipelineDefinitionRequest
 */
export interface PipelinesApiGetPipelineDefinitionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineDefinition
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineDefinition
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiGetPipelineDefinition
     */
    readonly pipelineId: string

    /**
     * An optional Pipeline Version ID.
     * @type {string}
     * @memberof PipelinesApiGetPipelineDefinition
     */
    readonly version?: string

    /**
     * 
     * @type {string}
     * @memberof PipelinesApiGetPipelineDefinition
     */
    readonly accept?: string
}

/**
 * Request parameters for listPipelineCriteriaInApp operation in PipelinesApi.
 * @export
 * @interface PipelinesApiListPipelineCriteriaInAppRequest
 */
export interface PipelinesApiListPipelineCriteriaInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly appId: string

    /**
     * An optional filter by Pipeline ID.
     * @type {string}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly pipeline?: string

    /**
     * Optional key value match filters on the criteria.
     * @type {{ [key: string]: string; }}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly match?: { [key: string]: string; }

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelinesApiListPipelineCriteriaInApp
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineVersions operation in PipelinesApi.
 * @export
 * @interface PipelinesApiListPipelineVersionsRequest
 */
export interface PipelinesApiListPipelineVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiListPipelineVersions
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiListPipelineVersions
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiListPipelineVersions
     */
    readonly pipelineId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelinesApiListPipelineVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelinesApiListPipelineVersions
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelines operation in PipelinesApi.
 * @export
 * @interface PipelinesApiListPipelinesRequest
 */
export interface PipelinesApiListPipelinesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiListPipelines
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiListPipelines
     */
    readonly appId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelinesApiListPipelines
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelinesApiListPipelines
     */
    readonly page?: string

    /**
     * An optional filter by trigger type.
     * @type {string}
     * @memberof PipelinesApiListPipelines
     */
    readonly trigger?: string

    /**
     * Optional filter by pipeline metadata
     * @type {{ [key: string]: string; }}
     * @memberof PipelinesApiListPipelines
     */
    readonly metadata?: { [key: string]: string; }
}

/**
 * Request parameters for listPipelinesInOrg operation in PipelinesApi.
 * @export
 * @interface PipelinesApiListPipelinesInOrgRequest
 */
export interface PipelinesApiListPipelinesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly orgId: string

    /**
     * An optional list of Application IDs.
     * @type {Array<string>}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly app?: Array<string>

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly page?: string

    /**
     * An optional filter by trigger type.
     * @type {string}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly trigger?: string

    /**
     * Optional filter by pipeline metadata
     * @type {{ [key: string]: string; }}
     * @memberof PipelinesApiListPipelinesInOrg
     */
    readonly metadata?: { [key: string]: string; }
}

/**
 * Request parameters for updatePipeline operation in PipelinesApi.
 * @export
 * @interface PipelinesApiUpdatePipelineRequest
 */
export interface PipelinesApiUpdatePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly pipelineId: string

    /**
     * 
     * @type {object}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly body: object

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly ifMatch?: string

    /**
     * Optionally validate the request but do not persist the update.
     * @type {boolean}
     * @memberof PipelinesApiUpdatePipeline
     */
    readonly dryRun?: boolean
}

/**
 * PipelinesApi - object-oriented interface
 * @export
 * @class PipelinesApi
 * @extends {BaseAPI}
 */
export class PipelinesApi extends BaseAPI {
    /**
     * 
     * @summary Create a Pipeline within an Application.
     * @param {PipelinesApiCreatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public createPipeline(requestParameters: PipelinesApiCreatePipelineRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.body, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
     * @summary Create a new trigger matching criteria for this Pipeline.
     * @param {PipelinesApiCreatePipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public createPipelineCriteria(requestParameters: PipelinesApiCreatePipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).createPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineCriteriaCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a pipeline within an application.
     * @param {PipelinesApiDeletePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipeline(requestParameters: PipelinesApiDeletePipelineRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the Pipeline Criteria with the given id.
     * @param {PipelinesApiDeletePipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public deletePipelineCriteria(requestParameters: PipelinesApiDeletePipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).deletePipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the current state of a trigger batch for a Pipeline if one exists
     * @summary Read the current state of a trigger batch
     * @param {PipelinesApiGetBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getBatch(requestParameters: PipelinesApiGetBatchRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getBatch(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.batchType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the latest pipeline schema
     * @param {PipelinesApiGetLatestPipelineDefinitionSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getLatestPipelineDefinitionSchema(requestParameters: PipelinesApiGetLatestPipelineDefinitionSchemaRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getLatestPipelineDefinitionSchema(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Pipeline within an Application.
     * @param {PipelinesApiGetPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipeline(requestParameters: PipelinesApiGetPipelineRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Pipeline Criteria with the given id.
     * @param {PipelinesApiGetPipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineCriteria(requestParameters: PipelinesApiGetPipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pipeline schema.
     * @param {PipelinesApiGetPipelineDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public getPipelineDefinition(requestParameters: PipelinesApiGetPipelineDefinitionRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).getPipelineDefinition(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
     * @summary List the trigger matching criteria defined for Pipelines in this Application.
     * @param {PipelinesApiListPipelineCriteriaInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelineCriteriaInApp(requestParameters: PipelinesApiListPipelineCriteriaInAppRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelineCriteriaInApp(requestParameters.orgId, requestParameters.appId, requestParameters.pipeline, requestParameters.match, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all versions of the pipeline
     * @param {PipelinesApiListPipelineVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelineVersions(requestParameters: PipelinesApiListPipelineVersionsRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelineVersions(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Pipelines within an Application.
     * @param {PipelinesApiListPipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelines(requestParameters: PipelinesApiListPipelinesRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelines(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Pipelines within an Organization. This can be filtered by Application.
     * @param {PipelinesApiListPipelinesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public listPipelinesInOrg(requestParameters: PipelinesApiListPipelinesInOrgRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).listPipelinesInOrg(requestParameters.orgId, requestParameters.app, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update a Pipeline within an Application.
     * @param {PipelinesApiUpdatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PipelinesApi
     */
    public updatePipeline(requestParameters: PipelinesApiUpdatePipelineRequest, options?: AxiosRequestConfig) {
        return PipelinesApiFp(this.configuration).updatePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.body, requestParameters.ifMatch, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('approvePipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/approve`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('cancelPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/cancel`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {string} orgId The Organization ID
         * @param {AgentCreateBody} agentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent: async (orgId: string, agentCreateBody: AgentCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createAgent', 'orgId', orgId)
            // verify required parameter 'agentCreateBody' is not null or undefined
            assertParamExists('createAgent', 'agentCreateBody', agentCreateBody)
            const localVarPath = `/orgs/{orgId}/agents`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (orgId: string, applicationCreationRequest: ApplicationCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createApplication', 'orgId', orgId)
            // verify required parameter 'applicationCreationRequest' is not null or undefined
            assertParamExists('createApplication', 'applicationCreationRequest', applicationCreationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.
         * @param {CreateArtefactVersion} createArtefactVersion The data needed to register a new Artefact Version within the organization.
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
         * @param {string} [accept] Indicates which content types the client is able to understand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtefactVersion: async (orgId: string, createArtefactVersion: CreateArtefactVersion, vcs?: string, dryRun?: boolean, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createArtefactVersion', 'orgId', orgId)
            // verify required parameter 'createArtefactVersion' is not null or undefined
            assertParamExists('createArtefactVersion', 'createArtefactVersion', createArtefactVersion)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createArtefactVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDeployment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createDeployment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('createDeployment', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('createDeployment', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeprecatedImageBuild: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('createDeprecatedImageBuild', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createEnvironment', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('createEnvironment', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentType: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createEnvironmentType', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('createEnvironmentType', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteInOrg: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createInviteInOrg', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('createInviteInOrg', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {KeyCreateBody} keyCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (orgId: string, agentId: string, keyCreateBody: KeyCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createKey', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('createKey', 'agentId', agentId)
            // verify required parameter 'keyCreateBody' is not null or undefined
            assertParamExists('createKey', 'keyCreateBody', keyCreateBody)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {object} body 
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline: async (orgId: string, appId: string, body: object, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipeline', 'appId', appId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPipeline', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineCriteriaCreateBody} pipelineCriteriaCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineCriteria: async (orgId: string, appId: string, pipelineId: string, pipelineCriteriaCreateBody: PipelineCriteriaCreateBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('createPipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'pipelineCriteriaCreateBody' is not null or undefined
            assertParamExists('createPipelineCriteria', 'pipelineCriteriaCreateBody', pipelineCriteriaCreateBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineCriteriaCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineRunCreateBody} pipelineRunCreateBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRun: async (orgId: string, appId: string, pipelineId: string, pipelineRunCreateBody: PipelineRunCreateBody, idempotencyKey?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('createPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'pipelineRunCreateBody' is not null or undefined
            assertParamExists('createPipelineRun', 'pipelineRunCreateBody', pipelineRunCreateBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineRunCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {PipelineRunCreateByTriggerCriteriaBody} pipelineRunCreateByTriggerCriteriaBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRunByTriggerCriteria: async (orgId: string, appId: string, pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody, idempotencyKey?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'appId', appId)
            // verify required parameter 'pipelineRunCreateByTriggerCriteriaBody' is not null or undefined
            assertParamExists('createPipelineRunByTriggerCriteria', 'pipelineRunCreateByTriggerCriteriaBody', pipelineRunCreateByTriggerCriteriaBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipeline-runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineRunCreateByTriggerCriteriaBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} body A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (orgId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPublicKey', 'orgId', orgId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPublicKey', 'body', body)
            const localVarPath = `/orgs/{orgId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceAccount: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceAccount', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('createResourceAccount', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinition: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDefinition', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('createResourceDefinition', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDriver: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDriver', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('createResourceDriver', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID
         * @param {NewServiceUserRequest} newServiceUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceUserInOrg: async (orgId: string, newServiceUserRequest: NewServiceUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createServiceUserInOrg', 'orgId', orgId)
            // verify required parameter 'newServiceUserRequest' is not null or undefined
            assertParamExists('createServiceUserInOrg', 'newServiceUserRequest', newServiceUserRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newServiceUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInApp: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createUserRoleInApp', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('createUserRoleInApp', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInEnvType: async (orgId: string, envType: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserToken: async (userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createUserToken', 'userId', userId)
            // verify required parameter 'tokenDefinitionRequest' is not null or undefined
            assertParamExists('createUserToken', 'tokenDefinitionRequest', tokenDefinitionRequest)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfile: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('createWorkloadProfile', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {string} orgId The Organization ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfileChartVersion: async (orgId: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createWorkloadProfileChartVersion', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-chart-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...(localVarFormParams as any).getHeaders?.(), ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type, may include a resource class: {type}.{class}.  
         * @param {string} resId The Resource ID.  
         * @param {boolean} [detach] If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActiveResource: async (orgId: string, appId: string, envId: string, type: string, resId: string, detach?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteActiveResource', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteActiveResource', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteActiveResource', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteActiveResource', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('deleteActiveResource', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (detach !== undefined) {
                localVarQueryParameter['detach'] = detach;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent: async (orgId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteAgent', 'agentId', agentId)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteApplication', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteApplication', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtefact: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteArtefact', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('deleteArtefact', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentType: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('deleteEnvironmentType', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {string} fingerprint The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyInAgent: async (orgId: string, agentId: string, fingerprint: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'agentId', agentId)
            // verify required parameter 'fingerprint' is not null or undefined
            assertParamExists('deleteKeyInAgent', 'fingerprint', fingerprint)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys/{fingerprint}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"fingerprint"}}`, encodeURIComponent(String(fingerprint)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline: async (orgId: string, appId: string, pipelineId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipeline', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineCriteria: async (orgId: string, appId: string, pipelineId: string, criteriaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('deletePipelineCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deletePipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('deletePipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deletePipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (orgId: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePublicKey', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deletePublicKey', 'keyId', keyId)
            const localVarPath = `/orgs/{orgId}/keys/{keyId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceAccount: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('deleteResourceAccount', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinition: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('deleteResourceDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDriver: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('deleteResourceDriver', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInApp: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInEnvType: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInOrg: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInOrg', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserToken: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteUserToken', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkloadProfile: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('deleteWorkloadProfile', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyPipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('denyPipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/deny`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getApplication', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getApplication', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactVersion: async (orgId: string, artefactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getArtefactVersion', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getArtefactVersion', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} batchType The batch type, only artefact is implemented.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch: async (orgId: string, appId: string, pipelineId: string, batchType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getBatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getBatch', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getBatch', 'pipelineId', pipelineId)
            // verify required parameter 'batchType' is not null or undefined
            assertParamExists('getBatch', 'batchType', batchType)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/batches/{batchType}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"batchType"}}`, encodeURIComponent(String(batchType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta: async (orgId: string, appId: string, deltaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('getDelta', 'deltaId', deltaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDeployment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDeployment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getDeployment', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('getDeployment', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeprecatedImage: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDeprecatedImage', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getDeprecatedImage', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentType: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('getEnvironmentType', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestPipelineDefinitionSchema: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestPipelineDefinitionSchema', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipeline-schemas/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getOrganization', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline: async (orgId: string, appId: string, pipelineId: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipeline', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineApprovalRequest: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'jobId', jobId)
            // verify required parameter 'approvalId' is not null or undefined
            assertParamExists('getPipelineApprovalRequest', 'approvalId', approvalId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"approvalId"}}`, encodeURIComponent(String(approvalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineCriteria: async (orgId: string, appId: string, pipelineId: string, criteriaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'pipelineId', pipelineId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('getPipelineCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDefinition: async (orgId: string, appId: string, pipelineId: string, version?: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineDefinition', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/schema`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineJob: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineJob', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineJob', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineJob', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineJob', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getPipelineJob', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('getPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (orgId: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPublicKey', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getPublicKey', 'keyId', keyId)
            const localVarPath = `/orgs/{orgId}/keys/{keyId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceAccount: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('getResourceAccount', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDefinition: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('getResourceDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDriver: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('getResourceDriver', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntime: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getRuntime', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getRuntime', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getRuntime', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSets', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSets', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInApp: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInEnvType: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInOrg: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInOrg', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getUserToken', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionDeploymentSet: async (orgId: string, artefactVersionId: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionDeploymentSet', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionDeploymentSet', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-deployment-set`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionSpec: async (orgId: string, artefactVersionId: string, accept?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionSpec', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('getWorkloadArtefactVersionSpec', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-spec`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept != null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadProfile: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getWorkloadProfile', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResources: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listActiveResources', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listActiveResources', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listActiveResources', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} [fingerprint] The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents: async (orgId: string, fingerprint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAgents', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/agents`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listApplications', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.
         * @param {number} [limit] (Optional) Limit the number of versions returned by the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersions: async (orgId: string, artefactId: string, archived?: boolean, reference?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefactVersions', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('listArtefactVersions', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {string} orgId The organization ID.
         * @param {string} [name] (Optional) Filter Artefact Versions by name.
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [type] (Optional) Filter by artefact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersionsInOrg: async (orgId: string, name?: string, reference?: string, archived?: boolean, type?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefactVersionsInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.
         * @param {string} [type] (Optional) Filter Artefacts by type.
         * @param {string} [name] (Optional) Filter Artefacts by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefacts: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listArtefacts', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [from] Optional filter for entries created after the given time.
         * @param {string} [to] Optional filter for entries created before the given time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogEntries: async (orgId: string, perPage?: number, page?: string, from?: string, to?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listAuditLogEntries', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/audit-logs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentErrors: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('listDeploymentErrors', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [pipelineRunId] An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments: async (orgId: string, appId: string, envId: string, pipelineRunId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeployments', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listDeployments', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('listDeployments', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipelineRunId !== undefined) {
                localVarQueryParameter['pipelineRunId'] = pipelineRunId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImageBuilds: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeprecatedImageBuilds', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('listDeprecatedImageBuilds', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImages: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listDeprecatedImages', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listEnvironmentTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listEnvironments', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listEnvironments', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {string} orgId The organization ID.
         * @param {boolean} [active] If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHumanitecPublicKeys: async (orgId: string, active?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listHumanitecPublicKeys', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/humanitec-keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesInOrg: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listInvitesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeysInAgent: async (orgId: string, agentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listKeysInAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('listKeysInAgent', 'agentId', agentId)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {Array<string>} [run] An optional Pipeline Run ID.
         * @param {string} [status] Optional filter by status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineApprovalRequests: async (orgId: string, appId: string, perPage?: number, page?: string, pipeline?: Array<string>, run?: Array<string>, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineApprovalRequests', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineApprovalRequests', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/approvals`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pipeline) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (run) {
                localVarQueryParameter['run'] = run;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} [pipeline] An optional filter by Pipeline ID.
         * @param {{ [key: string]: string; }} [match] Optional key value match filters on the criteria.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineCriteriaInApp: async (orgId: string, appId: string, pipeline?: string, match?: { [key: string]: string; }, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineCriteriaInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineCriteriaInApp', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipeline-criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipeline !== undefined) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineJobs: async (orgId: string, appId: string, pipelineId: string, runId: string, status?: Array<string>, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineJobs', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineJobs', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineJobs', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('listPipelineJobs', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRuns: async (orgId: string, appId: string, pipelineId: string, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineRuns', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineRuns', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineRuns', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRunsByOrg: async (orgId: string, app?: Array<string>, pipeline?: Array<string>, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineRunsByOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipeline-runs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app) {
                localVarQueryParameter['app'] = app;
            }

            if (pipeline) {
                localVarQueryParameter['pipeline'] = pipeline;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['created_after'] = (createdAfter as any instanceof Date) ?
                    (createdAfter as any).toISOString() :
                    createdAfter;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = (createdBefore as any instanceof Date) ?
                    (createdBefore as any).toISOString() :
                    createdBefore;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {number} stepIndex The index of the step within the Job
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineStepLogs: async (orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, stepIndex: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'runId', runId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'jobId', jobId)
            // verify required parameter 'stepIndex' is not null or undefined
            assertParamExists('listPipelineStepLogs', 'stepIndex', stepIndex)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/steps/{stepIndex}/logs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"stepIndex"}}`, encodeURIComponent(String(stepIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineVersions: async (orgId: string, appId: string, pipelineId: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelineVersions', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelineVersions', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('listPipelineVersions', 'pipelineId', pipelineId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines: async (orgId: string, appId: string, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelines', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listPipelines', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelinesInOrg: async (orgId: string, app?: Array<string>, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPipelinesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/pipelines`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app) {
                localVarQueryParameter['app'] = app;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (trigger !== undefined) {
                localVarQueryParameter['trigger'] = trigger;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} [fingerprint] The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys: async (orgId: string, fingerprint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPublicKeys', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccountTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceAccountTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccounts: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceAccounts', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {string} [_class] (Optional) Filter Resource Definitions that may match a specific Class.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDefinitions: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, _class?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceDefinitions', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }

            if (_class !== undefined) {
                localVarQueryParameter['class'] = _class;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDrivers: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceDrivers', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {Array<string>} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuntime: async (orgId: string, appId: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listRuntime', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listRuntime', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInApp: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listUserRolesInApp', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInEnvType: async (orgId: string, envType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('listUserRolesInEnvType', 'envType', envType)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInOrg: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTokens: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserTokens', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [id] Filter Chart Versions by Chart Version ID.
         * @param {string} [version] Filter Chart Versions by Chart Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileChartVersions: async (orgId: string, perPage?: number, page?: string, id?: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileChartVersions', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-chart-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileFeatures: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileFeatures', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-features`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileVersions: async (orgId: string, profileQid: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileVersions', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('listWorkloadProfileVersions', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID
         * @param {boolean} [deprecated] Whether to include deprecated profiles
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfiles: async (orgId: string, deprecated?: boolean, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfiles', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deprecated !== undefined) {
                localVarQueryParameter['deprecated'] = deprecated;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, diff?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/secretstores`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateSecretStorePayloadRequest} createSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresPost: async (orgId: string, createSecretStorePayloadRequest: CreateSecretStorePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresPost', 'orgId', orgId)
            // verify required parameter 'createSecretStorePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresPost', 'createSecretStorePayloadRequest', createSecretStorePayloadRequest)
            const localVarPath = `/orgs/{orgId}/secretstores`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSecretStorePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdDelete: async (orgId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdDelete', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdDelete', 'storeId', storeId)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdGet: async (orgId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdGet', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdGet', 'storeId', storeId)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {UpdateSecretStorePayloadRequest} updateSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdPatch: async (orgId: string, storeId: string, updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'storeId', storeId)
            // verify required parameter 'updateSecretStorePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'updateSecretStorePayloadRequest', updateSecretStorePayloadRequest)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSecretStorePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {AgentPatchBody} agentPatchBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent: async (orgId: string, agentId: string, agentPatchBody: AgentPatchBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchAgent', 'orgId', orgId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('patchAgent', 'agentId', agentId)
            // verify required parameter 'agentPatchBody' is not null or undefined
            assertParamExists('patchAgent', 'agentPatchBody', agentPatchBody)
            const localVarPath = `/orgs/{orgId}/agents/{agentId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentPatchBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {string} versionId The Version ID.
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtefactVersion: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('patchArtefactVersion', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('patchArtefactVersion', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReplicas: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchReplicas', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('patchReplicas', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('patchReplicas', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchReplicas', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceAccount: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('patchResourceAccount', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('patchResourceAccount', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceDefinition: async (orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('patchResourceDefinition', 'defId', defId)
            // verify required parameter 'patchResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('patchResourceDefinition', 'patchResourceDefinitionRequestRequest', patchResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta: async (orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('putDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('putDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('putDelta', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('putDelta', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResourceGraph: async (orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('queryResourceGraph', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('queryResourceGraph', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('queryResourceGraph', 'envId', envId)
            // verify required parameter 'resourceProvisionRequestRequest' is not null or undefined
            assertParamExists('queryResourceGraph', 'resourceProvisionRequestRequest', resourceProvisionRequestRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graph`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceProvisionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaseEnvironment: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('rebaseEnvironment', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('rebaseEnvironment', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartPipelineRun: async (orgId: string, appId: string, pipelineId: string, runId: string, idempotencyKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('restartPipelineRun', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('restartPipelineRun', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('restartPipelineRun', 'pipelineId', pipelineId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('restartPipelineRun', 'runId', runId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/restart`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)))
                .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idempotencyKey != null) {
                localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('updateCurrentUser', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {EnvironmentBaseUpdateRequest} [environmentBaseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment: async (orgId: string, appId: string, envId: string, environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateEnvironment', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateEnvironment', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('updateEnvironment', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentBaseUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {UpdateEnvironmentTypePayloadRequest} updateEnvironmentTypePayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentType: async (orgId: string, envTypeId: string, updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateEnvironmentType', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('updateEnvironmentType', 'envTypeId', envTypeId)
            // verify required parameter 'updateEnvironmentTypePayloadRequest' is not null or undefined
            assertParamExists('updateEnvironmentType', 'updateEnvironmentTypePayloadRequest', updateEnvironmentTypePayloadRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvironmentTypePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaused: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updatePaused', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatePaused', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('updatePaused', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePaused', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {object} body 
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline: async (orgId: string, appId: string, pipelineId: string, body: object, ifMatch?: string, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updatePipeline', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updatePipeline', 'appId', appId)
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('updatePipeline', 'pipelineId', pipelineId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updatePipeline', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/x-yaml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinition: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('updateResourceDefinition', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('updateResourceDefinition', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDriver: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDriver', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('updateResourceDriver', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('updateResourceDriver', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInApp: async (orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInEnvType: async (orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInOrg: async (orgId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {WorkloadProfileUpdateRequest} workloadProfileUpdateRequest Workload profile details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkloadProfile: async (orgId: string, profileQid: string, workloadProfileUpdateRequest: WorkloadProfileUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'profileQid', profileQid)
            // verify required parameter 'workloadProfileUpdateRequest' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'workloadProfileUpdateRequest', workloadProfileUpdateRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approvePipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approvePipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPipelineRun(orgId, appId, pipelineId, runId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {string} orgId The Organization ID
         * @param {AgentCreateBody} agentCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgent(orgId: string, agentCreateBody: AgentCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgent(orgId, agentCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(orgId: string, applicationCreationRequest: ApplicationCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(orgId, applicationCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.
         * @param {CreateArtefactVersion} createArtefactVersion The data needed to register a new Artefact Version within the organization.
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
         * @param {string} [accept] Indicates which content types the client is able to understand.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtefactVersion(orgId: string, createArtefactVersion: CreateArtefactVersion, vcs?: string, dryRun?: boolean, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtefactVersion(orgId, createArtefactVersion, vcs, dryRun, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeployment(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeployment(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDeprecatedImageBuild(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDeprecatedImageBuild(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironment(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnvironmentType(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironmentType(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteInOrg(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteInOrg(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {KeyCreateBody} keyCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(orgId: string, agentId: string, keyCreateBody: KeyCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Key>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(orgId, agentId, keyCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {object} body 
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipeline(orgId: string, appId: string, body: object, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipeline(orgId, appId, body, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineCriteriaCreateBody} pipelineCriteriaCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineCriteria(orgId: string, appId: string, pipelineId: string, pipelineCriteriaCreateBody: PipelineCriteriaCreateBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineCriteria(orgId, appId, pipelineId, pipelineCriteriaCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {PipelineRunCreateBody} pipelineRunCreateBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineRun(orgId: string, appId: string, pipelineId: string, pipelineRunCreateBody: PipelineRunCreateBody, idempotencyKey?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineRun(orgId, appId, pipelineId, pipelineRunCreateBody, idempotencyKey, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {PipelineRunCreateByTriggerCriteriaBody} pipelineRunCreateByTriggerCriteriaBody 
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the actual Pipeline Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPipelineRunByTriggerCriteria(orgId: string, appId: string, pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody, idempotencyKey?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPipelineRunByTriggerCriteria(orgId, appId, pipelineRunCreateByTriggerCriteriaBody, idempotencyKey, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} body A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(orgId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(orgId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceAccount(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAccount(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDefinition(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDefinition(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDriver(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDriver(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID
         * @param {NewServiceUserRequest} newServiceUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceUserInOrg(orgId: string, newServiceUserRequest: NewServiceUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceUserInOrg(orgId, newServiceUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserRoleInApp(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRoleInApp(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserRoleInEnvType(orgId: string, envType: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRoleInEnvType(orgId, envType, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserToken(userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserToken(userId, tokenDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkloadProfile(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkloadProfile(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {string} orgId The Organization ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkloadProfileChartVersion(orgId: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileChartVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkloadProfileChartVersion(orgId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type, may include a resource class: {type}.{class}.  
         * @param {string} resId The Resource ID.  
         * @param {boolean} [detach] If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActiveResource(orgId: string, appId: string, envId: string, type: string, resId: string, detach?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActiveResource(orgId, appId, envId, type, resId, detach, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgent(orgId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgent(orgId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplication(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplication(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtefact(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtefact(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironmentType(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironmentType(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {string} fingerprint The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKeyInAgent(orgId: string, agentId: string, fingerprint: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKeyInAgent(orgId, agentId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipeline(orgId: string, appId: string, pipelineId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipeline(orgId, appId, pipelineId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineCriteria(orgId: string, appId: string, pipelineId: string, criteriaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineCriteria(orgId, appId, pipelineId, criteriaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, ifMatch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePipelineRun(orgId, appId, pipelineId, runId, ifMatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(orgId: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(orgId, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceAccount(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAccount(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDefinition(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDefinition(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDefinitionCriteria(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDefinitionCriteria(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDriver(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDriver(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInApp(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInApp(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInEnvType(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInEnvType(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInOrg(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInOrg(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserToken(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkloadProfile(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkloadProfile(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyPipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyPipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplication(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtefactVersion(orgId: string, artefactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtefactVersion(orgId, artefactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} batchType The batch type, only artefact is implemented.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatch(orgId: string, appId: string, pipelineId: string, batchType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatch(orgId, appId, pipelineId, batchType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelta(orgId: string, appId: string, deltaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelta(orgId, appId, deltaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeployment(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeployment(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeprecatedImage(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeprecatedImage(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentType(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentType(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestPipelineDefinitionSchema(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestPipelineDefinitionSchema(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getLatestWorkloadProfileVersion(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestWorkloadProfileVersion(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipeline(orgId: string, appId: string, pipelineId: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipeline(orgId, appId, pipelineId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {string} approvalId The Approval ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineApprovalRequest(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, approvalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineApprovalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineApprovalRequest(orgId, appId, pipelineId, runId, jobId, approvalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} criteriaId The Criteria ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineCriteria(orgId: string, appId: string, pipelineId: string, criteriaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineCriteria(orgId, appId, pipelineId, criteriaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [version] An optional Pipeline Version ID.
         * @param {string} [accept] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineDefinition(orgId: string, appId: string, pipelineId: string, version?: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineDefinition(orgId, appId, pipelineId, version, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineJob(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineJob(orgId, appId, pipelineId, runId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPipelineRun(orgId, appId, pipelineId, runId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(orgId: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(orgId, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceAccount(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAccount(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceDefinition(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceDefinition(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceDriver(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceDriver(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuntime(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuntime(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSets(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSets(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInApp(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInApp(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInEnvType(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInEnvType(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInOrg(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInOrg(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserToken(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadArtefactVersionDeploymentSet(orgId: string, artefactVersionId: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadArtefactVersionDeploymentSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadArtefactVersionDeploymentSet(orgId, artefactVersionId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {string} orgId The organization ID.
         * @param {string} artefactVersionId The Artefact Version ID.
         * @param {string} [accept] The accepted content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadArtefactVersionSpec(orgId: string, artefactVersionId: string, accept?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadArtefactVersionSpec(orgId, artefactVersionId, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadProfile(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadProfile(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveResourceByDefinition(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveResourceByDefinition(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveResources(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveResources(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} [fingerprint] The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgents(orgId: string, fingerprint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgents(orgId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplications(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplications(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.
         * @param {number} [limit] (Optional) Limit the number of versions returned by the endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefactVersions(orgId: string, artefactId: string, archived?: boolean, reference?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefactVersions(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {string} orgId The organization ID.
         * @param {string} [name] (Optional) Filter Artefact Versions by name.
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
         * @param {boolean} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
         * @param {string} [type] (Optional) Filter by artefact type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefactVersionsInOrg(orgId: string, name?: string, reference?: string, archived?: boolean, type?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefactVersionsInOrg(orgId, name, reference, archived, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.
         * @param {string} [type] (Optional) Filter Artefacts by type.
         * @param {string} [name] (Optional) Filter Artefacts by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtefacts(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtefacts(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [from] Optional filter for entries created after the given time.
         * @param {string} [to] Optional filter for entries created before the given time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuditLogEntries(orgId: string, perPage?: number, page?: string, from?: string, to?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuditLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogEntries(orgId, perPage, page, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeploymentErrors(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeploymentErrors(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [pipelineRunId] An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeployments(orgId: string, appId: string, envId: string, pipelineRunId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeployments(orgId, appId, envId, pipelineRunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.
         * @param {string} imageId The Image ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeprecatedImageBuilds(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeprecatedImageBuilds(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDeprecatedImages(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDeprecatedImages(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironmentTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironmentTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEnvironments(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {string} orgId The organization ID.
         * @param {boolean} [active] If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listHumanitecPublicKeys(orgId: string, active?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanitecPublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listHumanitecPublicKeys(orgId, active, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesInOrg(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvitesInOrg(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeysInAgent(orgId: string, agentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Key>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeysInAgent(orgId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {Array<string>} [run] An optional Pipeline Run ID.
         * @param {string} [status] Optional filter by status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineApprovalRequests(orgId: string, appId: string, perPage?: number, page?: string, pipeline?: Array<string>, run?: Array<string>, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineApprovalRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineApprovalRequests(orgId, appId, perPage, page, pipeline, run, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} [pipeline] An optional filter by Pipeline ID.
         * @param {{ [key: string]: string; }} [match] Optional key value match filters on the criteria.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineCriteriaInApp(orgId: string, appId: string, pipeline?: string, match?: { [key: string]: string; }, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineCriteria>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineCriteriaInApp(orgId, appId, pipeline, match, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineJobs(orgId: string, appId: string, pipelineId: string, runId: string, status?: Array<string>, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineJobPartial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineJobs(orgId, appId, pipelineId, runId, status, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineRuns(orgId: string, appId: string, pipelineId: string, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineRuns(orgId, appId, pipelineId, env, status, completed, createdAfter, createdBefore, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {Array<string>} [pipeline] An optional list of Pipeline IDs.
         * @param {string} [env] An optional Environment ID
         * @param {Array<string>} [status] Optional filter by status.
         * @param {boolean} [completed] Optional filer by completed or not.
         * @param {string} [createdAfter] Optional filter by creation after date time.
         * @param {string} [createdBefore] Optional filter by creation before date time
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineRunsByOrg(orgId: string, app?: Array<string>, pipeline?: Array<string>, env?: string, status?: Array<string>, completed?: boolean, createdAfter?: string, createdBefore?: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineRunsByOrg(orgId, app, pipeline, env, status, completed, createdAfter, createdBefore, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} jobId The Job ID
         * @param {number} stepIndex The index of the step within the Job
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineStepLogs(orgId: string, appId: string, pipelineId: string, runId: string, jobId: string, stepIndex: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineStepLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineStepLogs(orgId, appId, pipelineId, runId, jobId, stepIndex, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelineVersions(orgId: string, appId: string, pipelineId: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelineVersions(orgId, appId, pipelineId, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelines(orgId: string, appId: string, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelines(orgId, appId, perPage, page, trigger, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {string} orgId The Organization ID
         * @param {Array<string>} [app] An optional list of Application IDs.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [trigger] An optional filter by trigger type.
         * @param {{ [key: string]: string; }} [metadata] Optional filter by pipeline metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPipelinesInOrg(orgId: string, app?: Array<string>, perPage?: number, page?: string, trigger?: string, metadata?: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pipeline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPipelinesInOrg(orgId, app, perPage, page, trigger, metadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} [fingerprint] The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublicKeys(orgId: string, fingerprint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicKeys(orgId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceAccountTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAccountTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceAccounts(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAccounts(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {string} [_class] (Optional) Filter Resource Definitions that may match a specific Class.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceDefinitions(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, _class?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceDefinitions(orgId, app, env, envType, res, resType, _class, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceDrivers(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceDrivers(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {Array<string>} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuntime(orgId: string, appId: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuntime(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInApp(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInApp(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInEnvType(orgId: string, envType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInEnvType(orgId, envType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInOrg(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInOrg(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserTokens(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserTokens(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [id] Filter Chart Versions by Chart Version ID.
         * @param {string} [version] Filter Chart Versions by Chart Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileChartVersions(orgId: string, perPage?: number, page?: string, id?: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileChartVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileChartVersions(orgId, perPage, page, id, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileFeatures(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileFeatureResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileFeatures(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileVersions(orgId: string, profileQid: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileVersions(orgId, profileQid, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID
         * @param {boolean} [deprecated] Whether to include deprecated profiles
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfiles(orgId: string, deprecated?: boolean, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfiles(orgId, deprecated, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainDeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, diff?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, diff, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecretStoreResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateSecretStorePayloadRequest} createSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresPost(orgId: string, createSecretStorePayloadRequest: CreateSecretStorePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresPost(orgId, createSecretStorePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdDelete(orgId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdDelete(orgId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdGet(orgId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdGet(orgId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {UpdateSecretStorePayloadRequest} updateSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdPatch(orgId: string, storeId: string, updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdPatch(orgId, storeId, updateSecretStorePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {string} orgId The Organization ID
         * @param {string} agentId The Agent id.
         * @param {AgentPatchBody} agentPatchBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAgent(orgId: string, agentId: string, agentPatchBody: AgentPatchBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAgent(orgId, agentId, agentPatchBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.
         * @param {string} artefactId The Artefact ID.
         * @param {string} versionId The Version ID.
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchArtefactVersion(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchArtefactVersion(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchReplicas(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchReplicas(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchResourceAccount(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchResourceAccount(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchResourceDefinition(orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchResourceDefinition(orgId, defId, patchResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDelta(orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDelta(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryResourceGraph(orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeBodyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryResourceGraph(orgId, appId, envId, resourceProvisionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebaseEnvironment(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebaseEnvironment(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {string} runId The Run ID
         * @param {string} [idempotencyKey] The HTTP Idempotency-Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartPipelineRun(orgId: string, appId: string, pipelineId: string, runId: string, idempotencyKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartPipelineRun(orgId, appId, pipelineId, runId, idempotencyKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {EnvironmentBaseUpdateRequest} [environmentBaseUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironment(orgId: string, appId: string, envId: string, environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(orgId, appId, envId, environmentBaseUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {UpdateEnvironmentTypePayloadRequest} updateEnvironmentTypePayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnvironmentType(orgId: string, envTypeId: string, updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironmentType(orgId, envTypeId, updateEnvironmentTypePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaused(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaused(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} pipelineId The Pipeline ID
         * @param {object} body 
         * @param {string} [ifMatch] Indicate that the request should only succeed if there is an etag match
         * @param {boolean} [dryRun] Optionally validate the request but do not persist the update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePipeline(orgId: string, appId: string, pipelineId: string, body: object, ifMatch?: string, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pipeline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePipeline(orgId, appId, pipelineId, body, ifMatch, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDefinition(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDefinition(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchingCriteriaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDriver(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDriver(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInApp(orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInApp(orgId, appId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInEnvType(orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInEnvType(orgId, envType, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInOrg(orgId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInOrg(orgId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {WorkloadProfileUpdateRequest} workloadProfileUpdateRequest Workload profile details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkloadProfile(orgId: string, profileQid: string, workloadProfileUpdateRequest: WorkloadProfileUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkloadProfile(orgId, profileQid, workloadProfileUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * Approve the approval requested.
         * @summary Approve the approval request
         * @param {PublicApiApprovePipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approvePipelineApprovalRequest(requestParameters: PublicApiApprovePipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.approvePipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
         * @summary Cancel a Run within an Pipeline.
         * @param {PublicApiCancelPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPipelineRun(requestParameters: PublicApiCancelPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Agent under an Organization.
         * @param {PublicApiCreateAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(requestParameters: PublicApiCreateAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Agent> {
            return localVarFp.createAgent(requestParameters.orgId, requestParameters.agentCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {PublicApiCreateApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(requestParameters: PublicApiCreateApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.createApplication(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {PublicApiCreateArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtefactVersion(requestParameters: PublicApiCreateArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.createArtefactVersion(requestParameters.orgId, requestParameters.createArtefactVersion, requestParameters.vcs, requestParameters.dryRun, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {PublicApiCreateDeploymentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(requestParameters: PublicApiCreateDeploymentRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.createDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {PublicApiCreateDeprecatedImageBuildRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeprecatedImageBuild(requestParameters: PublicApiCreateDeprecatedImageBuildRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createDeprecatedImageBuild(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {PublicApiCreateEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironment(requestParameters: PublicApiCreateEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.createEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {PublicApiCreateEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnvironmentType(requestParameters: PublicApiCreateEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.createEnvironmentType(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {PublicApiCreateInviteInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteInOrg(requestParameters: PublicApiCreateInviteInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.createInviteInOrg(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Key under an Agent in an Organization.
         * @param {PublicApiCreateKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(requestParameters: PublicApiCreateKeyRequest, options?: AxiosRequestConfig): AxiosPromise<Key> {
            return localVarFp.createKey(requestParameters.orgId, requestParameters.agentId, requestParameters.keyCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Pipeline within an Application.
         * @param {PublicApiCreatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipeline(requestParameters: PublicApiCreatePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.createPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.body, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
         * @summary Create a new trigger matching criteria for this Pipeline.
         * @param {PublicApiCreatePipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineCriteria(requestParameters: PublicApiCreatePipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineCriteria> {
            return localVarFp.createPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineCriteriaCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a run within a pipeline.
         * @param {PublicApiCreatePipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRun(requestParameters: PublicApiCreatePipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.createPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineRunCreateBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
         * @param {PublicApiCreatePipelineRunByTriggerCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPipelineRunByTriggerCriteria(requestParameters: PublicApiCreatePipelineRunByTriggerCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.createPipelineRunByTriggerCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineRunCreateByTriggerCriteriaBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {PublicApiCreatePublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(requestParameters: PublicApiCreatePublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.createPublicKey(requestParameters.orgId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {PublicApiCreateResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceAccount(requestParameters: PublicApiCreateResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.createResourceAccount(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {PublicApiCreateResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinition(requestParameters: PublicApiCreateResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.createResourceDefinition(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {PublicApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria(requestParameters: PublicApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {PublicApiCreateResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDriver(requestParameters: PublicApiCreateResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.createResourceDriver(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {PublicApiCreateServiceUserInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceUserInOrg(requestParameters: PublicApiCreateServiceUserInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.createServiceUserInOrg(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {PublicApiCreateUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInApp(requestParameters: PublicApiCreateUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.createUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {PublicApiCreateUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInEnvType(requestParameters: PublicApiCreateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.createUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {PublicApiCreateUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserToken(requestParameters: PublicApiCreateUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.createUserToken(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {PublicApiCreateWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfile(requestParameters: PublicApiCreateWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.createWorkloadProfile(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {PublicApiCreateWorkloadProfileChartVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfileChartVersion(requestParameters: PublicApiCreateWorkloadProfileChartVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileChartVersionResponse> {
            return localVarFp.createWorkloadProfileChartVersion(requestParameters.orgId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {PublicApiDeleteActiveResourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActiveResource(requestParameters: PublicApiDeleteActiveResourceRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteActiveResource(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, requestParameters.detach, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an Agent (and its keys) stored under an Organization.
         * @param {PublicApiDeleteAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(requestParameters: PublicApiDeleteAgentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {PublicApiDeleteApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(requestParameters: PublicApiDeleteApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {PublicApiDeleteArtefactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtefact(requestParameters: PublicApiDeleteArtefactRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteArtefact(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {PublicApiDeleteEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(requestParameters: PublicApiDeleteEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {PublicApiDeleteEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironmentType(requestParameters: PublicApiDeleteEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.deleteEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key registered under a Agent.
         * @param {PublicApiDeleteKeyInAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKeyInAgent(requestParameters: PublicApiDeleteKeyInAgentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteKeyInAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a pipeline within an application.
         * @param {PublicApiDeletePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipeline(requestParameters: PublicApiDeletePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the Pipeline Criteria with the given id.
         * @param {PublicApiDeletePipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineCriteria(requestParameters: PublicApiDeletePipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deleting a completed Run within a Pipeline.
         * @param {PublicApiDeletePipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePipelineRun(requestParameters: PublicApiDeletePipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {PublicApiDeletePublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(requestParameters: PublicApiDeletePublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {PublicApiDeleteResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceAccount(requestParameters: PublicApiDeleteResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {PublicApiDeleteResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinition(requestParameters: PublicApiDeleteResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {PublicApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria(requestParameters: PublicApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {PublicApiDeleteResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDriver(requestParameters: PublicApiDeleteResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {PublicApiDeleteUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInApp(requestParameters: PublicApiDeleteUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {PublicApiDeleteUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInEnvType(requestParameters: PublicApiDeleteUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {PublicApiDeleteUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInOrg(requestParameters: PublicApiDeleteUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {PublicApiDeleteUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserToken(requestParameters: PublicApiDeleteUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {PublicApiDeleteWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkloadProfile(requestParameters: PublicApiDeleteWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deny the approval requested.
         * @summary Deny the approval request
         * @param {PublicApiDenyPipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyPipelineApprovalRequest(requestParameters: PublicApiDenyPipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.denyPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {PublicApiGetApplicationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplication(requestParameters: PublicApiGetApplicationRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.getApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {PublicApiGetArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtefactVersion(requestParameters: PublicApiGetArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.getArtefactVersion(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Read the current state of a trigger batch for a Pipeline if one exists
         * @summary Read the current state of a trigger batch
         * @param {PublicApiGetBatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatch(requestParameters: PublicApiGetBatchRequest, options?: AxiosRequestConfig): AxiosPromise<Batch> {
            return localVarFp.getBatch(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.batchType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {PublicApiGetDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta(requestParameters: PublicApiGetDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {PublicApiGetDeploymentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(requestParameters: PublicApiGetDeploymentRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.getDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {PublicApiGetDeprecatedImageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeprecatedImage(requestParameters: PublicApiGetDeprecatedImageRequest, options?: AxiosRequestConfig): AxiosPromise<ImageResponse> {
            return localVarFp.getDeprecatedImage(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {PublicApiGetEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(requestParameters: PublicApiGetEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.getEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {PublicApiGetEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentType(requestParameters: PublicApiGetEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.getEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the latest pipeline schema
         * @param {PublicApiGetLatestPipelineDefinitionSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestPipelineDefinitionSchema(requestParameters: PublicApiGetLatestPipelineDefinitionSchemaRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getLatestPipelineDefinitionSchema(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {PublicApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion(requestParameters: PublicApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {PublicApiGetOrganizationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(requestParameters: PublicApiGetOrganizationRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationResponse> {
            return localVarFp.getOrganization(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Pipeline within an Application.
         * @param {PublicApiGetPipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipeline(requestParameters: PublicApiGetPipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.getPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an approval request.
         * @summary Get an approval request
         * @param {PublicApiGetPipelineApprovalRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineApprovalRequest(requestParameters: PublicApiGetPipelineApprovalRequestRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineApprovalRequest> {
            return localVarFp.getPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Pipeline Criteria with the given id.
         * @param {PublicApiGetPipelineCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineCriteria(requestParameters: PublicApiGetPipelineCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineCriteria> {
            return localVarFp.getPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pipeline schema.
         * @param {PublicApiGetPipelineDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineDefinition(requestParameters: PublicApiGetPipelineDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPipelineDefinition(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the details of a Job including Step information
         * @param {PublicApiGetPipelineJobRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineJob(requestParameters: PublicApiGetPipelineJobRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineJob> {
            return localVarFp.getPipelineJob(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a run within an pipeline.
         * @param {PublicApiGetPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPipelineRun(requestParameters: PublicApiGetPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.getPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {PublicApiGetPublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(requestParameters: PublicApiGetPublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.getPublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {PublicApiGetResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceAccount(requestParameters: PublicApiGetResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.getResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {PublicApiGetResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDefinition(requestParameters: PublicApiGetResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.getResourceDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {PublicApiGetResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDriver(requestParameters: PublicApiGetResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.getResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {PublicApiGetRuntimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntime(requestParameters: PublicApiGetRuntimeRequest, options?: AxiosRequestConfig): AxiosPromise<RuntimeInfoResponseV1> {
            return localVarFp.getRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {PublicApiGetSetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets(requestParameters: PublicApiGetSetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SetResponse>> {
            return localVarFp.getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {PublicApiGetUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInApp(requestParameters: PublicApiGetUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {PublicApiGetUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInEnvType(requestParameters: PublicApiGetUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {PublicApiGetUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInOrg(requestParameters: PublicApiGetUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {PublicApiGetUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken(requestParameters: PublicApiGetUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenInfoResponse> {
            return localVarFp.getUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
         * @param {PublicApiGetWorkloadArtefactVersionDeploymentSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionDeploymentSet(requestParameters: PublicApiGetWorkloadArtefactVersionDeploymentSetRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadArtefactVersionDeploymentSet> {
            return localVarFp.getWorkloadArtefactVersionDeploymentSet(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
         * @summary Get the spec of this Workload Artefact Version
         * @param {PublicApiGetWorkloadArtefactVersionSpecRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadArtefactVersionSpec(requestParameters: PublicApiGetWorkloadArtefactVersionSpecRequest, options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getWorkloadArtefactVersionSpec(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {PublicApiGetWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadProfile(requestParameters: PublicApiGetWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.getWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {PublicApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition(requestParameters: PublicApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {PublicApiListActiveResourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResources(requestParameters: PublicApiListActiveResourcesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.listActiveResources(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the agents in an Organization.
         * @param {PublicApiListAgentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(requestParameters: PublicApiListAgentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Agent>> {
            return localVarFp.listAgents(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {PublicApiListApplicationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplications(requestParameters: PublicApiListApplicationsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.listApplications(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {PublicApiListArtefactVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersions(requestParameters: PublicApiListArtefactVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersion>> {
            return localVarFp.listArtefactVersions(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions in the org.
         * @param {PublicApiListArtefactVersionsInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefactVersionsInOrg(requestParameters: PublicApiListArtefactVersionsInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersion>> {
            return localVarFp.listArtefactVersionsInOrg(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {PublicApiListArtefactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtefacts(requestParameters: PublicApiListArtefactsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.listArtefacts(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
         * @summary List audit log entries by Organization
         * @param {PublicApiListAuditLogEntriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogEntries(requestParameters: PublicApiListAuditLogEntriesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AuditLogEntry>> {
            return localVarFp.listAuditLogEntries(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.from, requestParameters.to, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {PublicApiListDeploymentErrorsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeploymentErrors(requestParameters: PublicApiListDeploymentErrorsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.listDeploymentErrors(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {PublicApiListDeploymentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeployments(requestParameters: PublicApiListDeploymentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.listDeployments(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.pipelineRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {PublicApiListDeprecatedImageBuildsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImageBuilds(requestParameters: PublicApiListDeprecatedImageBuildsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.listDeprecatedImageBuilds(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {PublicApiListDeprecatedImagesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDeprecatedImages(requestParameters: PublicApiListDeprecatedImagesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.listDeprecatedImages(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {PublicApiListEnvironmentTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironmentTypes(requestParameters: PublicApiListEnvironmentTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.listEnvironmentTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {PublicApiListEnvironmentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEnvironments(requestParameters: PublicApiListEnvironmentsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.listEnvironments(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the public keys Humanitec shares with an organization.
         * @param {PublicApiListHumanitecPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHumanitecPublicKeys(requestParameters: PublicApiListHumanitecPublicKeysRequest, options?: AxiosRequestConfig): AxiosPromise<Array<HumanitecPublicKey>> {
            return localVarFp.listHumanitecPublicKeys(requestParameters.orgId, requestParameters.active, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {PublicApiListInvitesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesInOrg(requestParameters: PublicApiListInvitesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.listInvitesInOrg(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the keys registered under an Agent in an Organization.
         * @param {PublicApiListKeysInAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeysInAgent(requestParameters: PublicApiListKeysInAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Key>> {
            return localVarFp.listKeysInAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: AxiosRequestConfig): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * List of the approval requests with in an app. 
         * @summary List of the approval requests
         * @param {PublicApiListPipelineApprovalRequestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineApprovalRequests(requestParameters: PublicApiListPipelineApprovalRequestsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineApprovalRequest>> {
            return localVarFp.listPipelineApprovalRequests(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.pipeline, requestParameters.run, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
         * @summary List the trigger matching criteria defined for Pipelines in this Application.
         * @param {PublicApiListPipelineCriteriaInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineCriteriaInApp(requestParameters: PublicApiListPipelineCriteriaInAppRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineCriteria>> {
            return localVarFp.listPipelineCriteriaInApp(requestParameters.orgId, requestParameters.appId, requestParameters.pipeline, requestParameters.match, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the details of the jobs within a pipeline run.
         * @param {PublicApiListPipelineJobsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineJobs(requestParameters: PublicApiListPipelineJobsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineJobPartial>> {
            return localVarFp.listPipelineJobs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.status, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List runs within a pipeline.
         * @param {PublicApiListPipelineRunsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRuns(requestParameters: PublicApiListPipelineRunsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.listPipelineRuns(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
         * @param {PublicApiListPipelineRunsByOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineRunsByOrg(requestParameters: PublicApiListPipelineRunsByOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineRun>> {
            return localVarFp.listPipelineRunsByOrg(requestParameters.orgId, requestParameters.app, requestParameters.pipeline, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a page of log output for a given step within a job.
         * @param {PublicApiListPipelineStepLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineStepLogs(requestParameters: PublicApiListPipelineStepLogsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineStepLog>> {
            return localVarFp.listPipelineStepLogs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.stepIndex, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all versions of the pipeline
         * @param {PublicApiListPipelineVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelineVersions(requestParameters: PublicApiListPipelineVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PipelineVersion>> {
            return localVarFp.listPipelineVersions(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Pipelines within an Application.
         * @param {PublicApiListPipelinesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelines(requestParameters: PublicApiListPipelinesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.listPipelines(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Pipelines within an Organization. This can be filtered by Application.
         * @param {PublicApiListPipelinesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPipelinesInOrg(requestParameters: PublicApiListPipelinesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Pipeline>> {
            return localVarFp.listPipelinesInOrg(requestParameters.orgId, requestParameters.app, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {PublicApiListPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys(requestParameters: PublicApiListPublicKeysRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>> {
            return localVarFp.listPublicKeys(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {PublicApiListResourceAccountTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccountTypes(requestParameters: PublicApiListResourceAccountTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.listResourceAccountTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {PublicApiListResourceAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccounts(requestParameters: PublicApiListResourceAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.listResourceAccounts(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {PublicApiListResourceDefinitionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDefinitions(requestParameters: PublicApiListResourceDefinitionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.listResourceDefinitions(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, requestParameters._class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {PublicApiListResourceDriversRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDrivers(requestParameters: PublicApiListResourceDriversRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.listResourceDrivers(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {PublicApiListResourceTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceTypes(requestParameters: PublicApiListResourceTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.listResourceTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {PublicApiListRuntimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuntime(requestParameters: PublicApiListRuntimeRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.listRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {PublicApiListUserRolesInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInApp(requestParameters: PublicApiListUserRolesInAppRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInApp(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {PublicApiListUserRolesInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInEnvType(requestParameters: PublicApiListUserRolesInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInEnvType(requestParameters.orgId, requestParameters.envType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {PublicApiListUserRolesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInOrg(requestParameters: PublicApiListUserRolesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInOrg(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {PublicApiListUserTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTokens(requestParameters: PublicApiListUserTokensRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TokenInfoResponse>> {
            return localVarFp.listUserTokens(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {PublicApiListWorkloadProfileChartVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileChartVersions(requestParameters: PublicApiListWorkloadProfileChartVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileChartVersionResponse>> {
            return localVarFp.listWorkloadProfileChartVersions(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.id, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {PublicApiListWorkloadProfileFeaturesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileFeatures(requestParameters: PublicApiListWorkloadProfileFeaturesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileFeatureResponse>> {
            return localVarFp.listWorkloadProfileFeatures(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {PublicApiListWorkloadProfileVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileVersions(requestParameters: PublicApiListWorkloadProfileVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.listWorkloadProfileVersions(requestParameters.orgId, requestParameters.profileQid, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {PublicApiListWorkloadProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfiles(requestParameters: PublicApiListWorkloadProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.listWorkloadProfiles(requestParameters.orgId, requestParameters.deprecated, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlainDeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookUpdateResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {PublicApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(requestParameters: PublicApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {PublicApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(requestParameters: PublicApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {PublicApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(requestParameters: PublicApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {PublicApiOrgsOrgIdSecretstoresGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresGet(requestParameters: PublicApiOrgsOrgIdSecretstoresGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SecretStoreResponse>> {
            return localVarFp.orgsOrgIdSecretstoresGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {PublicApiOrgsOrgIdSecretstoresPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresPost(requestParameters: PublicApiOrgsOrgIdSecretstoresPostRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresPost(requestParameters.orgId, requestParameters.createSecretStorePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdDelete(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdDelete(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdGet(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdGet(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdPatch(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdPatch(requestParameters.orgId, requestParameters.storeId, requestParameters.updateSecretStorePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the description of an Agent.
         * @param {PublicApiPatchAgentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(requestParameters: PublicApiPatchAgentRequest, options?: AxiosRequestConfig): AxiosPromise<Agent> {
            return localVarFp.patchAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.agentPatchBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {PublicApiPatchArtefactVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchArtefactVersion(requestParameters: PublicApiPatchArtefactVersionRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersion> {
            return localVarFp.patchArtefactVersion(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {PublicApiPatchReplicasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReplicas(requestParameters: PublicApiPatchReplicasRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchReplicas(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {PublicApiPatchResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceAccount(requestParameters: PublicApiPatchResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.patchResourceAccount(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {PublicApiPatchResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceDefinition(requestParameters: PublicApiPatchResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.patchResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {PublicApiPutDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta(requestParameters: PublicApiPutDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {PublicApiQueryResourceGraphRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResourceGraph(requestParameters: PublicApiQueryResourceGraphRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeBodyResponse>> {
            return localVarFp.queryResourceGraph(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {PublicApiRebaseEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebaseEnvironment(requestParameters: PublicApiRebaseEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rebaseEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to copy and restart the specified Run. The run must be in a completed state. 
         * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
         * @param {PublicApiRestartPipelineRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartPipelineRun(requestParameters: PublicApiRestartPipelineRunRequest, options?: AxiosRequestConfig): AxiosPromise<PipelineRun> {
            return localVarFp.restartPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.idempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {PublicApiUpdateCurrentUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(requestParameters: PublicApiUpdateCurrentUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.updateCurrentUser(requestParameters.userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific Environment in an Application.
         * @summary Update a specific Environment.
         * @param {PublicApiUpdateEnvironmentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironment(requestParameters: PublicApiUpdateEnvironmentRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.updateEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.environmentBaseUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates Environment Type.
         * @summary Updates Environment Type
         * @param {PublicApiUpdateEnvironmentTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnvironmentType(requestParameters: PublicApiUpdateEnvironmentTypeRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.updateEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, requestParameters.updateEnvironmentTypePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {PublicApiUpdatePausedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaused(requestParameters: PublicApiUpdatePausedRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePaused(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update a Pipeline within an Application.
         * @param {PublicApiUpdatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePipeline(requestParameters: PublicApiUpdatePipelineRequest, options?: AxiosRequestConfig): AxiosPromise<Pipeline> {
            return localVarFp.updatePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.body, requestParameters.ifMatch, requestParameters.dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {PublicApiUpdateResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinition(requestParameters: PublicApiUpdateResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.updateResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {PublicApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria(requestParameters: PublicApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<Array<MatchingCriteriaResponse>> {
            return localVarFp.updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {PublicApiUpdateResourceDriverRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDriver(requestParameters: PublicApiUpdateResourceDriverRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.updateResourceDriver(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {PublicApiUpdateUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInApp(requestParameters: PublicApiUpdateUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {PublicApiUpdateUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInEnvType(requestParameters: PublicApiUpdateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {PublicApiUpdateUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInOrg(requestParameters: PublicApiUpdateUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInOrg(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {PublicApiUpdateWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkloadProfile(requestParameters: PublicApiUpdateWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.updateWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, requestParameters.workloadProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for approvePipelineApprovalRequest operation in PublicApi.
 * @export
 * @interface PublicApiApprovePipelineApprovalRequestRequest
 */
export interface PublicApiApprovePipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PublicApiApprovePipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for cancelPipelineRun operation in PublicApi.
 * @export
 * @interface PublicApiCancelPipelineRunRequest
 */
export interface PublicApiCancelPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCancelPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiCancelPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiCancelPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiCancelPipelineRun
     */
    readonly runId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PublicApiCancelPipelineRun
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for createAgent operation in PublicApi.
 * @export
 * @interface PublicApiCreateAgentRequest
 */
export interface PublicApiCreateAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateAgent
     */
    readonly orgId: string

    /**
     * 
     * @type {AgentCreateBody}
     * @memberof PublicApiCreateAgent
     */
    readonly agentCreateBody: AgentCreateBody
}

/**
 * Request parameters for createApplication operation in PublicApi.
 * @export
 * @interface PublicApiCreateApplicationRequest
 */
export interface PublicApiCreateApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateApplication
     */
    readonly orgId: string

    /**
     * The request ID, Human-friendly name and environment of the Application.  
     * @type {ApplicationCreationRequest}
     * @memberof PublicApiCreateApplication
     */
    readonly applicationCreationRequest: ApplicationCreationRequest
}

/**
 * Request parameters for createArtefactVersion operation in PublicApi.
 * @export
 * @interface PublicApiCreateArtefactVersionRequest
 */
export interface PublicApiCreateArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiCreateArtefactVersion
     */
    readonly orgId: string

    /**
     * The data needed to register a new Artefact Version within the organization.
     * @type {CreateArtefactVersion}
     * @memberof PublicApiCreateArtefactVersion
     */
    readonly createArtefactVersion: CreateArtefactVersion

    /**
     * (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.
     * @type {string}
     * @memberof PublicApiCreateArtefactVersion
     */
    readonly vcs?: string

    /**
     * Optionally validate the request but do not persist the actual artefact. If the Accept type is set to \&quot;application/x.workload-deployment-set+json\&quot; or \&quot;application/x.workload-deployment-set+x-yaml\&quot;, the generated deployment set will be returned.
     * @type {boolean}
     * @memberof PublicApiCreateArtefactVersion
     */
    readonly dryRun?: boolean

    /**
     * Indicates which content types the client is able to understand.
     * @type {string}
     * @memberof PublicApiCreateArtefactVersion
     */
    readonly accept?: string
}

/**
 * Request parameters for createDeployment operation in PublicApi.
 * @export
 * @interface PublicApiCreateDeploymentRequest
 */
export interface PublicApiCreateDeploymentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateDeployment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiCreateDeployment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiCreateDeployment
     */
    readonly envId: string

    /**
     * The Delta describing the change to the Environment and a comment.  
     * @type {DeploymentRequest}
     * @memberof PublicApiCreateDeployment
     */
    readonly deploymentRequest: DeploymentRequest
}

/**
 * Request parameters for createDeprecatedImageBuild operation in PublicApi.
 * @export
 * @interface PublicApiCreateDeprecatedImageBuildRequest
 */
export interface PublicApiCreateDeprecatedImageBuildRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiCreateDeprecatedImageBuild
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof PublicApiCreateDeprecatedImageBuild
     */
    readonly imageId: string

    /**
     * The metadata associated with the build.
     * @type {ImageBuildRequest}
     * @memberof PublicApiCreateDeprecatedImageBuild
     */
    readonly imageBuildRequest: ImageBuildRequest
}

/**
 * Request parameters for createEnvironment operation in PublicApi.
 * @export
 * @interface PublicApiCreateEnvironmentRequest
 */
export interface PublicApiCreateEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiCreateEnvironment
     */
    readonly appId: string

    /**
     * The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @type {EnvironmentDefinitionRequest}
     * @memberof PublicApiCreateEnvironment
     */
    readonly environmentDefinitionRequest: EnvironmentDefinitionRequest
}

/**
 * Request parameters for createEnvironmentType operation in PublicApi.
 * @export
 * @interface PublicApiCreateEnvironmentTypeRequest
 */
export interface PublicApiCreateEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateEnvironmentType
     */
    readonly orgId: string

    /**
     * New Environment Type.  
     * @type {EnvironmentTypeRequest}
     * @memberof PublicApiCreateEnvironmentType
     */
    readonly environmentTypeRequest: EnvironmentTypeRequest
}

/**
 * Request parameters for createInviteInOrg operation in PublicApi.
 * @export
 * @interface PublicApiCreateInviteInOrgRequest
 */
export interface PublicApiCreateInviteInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateInviteInOrg
     */
    readonly orgId: string

    /**
     * The email and the desired role  
     * @type {UserInviteRequestRequest}
     * @memberof PublicApiCreateInviteInOrg
     */
    readonly userInviteRequestRequest: UserInviteRequestRequest
}

/**
 * Request parameters for createKey operation in PublicApi.
 * @export
 * @interface PublicApiCreateKeyRequest
 */
export interface PublicApiCreateKeyRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateKey
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof PublicApiCreateKey
     */
    readonly agentId: string

    /**
     * 
     * @type {KeyCreateBody}
     * @memberof PublicApiCreateKey
     */
    readonly keyCreateBody: KeyCreateBody
}

/**
 * Request parameters for createPipeline operation in PublicApi.
 * @export
 * @interface PublicApiCreatePipelineRequest
 */
export interface PublicApiCreatePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreatePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiCreatePipeline
     */
    readonly appId: string

    /**
     * 
     * @type {object}
     * @memberof PublicApiCreatePipeline
     */
    readonly body: object

    /**
     * Optionally validate the request but do not persist the actual Pipeline.
     * @type {boolean}
     * @memberof PublicApiCreatePipeline
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for createPipelineCriteria operation in PublicApi.
 * @export
 * @interface PublicApiCreatePipelineCriteriaRequest
 */
export interface PublicApiCreatePipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreatePipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiCreatePipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiCreatePipelineCriteria
     */
    readonly pipelineId: string

    /**
     * 
     * @type {PipelineCriteriaCreateBody}
     * @memberof PublicApiCreatePipelineCriteria
     */
    readonly pipelineCriteriaCreateBody: PipelineCriteriaCreateBody
}

/**
 * Request parameters for createPipelineRun operation in PublicApi.
 * @export
 * @interface PublicApiCreatePipelineRunRequest
 */
export interface PublicApiCreatePipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly pipelineId: string

    /**
     * 
     * @type {PipelineRunCreateBody}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly pipelineRunCreateBody: PipelineRunCreateBody

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly idempotencyKey?: string

    /**
     * Optionally validate the request but do not persist the actual Pipeline Run.
     * @type {boolean}
     * @memberof PublicApiCreatePipelineRun
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for createPipelineRunByTriggerCriteria operation in PublicApi.
 * @export
 * @interface PublicApiCreatePipelineRunByTriggerCriteriaRequest
 */
export interface PublicApiCreatePipelineRunByTriggerCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreatePipelineRunByTriggerCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiCreatePipelineRunByTriggerCriteria
     */
    readonly appId: string

    /**
     * 
     * @type {PipelineRunCreateByTriggerCriteriaBody}
     * @memberof PublicApiCreatePipelineRunByTriggerCriteria
     */
    readonly pipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PublicApiCreatePipelineRunByTriggerCriteria
     */
    readonly idempotencyKey?: string

    /**
     * Optionally validate the request but do not persist the actual Pipeline Run.
     * @type {boolean}
     * @memberof PublicApiCreatePipelineRunByTriggerCriteria
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for createPublicKey operation in PublicApi.
 * @export
 * @interface PublicApiCreatePublicKeyRequest
 */
export interface PublicApiCreatePublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiCreatePublicKey
     */
    readonly orgId: string

    /**
     * A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
     * @type {string}
     * @memberof PublicApiCreatePublicKey
     */
    readonly body: string
}

/**
 * Request parameters for createResourceAccount operation in PublicApi.
 * @export
 * @interface PublicApiCreateResourceAccountRequest
 */
export interface PublicApiCreateResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateResourceAccount
     */
    readonly orgId: string

    /**
     * 
     * @type {CreateResourceAccountRequestRequest}
     * @memberof PublicApiCreateResourceAccount
     */
    readonly createResourceAccountRequestRequest: CreateResourceAccountRequestRequest
}

/**
 * Request parameters for createResourceDefinition operation in PublicApi.
 * @export
 * @interface PublicApiCreateResourceDefinitionRequest
 */
export interface PublicApiCreateResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition details.  
     * @type {CreateResourceDefinitionRequestRequest}
     * @memberof PublicApiCreateResourceDefinition
     */
    readonly createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest
}

/**
 * Request parameters for createResourceDefinitionCriteria operation in PublicApi.
 * @export
 * @interface PublicApiCreateResourceDefinitionCriteriaRequest
 */
export interface PublicApiCreateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiCreateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof PublicApiCreateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * Request parameters for createResourceDriver operation in PublicApi.
 * @export
 * @interface PublicApiCreateResourceDriverRequest
 */
export interface PublicApiCreateResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiCreateResourceDriver
     */
    readonly orgId: string

    /**
     * Resources Driver details.  
     * @type {CreateDriverRequestRequest}
     * @memberof PublicApiCreateResourceDriver
     */
    readonly createDriverRequestRequest: CreateDriverRequestRequest
}

/**
 * Request parameters for createServiceUserInOrg operation in PublicApi.
 * @export
 * @interface PublicApiCreateServiceUserInOrgRequest
 */
export interface PublicApiCreateServiceUserInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateServiceUserInOrg
     */
    readonly orgId: string

    /**
     * 
     * @type {NewServiceUserRequest}
     * @memberof PublicApiCreateServiceUserInOrg
     */
    readonly newServiceUserRequest: NewServiceUserRequest
}

/**
 * Request parameters for createUserRoleInApp operation in PublicApi.
 * @export
 * @interface PublicApiCreateUserRoleInAppRequest
 */
export interface PublicApiCreateUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiCreateUserRoleInApp
     */
    readonly appId: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof PublicApiCreateUserRoleInApp
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for createUserRoleInEnvType operation in PublicApi.
 * @export
 * @interface PublicApiCreateUserRoleInEnvTypeRequest
 */
export interface PublicApiCreateUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiCreateUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof PublicApiCreateUserRoleInEnvType
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for createUserToken operation in PublicApi.
 * @export
 * @interface PublicApiCreateUserTokenRequest
 */
export interface PublicApiCreateUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiCreateUserToken
     */
    readonly userId: string

    /**
     * The definition of the token.  
     * @type {TokenDefinitionRequest}
     * @memberof PublicApiCreateUserToken
     */
    readonly tokenDefinitionRequest: TokenDefinitionRequest
}

/**
 * Request parameters for createWorkloadProfile operation in PublicApi.
 * @export
 * @interface PublicApiCreateWorkloadProfileRequest
 */
export interface PublicApiCreateWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateWorkloadProfile
     */
    readonly orgId: string

    /**
     * Workload profile details.  
     * @type {WorkloadProfileRequest}
     * @memberof PublicApiCreateWorkloadProfile
     */
    readonly workloadProfileRequest: WorkloadProfileRequest
}

/**
 * Request parameters for createWorkloadProfileChartVersion operation in PublicApi.
 * @export
 * @interface PublicApiCreateWorkloadProfileChartVersionRequest
 */
export interface PublicApiCreateWorkloadProfileChartVersionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiCreateWorkloadProfileChartVersion
     */
    readonly orgId: string

    /**
     * 
     * @type {File}
     * @memberof PublicApiCreateWorkloadProfileChartVersion
     */
    readonly file?: File
}

/**
 * Request parameters for deleteActiveResource operation in PublicApi.
 * @export
 * @interface PublicApiDeleteActiveResourceRequest
 */
export interface PublicApiDeleteActiveResourceRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly envId: string

    /**
     * The Resource Type, may include a resource class: {type}.{class}.  
     * @type {string}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly type: string

    /**
     * The Resource ID.  
     * @type {string}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly resId: string

    /**
     * If set to &#x60;true&#x60;, will detach an active resource. The resource continues to exist and is not deleted, but it is no longer connected to the Platform Orchestrator.  Detaching can be done for any active resource. In case that the resource is an active one (i.e. not marked to be deleted), it would stay in use until the next deployment. Detaching active resources can cause inconsistent status (e.g. detaching a k8s-cluster might make it impossible to retrieve runtime information by or un-pause an environment) If the resource has been provisioned via the Humanitec Operator, this does not delete the resource CR in the cluster. This must be done manually. 
     * @type {boolean}
     * @memberof PublicApiDeleteActiveResource
     */
    readonly detach?: boolean
}

/**
 * Request parameters for deleteAgent operation in PublicApi.
 * @export
 * @interface PublicApiDeleteAgentRequest
 */
export interface PublicApiDeleteAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof PublicApiDeleteAgent
     */
    readonly agentId: string
}

/**
 * Request parameters for deleteApplication operation in PublicApi.
 * @export
 * @interface PublicApiDeleteApplicationRequest
 */
export interface PublicApiDeleteApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteApplication
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiDeleteApplication
     */
    readonly appId: string
}

/**
 * Request parameters for deleteArtefact operation in PublicApi.
 * @export
 * @interface PublicApiDeleteArtefactRequest
 */
export interface PublicApiDeleteArtefactRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiDeleteArtefact
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof PublicApiDeleteArtefact
     */
    readonly artefactId: string
}

/**
 * Request parameters for deleteEnvironment operation in PublicApi.
 * @export
 * @interface PublicApiDeleteEnvironmentRequest
 */
export interface PublicApiDeleteEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiDeleteEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiDeleteEnvironment
     */
    readonly envId: string
}

/**
 * Request parameters for deleteEnvironmentType operation in PublicApi.
 * @export
 * @interface PublicApiDeleteEnvironmentTypeRequest
 */
export interface PublicApiDeleteEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof PublicApiDeleteEnvironmentType
     */
    readonly envTypeId: string
}

/**
 * Request parameters for deleteKeyInAgent operation in PublicApi.
 * @export
 * @interface PublicApiDeleteKeyInAgentRequest
 */
export interface PublicApiDeleteKeyInAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteKeyInAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof PublicApiDeleteKeyInAgent
     */
    readonly agentId: string

    /**
     * The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
     * @type {string}
     * @memberof PublicApiDeleteKeyInAgent
     */
    readonly fingerprint: string
}

/**
 * Request parameters for deletePipeline operation in PublicApi.
 * @export
 * @interface PublicApiDeletePipelineRequest
 */
export interface PublicApiDeletePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeletePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiDeletePipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiDeletePipeline
     */
    readonly pipelineId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PublicApiDeletePipeline
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for deletePipelineCriteria operation in PublicApi.
 * @export
 * @interface PublicApiDeletePipelineCriteriaRequest
 */
export interface PublicApiDeletePipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeletePipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiDeletePipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiDeletePipelineCriteria
     */
    readonly pipelineId: string

    /**
     * The Criteria ID
     * @type {string}
     * @memberof PublicApiDeletePipelineCriteria
     */
    readonly criteriaId: string
}

/**
 * Request parameters for deletePipelineRun operation in PublicApi.
 * @export
 * @interface PublicApiDeletePipelineRunRequest
 */
export interface PublicApiDeletePipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeletePipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiDeletePipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiDeletePipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiDeletePipelineRun
     */
    readonly runId: string

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PublicApiDeletePipelineRun
     */
    readonly ifMatch?: string
}

/**
 * Request parameters for deletePublicKey operation in PublicApi.
 * @export
 * @interface PublicApiDeletePublicKeyRequest
 */
export interface PublicApiDeletePublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiDeletePublicKey
     */
    readonly orgId: string

    /**
     * The public key ID.
     * @type {string}
     * @memberof PublicApiDeletePublicKey
     */
    readonly keyId: string
}

/**
 * Request parameters for deleteResourceAccount operation in PublicApi.
 * @export
 * @interface PublicApiDeleteResourceAccountRequest
 */
export interface PublicApiDeleteResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceAccount
     */
    readonly accId: string
}

/**
 * Request parameters for deleteResourceDefinition operation in PublicApi.
 * @export
 * @interface PublicApiDeleteResourceDefinitionRequest
 */
export interface PublicApiDeleteResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDefinition
     */
    readonly defId: string

    /**
     * If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @type {boolean}
     * @memberof PublicApiDeleteResourceDefinition
     */
    readonly force?: boolean
}

/**
 * Request parameters for deleteResourceDefinitionCriteria operation in PublicApi.
 * @export
 * @interface PublicApiDeleteResourceDefinitionCriteriaRequest
 */
export interface PublicApiDeleteResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDefinitionCriteria
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof PublicApiDeleteResourceDefinitionCriteria
     */
    readonly force?: boolean
}

/**
 * Request parameters for deleteResourceDriver operation in PublicApi.
 * @export
 * @interface PublicApiDeleteResourceDriverRequest
 */
export interface PublicApiDeleteResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDriver
     */
    readonly orgId: string

    /**
     * The Resources Driver ID to delete.  
     * @type {string}
     * @memberof PublicApiDeleteResourceDriver
     */
    readonly driverId: string
}

/**
 * Request parameters for deleteUserRoleInApp operation in PublicApi.
 * @export
 * @interface PublicApiDeleteUserRoleInAppRequest
 */
export interface PublicApiDeleteUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInApp
     */
    readonly userId: string
}

/**
 * Request parameters for deleteUserRoleInEnvType operation in PublicApi.
 * @export
 * @interface PublicApiDeleteUserRoleInEnvTypeRequest
 */
export interface PublicApiDeleteUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInEnvType
     */
    readonly userId: string
}

/**
 * Request parameters for deleteUserRoleInOrg operation in PublicApi.
 * @export
 * @interface PublicApiDeleteUserRoleInOrgRequest
 */
export interface PublicApiDeleteUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiDeleteUserRoleInOrg
     */
    readonly userId: string
}

/**
 * Request parameters for deleteUserToken operation in PublicApi.
 * @export
 * @interface PublicApiDeleteUserTokenRequest
 */
export interface PublicApiDeleteUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiDeleteUserToken
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof PublicApiDeleteUserToken
     */
    readonly tokenId: string
}

/**
 * Request parameters for deleteWorkloadProfile operation in PublicApi.
 * @export
 * @interface PublicApiDeleteWorkloadProfileRequest
 */
export interface PublicApiDeleteWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDeleteWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof PublicApiDeleteWorkloadProfile
     */
    readonly profileQid: string
}

/**
 * Request parameters for denyPipelineApprovalRequest operation in PublicApi.
 * @export
 * @interface PublicApiDenyPipelineApprovalRequestRequest
 */
export interface PublicApiDenyPipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PublicApiDenyPipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for getApplication operation in PublicApi.
 * @export
 * @interface PublicApiGetApplicationRequest
 */
export interface PublicApiGetApplicationRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetApplication
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetApplication
     */
    readonly appId: string
}

/**
 * Request parameters for getArtefactVersion operation in PublicApi.
 * @export
 * @interface PublicApiGetArtefactVersionRequest
 */
export interface PublicApiGetArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiGetArtefactVersion
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof PublicApiGetArtefactVersion
     */
    readonly artefactVersionId: string
}

/**
 * Request parameters for getBatch operation in PublicApi.
 * @export
 * @interface PublicApiGetBatchRequest
 */
export interface PublicApiGetBatchRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetBatch
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetBatch
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetBatch
     */
    readonly pipelineId: string

    /**
     * The batch type, only artefact is implemented.
     * @type {string}
     * @memberof PublicApiGetBatch
     */
    readonly batchType: string
}

/**
 * Request parameters for getDelta operation in PublicApi.
 * @export
 * @interface PublicApiGetDeltaRequest
 */
export interface PublicApiGetDeltaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to fetch.  
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly deltaId: string
}

/**
 * Request parameters for getDeployment operation in PublicApi.
 * @export
 * @interface PublicApiGetDeploymentRequest
 */
export interface PublicApiGetDeploymentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetDeployment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetDeployment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiGetDeployment
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof PublicApiGetDeployment
     */
    readonly deployId: string
}

/**
 * Request parameters for getDeprecatedImage operation in PublicApi.
 * @export
 * @interface PublicApiGetDeprecatedImageRequest
 */
export interface PublicApiGetDeprecatedImageRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiGetDeprecatedImage
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof PublicApiGetDeprecatedImage
     */
    readonly imageId: string
}

/**
 * Request parameters for getEnvironment operation in PublicApi.
 * @export
 * @interface PublicApiGetEnvironmentRequest
 */
export interface PublicApiGetEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiGetEnvironment
     */
    readonly envId: string
}

/**
 * Request parameters for getEnvironmentType operation in PublicApi.
 * @export
 * @interface PublicApiGetEnvironmentTypeRequest
 */
export interface PublicApiGetEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof PublicApiGetEnvironmentType
     */
    readonly envTypeId: string
}

/**
 * Request parameters for getLatestPipelineDefinitionSchema operation in PublicApi.
 * @export
 * @interface PublicApiGetLatestPipelineDefinitionSchemaRequest
 */
export interface PublicApiGetLatestPipelineDefinitionSchemaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetLatestPipelineDefinitionSchema
     */
    readonly orgId: string
}

/**
 * Request parameters for getLatestWorkloadProfileVersion operation in PublicApi.
 * @export
 * @interface PublicApiGetLatestWorkloadProfileVersionRequest
 */
export interface PublicApiGetLatestWorkloadProfileVersionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetLatestWorkloadProfileVersion
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof PublicApiGetLatestWorkloadProfileVersion
     */
    readonly profileQid: string
}

/**
 * Request parameters for getOrganization operation in PublicApi.
 * @export
 * @interface PublicApiGetOrganizationRequest
 */
export interface PublicApiGetOrganizationRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetOrganization
     */
    readonly orgId: string
}

/**
 * Request parameters for getPipeline operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineRequest
 */
export interface PublicApiGetPipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipeline
     */
    readonly pipelineId: string

    /**
     * An optional Pipeline Version ID.
     * @type {string}
     * @memberof PublicApiGetPipeline
     */
    readonly version?: string
}

/**
 * Request parameters for getPipelineApprovalRequest operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineApprovalRequestRequest
 */
export interface PublicApiGetPipelineApprovalRequestRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly jobId: string

    /**
     * The Approval ID
     * @type {string}
     * @memberof PublicApiGetPipelineApprovalRequest
     */
    readonly approvalId: string
}

/**
 * Request parameters for getPipelineCriteria operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineCriteriaRequest
 */
export interface PublicApiGetPipelineCriteriaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipelineCriteria
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipelineCriteria
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipelineCriteria
     */
    readonly pipelineId: string

    /**
     * The Criteria ID
     * @type {string}
     * @memberof PublicApiGetPipelineCriteria
     */
    readonly criteriaId: string
}

/**
 * Request parameters for getPipelineDefinition operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineDefinitionRequest
 */
export interface PublicApiGetPipelineDefinitionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipelineDefinition
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipelineDefinition
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipelineDefinition
     */
    readonly pipelineId: string

    /**
     * An optional Pipeline Version ID.
     * @type {string}
     * @memberof PublicApiGetPipelineDefinition
     */
    readonly version?: string

    /**
     * 
     * @type {string}
     * @memberof PublicApiGetPipelineDefinition
     */
    readonly accept?: string
}

/**
 * Request parameters for getPipelineJob operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineJobRequest
 */
export interface PublicApiGetPipelineJobRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipelineJob
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipelineJob
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipelineJob
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiGetPipelineJob
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PublicApiGetPipelineJob
     */
    readonly jobId: string
}

/**
 * Request parameters for getPipelineRun operation in PublicApi.
 * @export
 * @interface PublicApiGetPipelineRunRequest
 */
export interface PublicApiGetPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiGetPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiGetPipelineRun
     */
    readonly runId: string
}

/**
 * Request parameters for getPublicKey operation in PublicApi.
 * @export
 * @interface PublicApiGetPublicKeyRequest
 */
export interface PublicApiGetPublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiGetPublicKey
     */
    readonly orgId: string

    /**
     * The public key ID.
     * @type {string}
     * @memberof PublicApiGetPublicKey
     */
    readonly keyId: string
}

/**
 * Request parameters for getResourceAccount operation in PublicApi.
 * @export
 * @interface PublicApiGetResourceAccountRequest
 */
export interface PublicApiGetResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiGetResourceAccount
     */
    readonly accId: string
}

/**
 * Request parameters for getResourceDefinition operation in PublicApi.
 * @export
 * @interface PublicApiGetResourceDefinitionRequest
 */
export interface PublicApiGetResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiGetResourceDefinition
     */
    readonly defId: string
}

/**
 * Request parameters for getResourceDriver operation in PublicApi.
 * @export
 * @interface PublicApiGetResourceDriverRequest
 */
export interface PublicApiGetResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetResourceDriver
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof PublicApiGetResourceDriver
     */
    readonly driverId: string
}

/**
 * Request parameters for getRuntime operation in PublicApi.
 * @export
 * @interface PublicApiGetRuntimeRequest
 */
export interface PublicApiGetRuntimeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetRuntime
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetRuntime
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof PublicApiGetRuntime
     */
    readonly envId: string
}

/**
 * Request parameters for getSets operation in PublicApi.
 * @export
 * @interface PublicApiGetSetsRequest
 */
export interface PublicApiGetSetsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetSets
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiGetSets
     */
    readonly appId: string
}

/**
 * Request parameters for getUserRoleInApp operation in PublicApi.
 * @export
 * @interface PublicApiGetUserRoleInAppRequest
 */
export interface PublicApiGetUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiGetUserRoleInApp
     */
    readonly userId: string
}

/**
 * Request parameters for getUserRoleInEnvType operation in PublicApi.
 * @export
 * @interface PublicApiGetUserRoleInEnvTypeRequest
 */
export interface PublicApiGetUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiGetUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiGetUserRoleInEnvType
     */
    readonly userId: string
}

/**
 * Request parameters for getUserRoleInOrg operation in PublicApi.
 * @export
 * @interface PublicApiGetUserRoleInOrgRequest
 */
export interface PublicApiGetUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiGetUserRoleInOrg
     */
    readonly userId: string
}

/**
 * Request parameters for getUserToken operation in PublicApi.
 * @export
 * @interface PublicApiGetUserTokenRequest
 */
export interface PublicApiGetUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiGetUserToken
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof PublicApiGetUserToken
     */
    readonly tokenId: string
}

/**
 * Request parameters for getWorkloadArtefactVersionDeploymentSet operation in PublicApi.
 * @export
 * @interface PublicApiGetWorkloadArtefactVersionDeploymentSetRequest
 */
export interface PublicApiGetWorkloadArtefactVersionDeploymentSetRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly artefactVersionId: string

    /**
     * The accepted content type.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionDeploymentSet
     */
    readonly accept?: string
}

/**
 * Request parameters for getWorkloadArtefactVersionSpec operation in PublicApi.
 * @export
 * @interface PublicApiGetWorkloadArtefactVersionSpecRequest
 */
export interface PublicApiGetWorkloadArtefactVersionSpecRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionSpec
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionSpec
     */
    readonly artefactVersionId: string

    /**
     * The accepted content type.
     * @type {string}
     * @memberof PublicApiGetWorkloadArtefactVersionSpec
     */
    readonly accept?: string
}

/**
 * Request parameters for getWorkloadProfile operation in PublicApi.
 * @export
 * @interface PublicApiGetWorkloadProfileRequest
 */
export interface PublicApiGetWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiGetWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof PublicApiGetWorkloadProfile
     */
    readonly profileQid: string
}

/**
 * Request parameters for listActiveResourceByDefinition operation in PublicApi.
 * @export
 * @interface PublicApiListActiveResourceByDefinitionRequest
 */
export interface PublicApiListActiveResourceByDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListActiveResourceByDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiListActiveResourceByDefinition
     */
    readonly defId: string
}

/**
 * Request parameters for listActiveResources operation in PublicApi.
 * @export
 * @interface PublicApiListActiveResourcesRequest
 */
export interface PublicApiListActiveResourcesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListActiveResources
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiListActiveResources
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiListActiveResources
     */
    readonly envId: string
}

/**
 * Request parameters for listAgents operation in PublicApi.
 * @export
 * @interface PublicApiListAgentsRequest
 */
export interface PublicApiListAgentsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListAgents
     */
    readonly orgId: string

    /**
     * The Key fingerprint (hexadecimal representation of sha256 hash of the DER representation of the key).
     * @type {string}
     * @memberof PublicApiListAgents
     */
    readonly fingerprint?: string
}

/**
 * Request parameters for listApplications operation in PublicApi.
 * @export
 * @interface PublicApiListApplicationsRequest
 */
export interface PublicApiListApplicationsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListApplications
     */
    readonly orgId: string
}

/**
 * Request parameters for listArtefactVersions operation in PublicApi.
 * @export
 * @interface PublicApiListArtefactVersionsRequest
 */
export interface PublicApiListArtefactVersionsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListArtefactVersions
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof PublicApiListArtefactVersions
     */
    readonly artefactId: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
     * @type {boolean}
     * @memberof PublicApiListArtefactVersions
     */
    readonly archived?: boolean

    /**
     * (Optional) Filter Artefact Versions by by name including a version or digest.
     * @type {string}
     * @memberof PublicApiListArtefactVersions
     */
    readonly reference?: string

    /**
     * (Optional) Limit the number of versions returned by the endpoint.
     * @type {number}
     * @memberof PublicApiListArtefactVersions
     */
    readonly limit?: number
}

/**
 * Request parameters for listArtefactVersionsInOrg operation in PublicApi.
 * @export
 * @interface PublicApiListArtefactVersionsInOrgRequest
 */
export interface PublicApiListArtefactVersionsInOrgRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListArtefactVersionsInOrg
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefact Versions by name.
     * @type {string}
     * @memberof PublicApiListArtefactVersionsInOrg
     */
    readonly name?: string

    /**
     * (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.
     * @type {string}
     * @memberof PublicApiListArtefactVersionsInOrg
     */
    readonly reference?: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.
     * @type {boolean}
     * @memberof PublicApiListArtefactVersionsInOrg
     */
    readonly archived?: boolean

    /**
     * (Optional) Filter by artefact type.
     * @type {string}
     * @memberof PublicApiListArtefactVersionsInOrg
     */
    readonly type?: string
}

/**
 * Request parameters for listArtefacts operation in PublicApi.
 * @export
 * @interface PublicApiListArtefactsRequest
 */
export interface PublicApiListArtefactsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListArtefacts
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefacts by type.
     * @type {string}
     * @memberof PublicApiListArtefacts
     */
    readonly type?: string

    /**
     * (Optional) Filter Artefacts by name.
     * @type {string}
     * @memberof PublicApiListArtefacts
     */
    readonly name?: string
}

/**
 * Request parameters for listAuditLogEntries operation in PublicApi.
 * @export
 * @interface PublicApiListAuditLogEntriesRequest
 */
export interface PublicApiListAuditLogEntriesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListAuditLogEntries
     */
    readonly orgId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListAuditLogEntries
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListAuditLogEntries
     */
    readonly page?: string

    /**
     * Optional filter for entries created after the given time.
     * @type {string}
     * @memberof PublicApiListAuditLogEntries
     */
    readonly from?: string

    /**
     * Optional filter for entries created before the given time.
     * @type {string}
     * @memberof PublicApiListAuditLogEntries
     */
    readonly to?: string
}

/**
 * Request parameters for listDeploymentErrors operation in PublicApi.
 * @export
 * @interface PublicApiListDeploymentErrorsRequest
 */
export interface PublicApiListDeploymentErrorsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListDeploymentErrors
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiListDeploymentErrors
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiListDeploymentErrors
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof PublicApiListDeploymentErrors
     */
    readonly deployId: string
}

/**
 * Request parameters for listDeployments operation in PublicApi.
 * @export
 * @interface PublicApiListDeploymentsRequest
 */
export interface PublicApiListDeploymentsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListDeployments
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiListDeployments
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiListDeployments
     */
    readonly envId: string

    /**
     * An optional filter by the Pipeline and Pipeline Run ID separated by a comma. 
     * @type {string}
     * @memberof PublicApiListDeployments
     */
    readonly pipelineRunId?: string
}

/**
 * Request parameters for listDeprecatedImageBuilds operation in PublicApi.
 * @export
 * @interface PublicApiListDeprecatedImageBuildsRequest
 */
export interface PublicApiListDeprecatedImageBuildsRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListDeprecatedImageBuilds
     */
    readonly orgId: string

    /**
     * The Image ID.
     * @type {string}
     * @memberof PublicApiListDeprecatedImageBuilds
     */
    readonly imageId: string
}

/**
 * Request parameters for listDeprecatedImages operation in PublicApi.
 * @export
 * @interface PublicApiListDeprecatedImagesRequest
 */
export interface PublicApiListDeprecatedImagesRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListDeprecatedImages
     */
    readonly orgId: string
}

/**
 * Request parameters for listEnvironmentTypes operation in PublicApi.
 * @export
 * @interface PublicApiListEnvironmentTypesRequest
 */
export interface PublicApiListEnvironmentTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListEnvironmentTypes
     */
    readonly orgId: string
}

/**
 * Request parameters for listEnvironments operation in PublicApi.
 * @export
 * @interface PublicApiListEnvironmentsRequest
 */
export interface PublicApiListEnvironmentsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListEnvironments
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiListEnvironments
     */
    readonly appId: string
}

/**
 * Request parameters for listHumanitecPublicKeys operation in PublicApi.
 * @export
 * @interface PublicApiListHumanitecPublicKeysRequest
 */
export interface PublicApiListHumanitecPublicKeysRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListHumanitecPublicKeys
     */
    readonly orgId: string

    /**
     * If set to true, the response includes only the active key, if set to false only non-active keys, otherwise both active and non-active keys.
     * @type {boolean}
     * @memberof PublicApiListHumanitecPublicKeys
     */
    readonly active?: boolean
}

/**
 * Request parameters for listInvitesInOrg operation in PublicApi.
 * @export
 * @interface PublicApiListInvitesInOrgRequest
 */
export interface PublicApiListInvitesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListInvitesInOrg
     */
    readonly orgId: string
}

/**
 * Request parameters for listKeysInAgent operation in PublicApi.
 * @export
 * @interface PublicApiListKeysInAgentRequest
 */
export interface PublicApiListKeysInAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListKeysInAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof PublicApiListKeysInAgent
     */
    readonly agentId: string
}

/**
 * Request parameters for listPipelineApprovalRequests operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineApprovalRequestsRequest
 */
export interface PublicApiListPipelineApprovalRequestsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly appId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly page?: string

    /**
     * An optional list of Pipeline IDs.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly pipeline?: Array<string>

    /**
     * An optional Pipeline Run ID.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly run?: Array<string>

    /**
     * Optional filter by status.
     * @type {string}
     * @memberof PublicApiListPipelineApprovalRequests
     */
    readonly status?: string
}

/**
 * Request parameters for listPipelineCriteriaInApp operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineCriteriaInAppRequest
 */
export interface PublicApiListPipelineCriteriaInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly appId: string

    /**
     * An optional filter by Pipeline ID.
     * @type {string}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly pipeline?: string

    /**
     * Optional key value match filters on the criteria.
     * @type {{ [key: string]: string; }}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly match?: { [key: string]: string; }

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineCriteriaInApp
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineJobs operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineJobsRequest
 */
export interface PublicApiListPipelineJobsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineJobs
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineJobs
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiListPipelineJobs
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiListPipelineJobs
     */
    readonly runId: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineJobs
     */
    readonly status?: Array<string>

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineJobs
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineJobs
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineRuns operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineRunsRequest
 */
export interface PublicApiListPipelineRunsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly pipelineId: string

    /**
     * An optional Environment ID
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly env?: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineRuns
     */
    readonly status?: Array<string>

    /**
     * Optional filer by completed or not.
     * @type {boolean}
     * @memberof PublicApiListPipelineRuns
     */
    readonly completed?: boolean

    /**
     * Optional filter by creation after date time.
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly createdAfter?: string

    /**
     * Optional filter by creation before date time
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly createdBefore?: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineRuns
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineRuns
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineRunsByOrg operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineRunsByOrgRequest
 */
export interface PublicApiListPipelineRunsByOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly orgId: string

    /**
     * An optional list of Application IDs.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly app?: Array<string>

    /**
     * An optional list of Pipeline IDs.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly pipeline?: Array<string>

    /**
     * An optional Environment ID
     * @type {string}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly env?: string

    /**
     * Optional filter by status.
     * @type {Array<string>}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly status?: Array<string>

    /**
     * Optional filer by completed or not.
     * @type {boolean}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly completed?: boolean

    /**
     * Optional filter by creation after date time.
     * @type {string}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly createdAfter?: string

    /**
     * Optional filter by creation before date time
     * @type {string}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly createdBefore?: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineRunsByOrg
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineStepLogs operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineStepLogsRequest
 */
export interface PublicApiListPipelineStepLogsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly runId: string

    /**
     * The Job ID
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly jobId: string

    /**
     * The index of the step within the Job
     * @type {number}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly stepIndex: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineStepLogs
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelineVersions operation in PublicApi.
 * @export
 * @interface PublicApiListPipelineVersionsRequest
 */
export interface PublicApiListPipelineVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelineVersions
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelineVersions
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiListPipelineVersions
     */
    readonly pipelineId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelineVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelineVersions
     */
    readonly page?: string
}

/**
 * Request parameters for listPipelines operation in PublicApi.
 * @export
 * @interface PublicApiListPipelinesRequest
 */
export interface PublicApiListPipelinesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelines
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListPipelines
     */
    readonly appId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelines
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelines
     */
    readonly page?: string

    /**
     * An optional filter by trigger type.
     * @type {string}
     * @memberof PublicApiListPipelines
     */
    readonly trigger?: string

    /**
     * Optional filter by pipeline metadata
     * @type {{ [key: string]: string; }}
     * @memberof PublicApiListPipelines
     */
    readonly metadata?: { [key: string]: string; }
}

/**
 * Request parameters for listPipelinesInOrg operation in PublicApi.
 * @export
 * @interface PublicApiListPipelinesInOrgRequest
 */
export interface PublicApiListPipelinesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly orgId: string

    /**
     * An optional list of Application IDs.
     * @type {Array<string>}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly app?: Array<string>

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly page?: string

    /**
     * An optional filter by trigger type.
     * @type {string}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly trigger?: string

    /**
     * Optional filter by pipeline metadata
     * @type {{ [key: string]: string; }}
     * @memberof PublicApiListPipelinesInOrg
     */
    readonly metadata?: { [key: string]: string; }
}

/**
 * Request parameters for listPublicKeys operation in PublicApi.
 * @export
 * @interface PublicApiListPublicKeysRequest
 */
export interface PublicApiListPublicKeysRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiListPublicKeys
     */
    readonly orgId: string

    /**
     * The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
     * @type {string}
     * @memberof PublicApiListPublicKeys
     */
    readonly fingerprint?: string
}

/**
 * Request parameters for listResourceAccountTypes operation in PublicApi.
 * @export
 * @interface PublicApiListResourceAccountTypesRequest
 */
export interface PublicApiListResourceAccountTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListResourceAccountTypes
     */
    readonly orgId: string
}

/**
 * Request parameters for listResourceAccounts operation in PublicApi.
 * @export
 * @interface PublicApiListResourceAccountsRequest
 */
export interface PublicApiListResourceAccountsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListResourceAccounts
     */
    readonly orgId: string
}

/**
 * Request parameters for listResourceDefinitions operation in PublicApi.
 * @export
 * @interface PublicApiListResourceDefinitionsRequest
 */
export interface PublicApiListResourceDefinitionsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly orgId: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Application.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly app?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly env?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly envType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly res?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly resType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Class.  
     * @type {string}
     * @memberof PublicApiListResourceDefinitions
     */
    readonly _class?: string
}

/**
 * Request parameters for listResourceDrivers operation in PublicApi.
 * @export
 * @interface PublicApiListResourceDriversRequest
 */
export interface PublicApiListResourceDriversRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListResourceDrivers
     */
    readonly orgId: string
}

/**
 * Request parameters for listResourceTypes operation in PublicApi.
 * @export
 * @interface PublicApiListResourceTypesRequest
 */
export interface PublicApiListResourceTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiListResourceTypes
     */
    readonly orgId: string
}

/**
 * Request parameters for listRuntime operation in PublicApi.
 * @export
 * @interface PublicApiListRuntimeRequest
 */
export interface PublicApiListRuntimeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListRuntime
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiListRuntime
     */
    readonly appId: string

    /**
     * Filter environments by ID (required). Up to 5 ids can be supplied per request.
     * @type {Array<string>}
     * @memberof PublicApiListRuntime
     */
    readonly id?: Array<string>
}

/**
 * Request parameters for listUserRolesInApp operation in PublicApi.
 * @export
 * @interface PublicApiListUserRolesInAppRequest
 */
export interface PublicApiListUserRolesInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListUserRolesInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiListUserRolesInApp
     */
    readonly appId: string
}

/**
 * Request parameters for listUserRolesInEnvType operation in PublicApi.
 * @export
 * @interface PublicApiListUserRolesInEnvTypeRequest
 */
export interface PublicApiListUserRolesInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListUserRolesInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiListUserRolesInEnvType
     */
    readonly envType: string
}

/**
 * Request parameters for listUserRolesInOrg operation in PublicApi.
 * @export
 * @interface PublicApiListUserRolesInOrgRequest
 */
export interface PublicApiListUserRolesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListUserRolesInOrg
     */
    readonly orgId: string
}

/**
 * Request parameters for listUserTokens operation in PublicApi.
 * @export
 * @interface PublicApiListUserTokensRequest
 */
export interface PublicApiListUserTokensRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiListUserTokens
     */
    readonly userId: string
}

/**
 * Request parameters for listWorkloadProfileChartVersions operation in PublicApi.
 * @export
 * @interface PublicApiListWorkloadProfileChartVersionsRequest
 */
export interface PublicApiListWorkloadProfileChartVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListWorkloadProfileChartVersions
     */
    readonly orgId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListWorkloadProfileChartVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListWorkloadProfileChartVersions
     */
    readonly page?: string

    /**
     * Filter Chart Versions by Chart Version ID.
     * @type {string}
     * @memberof PublicApiListWorkloadProfileChartVersions
     */
    readonly id?: string

    /**
     * Filter Chart Versions by Chart Version.
     * @type {string}
     * @memberof PublicApiListWorkloadProfileChartVersions
     */
    readonly version?: string
}

/**
 * Request parameters for listWorkloadProfileFeatures operation in PublicApi.
 * @export
 * @interface PublicApiListWorkloadProfileFeaturesRequest
 */
export interface PublicApiListWorkloadProfileFeaturesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListWorkloadProfileFeatures
     */
    readonly orgId: string
}

/**
 * Request parameters for listWorkloadProfileVersions operation in PublicApi.
 * @export
 * @interface PublicApiListWorkloadProfileVersionsRequest
 */
export interface PublicApiListWorkloadProfileVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListWorkloadProfileVersions
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof PublicApiListWorkloadProfileVersions
     */
    readonly profileQid: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListWorkloadProfileVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListWorkloadProfileVersions
     */
    readonly page?: string
}

/**
 * Request parameters for listWorkloadProfiles operation in PublicApi.
 * @export
 * @interface PublicApiListWorkloadProfilesRequest
 */
export interface PublicApiListWorkloadProfilesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiListWorkloadProfiles
     */
    readonly orgId: string

    /**
     * Whether to include deprecated profiles
     * @type {boolean}
     * @memberof PublicApiListWorkloadProfiles
     */
    readonly deprecated?: boolean

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof PublicApiListWorkloadProfiles
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof PublicApiListWorkloadProfiles
     */
    readonly page?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly deltaId: string

    /**
     * Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly deltaId: string

    /**
     * The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly deltaId: string

    /**
     * The new name.(NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {Array<DeltaRequest>}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaRequest: Array<DeltaRequest>
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly appId: string

    /**
     * If true, return archived Deltas.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly archived?: boolean

    /**
     * Only return Deltas associated with the specified Environment.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly env?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly appId: string

    /**
     * A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @type {DeltaRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly envId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly ruleId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly envId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly envId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdJobsDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to diff against.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly sourceSetId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to compared against.
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly diff?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly setId: string

    /**
     * The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @type {DeltaRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly appId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly jobId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly appId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdEventsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEventsGetRequest
 */
export interface PublicApiOrgsOrgIdEventsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEventsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesPostRequest
 */
export interface PublicApiOrgsOrgIdRegistriesPostRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesPost
     */
    readonly orgId: string

    /**
     * A new record details.  
     * @type {RegistryRequest}
     * @memberof PublicApiOrgsOrgIdRegistriesPost
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdCredsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdPatchRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdPatchRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly regId: string

    /**
     * Record details to update.  
     * @type {RegistryRequest}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdSecretstoresGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdSecretstoresGetRequest
 */
export interface PublicApiOrgsOrgIdSecretstoresGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdSecretstoresPostRequest
 */
export interface PublicApiOrgsOrgIdSecretstoresPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresPost
     */
    readonly orgId: string

    /**
     * Secret Store data.  
     * @type {CreateSecretStorePayloadRequest}
     * @memberof PublicApiOrgsOrgIdSecretstoresPost
     */
    readonly createSecretStorePayloadRequest: CreateSecretStorePayloadRequest
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdDelete
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdDelete
     */
    readonly storeId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest
 */
export interface PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdGet
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdGet
     */
    readonly storeId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest
 */
export interface PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly storeId: string

    /**
     * Secret Store data.  
     * @type {UpdateSecretStorePayloadRequest}
     * @memberof PublicApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest
}

/**
 * Request parameters for patchAgent operation in PublicApi.
 * @export
 * @interface PublicApiPatchAgentRequest
 */
export interface PublicApiPatchAgentRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiPatchAgent
     */
    readonly orgId: string

    /**
     * The Agent id.
     * @type {string}
     * @memberof PublicApiPatchAgent
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentPatchBody}
     * @memberof PublicApiPatchAgent
     */
    readonly agentPatchBody: AgentPatchBody
}

/**
 * Request parameters for patchArtefactVersion operation in PublicApi.
 * @export
 * @interface PublicApiPatchArtefactVersionRequest
 */
export interface PublicApiPatchArtefactVersionRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicApiPatchArtefactVersion
     */
    readonly orgId: string

    /**
     * The Artefact ID.
     * @type {string}
     * @memberof PublicApiPatchArtefactVersion
     */
    readonly artefactId: string

    /**
     * The Version ID.
     * @type {string}
     * @memberof PublicApiPatchArtefactVersion
     */
    readonly versionId: string

    /**
     * The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.
     * @type {UpdateArtefactVersionPayloadRequest}
     * @memberof PublicApiPatchArtefactVersion
     */
    readonly updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest
}

/**
 * Request parameters for patchReplicas operation in PublicApi.
 * @export
 * @interface PublicApiPatchReplicasRequest
 */
export interface PublicApiPatchReplicasRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiPatchReplicas
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiPatchReplicas
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof PublicApiPatchReplicas
     */
    readonly envId: string

    /**
     * map of replicas by modules.
     * @type {{ [key: string]: number; }}
     * @memberof PublicApiPatchReplicas
     */
    readonly requestBody: { [key: string]: number; }
}

/**
 * Request parameters for patchResourceAccount operation in PublicApi.
 * @export
 * @interface PublicApiPatchResourceAccountRequest
 */
export interface PublicApiPatchResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiPatchResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiPatchResourceAccount
     */
    readonly accId: string

    /**
     * 
     * @type {UpdateResourceAccountRequestRequest}
     * @memberof PublicApiPatchResourceAccount
     */
    readonly updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest
}

/**
 * Request parameters for patchResourceDefinition operation in PublicApi.
 * @export
 * @interface PublicApiPatchResourceDefinitionRequest
 */
export interface PublicApiPatchResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiPatchResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiPatchResourceDefinition
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @type {PatchResourceDefinitionRequestRequest}
     * @memberof PublicApiPatchResourceDefinition
     */
    readonly patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest
}

/**
 * Request parameters for putDelta operation in PublicApi.
 * @export
 * @interface PublicApiPutDeltaRequest
 */
export interface PublicApiPutDeltaRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {DeltaRequest}
     * @memberof PublicApiPutDelta
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for queryResourceGraph operation in PublicApi.
 * @export
 * @interface PublicApiQueryResourceGraphRequest
 */
export interface PublicApiQueryResourceGraphRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiQueryResourceGraph
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiQueryResourceGraph
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiQueryResourceGraph
     */
    readonly envId: string

    /**
     * Resources to provision.  
     * @type {Array<ResourceProvisionRequestRequest>}
     * @memberof PublicApiQueryResourceGraph
     */
    readonly resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>
}

/**
 * Request parameters for rebaseEnvironment operation in PublicApi.
 * @export
 * @interface PublicApiRebaseEnvironmentRequest
 */
export interface PublicApiRebaseEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiRebaseEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiRebaseEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiRebaseEnvironment
     */
    readonly envId: string

    /**
     * The Deployment ID to rebase to.  
     * @type {string}
     * @memberof PublicApiRebaseEnvironment
     */
    readonly body: string
}

/**
 * Request parameters for restartPipelineRun operation in PublicApi.
 * @export
 * @interface PublicApiRestartPipelineRunRequest
 */
export interface PublicApiRestartPipelineRunRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiRestartPipelineRun
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiRestartPipelineRun
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiRestartPipelineRun
     */
    readonly pipelineId: string

    /**
     * The Run ID
     * @type {string}
     * @memberof PublicApiRestartPipelineRun
     */
    readonly runId: string

    /**
     * The HTTP Idempotency-Key
     * @type {string}
     * @memberof PublicApiRestartPipelineRun
     */
    readonly idempotencyKey?: string
}

/**
 * Request parameters for updateCurrentUser operation in PublicApi.
 * @export
 * @interface PublicApiUpdateCurrentUserRequest
 */
export interface PublicApiUpdateCurrentUserRequest {
    /**
     * 
     * @type {UserProfileExtendedRequest}
     * @memberof PublicApiUpdateCurrentUser
     */
    readonly userProfileExtendedRequest: UserProfileExtendedRequest
}

/**
 * Request parameters for updateEnvironment operation in PublicApi.
 * @export
 * @interface PublicApiUpdateEnvironmentRequest
 */
export interface PublicApiUpdateEnvironmentRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiUpdateEnvironment
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiUpdateEnvironment
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiUpdateEnvironment
     */
    readonly envId: string

    /**
     * 
     * @type {EnvironmentBaseUpdateRequest}
     * @memberof PublicApiUpdateEnvironment
     */
    readonly environmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest
}

/**
 * Request parameters for updateEnvironmentType operation in PublicApi.
 * @export
 * @interface PublicApiUpdateEnvironmentTypeRequest
 */
export interface PublicApiUpdateEnvironmentTypeRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiUpdateEnvironmentType
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof PublicApiUpdateEnvironmentType
     */
    readonly envTypeId: string

    /**
     * 
     * @type {UpdateEnvironmentTypePayloadRequest}
     * @memberof PublicApiUpdateEnvironmentType
     */
    readonly updateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest
}

/**
 * Request parameters for updatePaused operation in PublicApi.
 * @export
 * @interface PublicApiUpdatePausedRequest
 */
export interface PublicApiUpdatePausedRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdatePaused
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiUpdatePaused
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof PublicApiUpdatePaused
     */
    readonly envId: string

    /**
     * If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.
     * @type {boolean}
     * @memberof PublicApiUpdatePaused
     */
    readonly body: boolean
}

/**
 * Request parameters for updatePipeline operation in PublicApi.
 * @export
 * @interface PublicApiUpdatePipelineRequest
 */
export interface PublicApiUpdatePipelineRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdatePipeline
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof PublicApiUpdatePipeline
     */
    readonly appId: string

    /**
     * The Pipeline ID
     * @type {string}
     * @memberof PublicApiUpdatePipeline
     */
    readonly pipelineId: string

    /**
     * 
     * @type {object}
     * @memberof PublicApiUpdatePipeline
     */
    readonly body: object

    /**
     * Indicate that the request should only succeed if there is an etag match
     * @type {string}
     * @memberof PublicApiUpdatePipeline
     */
    readonly ifMatch?: string

    /**
     * Optionally validate the request but do not persist the update.
     * @type {boolean}
     * @memberof PublicApiUpdatePipeline
     */
    readonly dryRun?: boolean
}

/**
 * Request parameters for updateResourceDefinition operation in PublicApi.
 * @export
 * @interface PublicApiUpdateResourceDefinitionRequest
 */
export interface PublicApiUpdateResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDefinition
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
     * @type {UpdateResourceDefinitionRequestRequest}
     * @memberof PublicApiUpdateResourceDefinition
     */
    readonly updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest
}

/**
 * Request parameters for updateResourceDefinitionCriteria operation in PublicApi.
 * @export
 * @interface PublicApiUpdateResourceDefinitionCriteriaRequest
 */
export interface PublicApiUpdateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {Array<MatchingCriteriaRuleRequest>}
     * @memberof PublicApiUpdateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>
}

/**
 * Request parameters for updateResourceDriver operation in PublicApi.
 * @export
 * @interface PublicApiUpdateResourceDriverRequest
 */
export interface PublicApiUpdateResourceDriverRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDriver
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof PublicApiUpdateResourceDriver
     */
    readonly driverId: string

    /**
     * 
     * @type {UpdateDriverRequestRequest}
     * @memberof PublicApiUpdateResourceDriver
     */
    readonly updateDriverRequestRequest: UpdateDriverRequestRequest
}

/**
 * Request parameters for updateUserRoleInApp operation in PublicApi.
 * @export
 * @interface PublicApiUpdateUserRoleInAppRequest
 */
export interface PublicApiUpdateUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInApp
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof PublicApiUpdateUserRoleInApp
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for updateUserRoleInEnvType operation in PublicApi.
 * @export
 * @interface PublicApiUpdateUserRoleInEnvTypeRequest
 */
export interface PublicApiUpdateUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInEnvType
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof PublicApiUpdateUserRoleInEnvType
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for updateUserRoleInOrg operation in PublicApi.
 * @export
 * @interface PublicApiUpdateUserRoleInOrgRequest
 */
export interface PublicApiUpdateUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiUpdateUserRoleInOrg
     */
    readonly userId: string

    /**
     * The new user the role  
     * @type {RoleRequest}
     * @memberof PublicApiUpdateUserRoleInOrg
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for updateWorkloadProfile operation in PublicApi.
 * @export
 * @interface PublicApiUpdateWorkloadProfileRequest
 */
export interface PublicApiUpdateWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof PublicApiUpdateWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof PublicApiUpdateWorkloadProfile
     */
    readonly profileQid: string

    /**
     * Workload profile details. 
     * @type {WorkloadProfileUpdateRequest}
     * @memberof PublicApiUpdateWorkloadProfile
     */
    readonly workloadProfileUpdateRequest: WorkloadProfileUpdateRequest
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * Approve the approval requested.
     * @summary Approve the approval request
     * @param {PublicApiApprovePipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public approvePipelineApprovalRequest(requestParameters: PublicApiApprovePipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).approvePipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
     * @summary Cancel a Run within an Pipeline.
     * @param {PublicApiCancelPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public cancelPipelineRun(requestParameters: PublicApiCancelPipelineRunRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).cancelPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Agent under an Organization.
     * @param {PublicApiCreateAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createAgent(requestParameters: PublicApiCreateAgentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createAgent(requestParameters.orgId, requestParameters.agentCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {PublicApiCreateApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createApplication(requestParameters: PublicApiCreateApplicationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createApplication(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {PublicApiCreateArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createArtefactVersion(requestParameters: PublicApiCreateArtefactVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createArtefactVersion(requestParameters.orgId, requestParameters.createArtefactVersion, requestParameters.vcs, requestParameters.dryRun, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {PublicApiCreateDeploymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createDeployment(requestParameters: PublicApiCreateDeploymentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {PublicApiCreateDeprecatedImageBuildRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createDeprecatedImageBuild(requestParameters: PublicApiCreateDeprecatedImageBuildRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createDeprecatedImageBuild(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {PublicApiCreateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createEnvironment(requestParameters: PublicApiCreateEnvironmentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {PublicApiCreateEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createEnvironmentType(requestParameters: PublicApiCreateEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createEnvironmentType(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {PublicApiCreateInviteInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createInviteInOrg(requestParameters: PublicApiCreateInviteInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createInviteInOrg(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Key under an Agent in an Organization.
     * @param {PublicApiCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createKey(requestParameters: PublicApiCreateKeyRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createKey(requestParameters.orgId, requestParameters.agentId, requestParameters.keyCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Pipeline within an Application.
     * @param {PublicApiCreatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPipeline(requestParameters: PublicApiCreatePipelineRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.body, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
     * @summary Create a new trigger matching criteria for this Pipeline.
     * @param {PublicApiCreatePipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPipelineCriteria(requestParameters: PublicApiCreatePipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineCriteriaCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a run within a pipeline.
     * @param {PublicApiCreatePipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPipelineRun(requestParameters: PublicApiCreatePipelineRunRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.pipelineRunCreateBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
     * @param {PublicApiCreatePipelineRunByTriggerCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPipelineRunByTriggerCriteria(requestParameters: PublicApiCreatePipelineRunByTriggerCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPipelineRunByTriggerCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineRunCreateByTriggerCriteriaBody, requestParameters.idempotencyKey, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Associate a new RSA public key to an organization.
     * @param {PublicApiCreatePublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createPublicKey(requestParameters: PublicApiCreatePublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createPublicKey(requestParameters.orgId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {PublicApiCreateResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createResourceAccount(requestParameters: PublicApiCreateResourceAccountRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createResourceAccount(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {PublicApiCreateResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createResourceDefinition(requestParameters: PublicApiCreateResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createResourceDefinition(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {PublicApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createResourceDefinitionCriteria(requestParameters: PublicApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {PublicApiCreateResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createResourceDriver(requestParameters: PublicApiCreateResourceDriverRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createResourceDriver(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {PublicApiCreateServiceUserInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createServiceUserInOrg(requestParameters: PublicApiCreateServiceUserInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createServiceUserInOrg(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {PublicApiCreateUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createUserRoleInApp(requestParameters: PublicApiCreateUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Environment Type with a Role
     * @param {PublicApiCreateUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createUserRoleInEnvType(requestParameters: PublicApiCreateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is only supported for users of type `service`.
     * @summary Creates a new static token for a user.
     * @param {PublicApiCreateUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createUserToken(requestParameters: PublicApiCreateUserTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createUserToken(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {PublicApiCreateWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createWorkloadProfile(requestParameters: PublicApiCreateWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createWorkloadProfile(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
     * @summary Add new Workload Profile Chart Version
     * @param {PublicApiCreateWorkloadProfileChartVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public createWorkloadProfileChartVersion(requestParameters: PublicApiCreateWorkloadProfileChartVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).createWorkloadProfileChartVersion(requestParameters.orgId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {PublicApiDeleteActiveResourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteActiveResource(requestParameters: PublicApiDeleteActiveResourceRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteActiveResource(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, requestParameters.detach, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an Agent (and its keys) stored under an Organization.
     * @param {PublicApiDeleteAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteAgent(requestParameters: PublicApiDeleteAgentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {PublicApiDeleteApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteApplication(requestParameters: PublicApiDeleteApplicationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {PublicApiDeleteArtefactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteArtefact(requestParameters: PublicApiDeleteArtefactRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteArtefact(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {PublicApiDeleteEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteEnvironment(requestParameters: PublicApiDeleteEnvironmentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {PublicApiDeleteEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteEnvironmentType(requestParameters: PublicApiDeleteEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key registered under a Agent.
     * @param {PublicApiDeleteKeyInAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteKeyInAgent(requestParameters: PublicApiDeleteKeyInAgentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteKeyInAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a pipeline within an application.
     * @param {PublicApiDeletePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deletePipeline(requestParameters: PublicApiDeletePipelineRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deletePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the Pipeline Criteria with the given id.
     * @param {PublicApiDeletePipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deletePipelineCriteria(requestParameters: PublicApiDeletePipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deletePipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deleting a completed Run within a Pipeline.
     * @param {PublicApiDeletePipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deletePipelineRun(requestParameters: PublicApiDeletePipelineRunRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deletePipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a public key associated to an organization.
     * @param {PublicApiDeletePublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deletePublicKey(requestParameters: PublicApiDeletePublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deletePublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an unused Resource Account.
     * @param {PublicApiDeleteResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteResourceAccount(requestParameters: PublicApiDeleteResourceAccountRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {PublicApiDeleteResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteResourceDefinition(requestParameters: PublicApiDeleteResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {PublicApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteResourceDefinitionCriteria(requestParameters: PublicApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {PublicApiDeleteResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteResourceDriver(requestParameters: PublicApiDeleteResourceDriverRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Application
     * @param {PublicApiDeleteUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteUserRoleInApp(requestParameters: PublicApiDeleteUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Environment Type
     * @param {PublicApiDeleteUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteUserRoleInEnvType(requestParameters: PublicApiDeleteUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Organization
     * @param {PublicApiDeleteUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteUserRoleInOrg(requestParameters: PublicApiDeleteUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
     * @summary Deletes a specific token associated with a user
     * @param {PublicApiDeleteUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteUserToken(requestParameters: PublicApiDeleteUserTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {PublicApiDeleteWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public deleteWorkloadProfile(requestParameters: PublicApiDeleteWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).deleteWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deny the approval requested.
     * @summary Deny the approval request
     * @param {PublicApiDenyPipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public denyPipelineApprovalRequest(requestParameters: PublicApiDenyPipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).denyPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {PublicApiGetApplicationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getApplication(requestParameters: PublicApiGetApplicationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getApplication(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific Artefact Version.
     * @summary Get an Artefacts Versions.
     * @param {PublicApiGetArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getArtefactVersion(requestParameters: PublicApiGetArtefactVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getArtefactVersion(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the current state of a trigger batch for a Pipeline if one exists
     * @summary Read the current state of a trigger batch
     * @param {PublicApiGetBatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getBatch(requestParameters: PublicApiGetBatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getBatch(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.batchType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch an existing Delta
     * @param {PublicApiGetDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDelta(requestParameters: PublicApiGetDeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {PublicApiGetDeploymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDeployment(requestParameters: PublicApiGetDeploymentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDeployment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {PublicApiGetDeprecatedImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDeprecatedImage(requestParameters: PublicApiGetDeprecatedImageRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDeprecatedImage(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {PublicApiGetEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getEnvironment(requestParameters: PublicApiGetEnvironmentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {PublicApiGetEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getEnvironmentType(requestParameters: PublicApiGetEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the latest pipeline schema
     * @param {PublicApiGetLatestPipelineDefinitionSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getLatestPipelineDefinitionSchema(requestParameters: PublicApiGetLatestPipelineDefinitionSchemaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getLatestPipelineDefinitionSchema(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Latest version of the given workload profile with optional constraint.
     * @param {PublicApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getLatestWorkloadProfileVersion(requestParameters: PublicApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {PublicApiGetOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getOrganization(requestParameters: PublicApiGetOrganizationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Pipeline within an Application.
     * @param {PublicApiGetPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipeline(requestParameters: PublicApiGetPipelineRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an approval request.
     * @summary Get an approval request
     * @param {PublicApiGetPipelineApprovalRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipelineApprovalRequest(requestParameters: PublicApiGetPipelineApprovalRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipelineApprovalRequest(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.approvalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Pipeline Criteria with the given id.
     * @param {PublicApiGetPipelineCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipelineCriteria(requestParameters: PublicApiGetPipelineCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipelineCriteria(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.criteriaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pipeline schema.
     * @param {PublicApiGetPipelineDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipelineDefinition(requestParameters: PublicApiGetPipelineDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipelineDefinition(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.version, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the details of a Job including Step information
     * @param {PublicApiGetPipelineJobRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipelineJob(requestParameters: PublicApiGetPipelineJobRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipelineJob(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a run within an pipeline.
     * @param {PublicApiGetPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPipelineRun(requestParameters: PublicApiGetPipelineRunRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a single public key associated to an organization.
     * @param {PublicApiGetPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getPublicKey(requestParameters: PublicApiGetPublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getPublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {PublicApiGetResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getResourceAccount(requestParameters: PublicApiGetResourceAccountRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {PublicApiGetResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getResourceDefinition(requestParameters: PublicApiGetResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getResourceDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {PublicApiGetResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getResourceDriver(requestParameters: PublicApiGetResourceDriverRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getResourceDriver(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {PublicApiGetRuntimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getRuntime(requestParameters: PublicApiGetRuntimeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Deployment Sets
     * @param {PublicApiGetSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSets(requestParameters: PublicApiGetSetsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {PublicApiGetUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUserRoleInApp(requestParameters: PublicApiGetUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {PublicApiGetUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUserRoleInEnvType(requestParameters: PublicApiGetUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Organization
     * @param {PublicApiGetUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUserRoleInOrg(requestParameters: PublicApiGetUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific token associated with a user
     * @param {PublicApiGetUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getUserToken(requestParameters: PublicApiGetUserTokenRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * @summary Get the Humanitec module definition of this Workload Artefact Version as a deployment set
     * @param {PublicApiGetWorkloadArtefactVersionDeploymentSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWorkloadArtefactVersionDeploymentSet(requestParameters: PublicApiGetWorkloadArtefactVersionDeploymentSetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWorkloadArtefactVersionDeploymentSet(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * @summary Get the spec of this Workload Artefact Version
     * @param {PublicApiGetWorkloadArtefactVersionSpecRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWorkloadArtefactVersionSpec(requestParameters: PublicApiGetWorkloadArtefactVersionSpecRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWorkloadArtefactVersionSpec(requestParameters.orgId, requestParameters.artefactVersionId, requestParameters.accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {PublicApiGetWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getWorkloadProfile(requestParameters: PublicApiGetWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {PublicApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listActiveResourceByDefinition(requestParameters: PublicApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {PublicApiListActiveResourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listActiveResources(requestParameters: PublicApiListActiveResourcesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listActiveResources(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the agents in an Organization.
     * @param {PublicApiListAgentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listAgents(requestParameters: PublicApiListAgentsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listAgents(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {PublicApiListApplicationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listApplications(requestParameters: PublicApiListApplicationsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listApplications(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {PublicApiListArtefactVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listArtefactVersions(requestParameters: PublicApiListArtefactVersionsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listArtefactVersions(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions in the org.
     * @param {PublicApiListArtefactVersionsInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listArtefactVersionsInOrg(requestParameters: PublicApiListArtefactVersionsInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listArtefactVersionsInOrg(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {PublicApiListArtefactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listArtefacts(requestParameters: PublicApiListArtefactsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listArtefacts(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
     * @summary List audit log entries by Organization
     * @param {PublicApiListAuditLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listAuditLogEntries(requestParameters: PublicApiListAuditLogEntriesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listAuditLogEntries(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {PublicApiListDeploymentErrorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeploymentErrors(requestParameters: PublicApiListDeploymentErrorsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeploymentErrors(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {PublicApiListDeploymentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeployments(requestParameters: PublicApiListDeploymentsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeployments(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.pipelineRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {PublicApiListDeprecatedImageBuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeprecatedImageBuilds(requestParameters: PublicApiListDeprecatedImageBuildsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeprecatedImageBuilds(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {PublicApiListDeprecatedImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listDeprecatedImages(requestParameters: PublicApiListDeprecatedImagesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listDeprecatedImages(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {PublicApiListEnvironmentTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listEnvironmentTypes(requestParameters: PublicApiListEnvironmentTypesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listEnvironmentTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {PublicApiListEnvironmentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listEnvironments(requestParameters: PublicApiListEnvironmentsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listEnvironments(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the public keys Humanitec shares with an organization.
     * @param {PublicApiListHumanitecPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listHumanitecPublicKeys(requestParameters: PublicApiListHumanitecPublicKeysRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listHumanitecPublicKeys(requestParameters.orgId, requestParameters.active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {PublicApiListInvitesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listInvitesInOrg(requestParameters: PublicApiListInvitesInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listInvitesInOrg(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the keys registered under an Agent in an Organization.
     * @param {PublicApiListKeysInAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listKeysInAgent(requestParameters: PublicApiListKeysInAgentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listKeysInAgent(requestParameters.orgId, requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listOrganizations(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the approval requests with in an app. 
     * @summary List of the approval requests
     * @param {PublicApiListPipelineApprovalRequestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineApprovalRequests(requestParameters: PublicApiListPipelineApprovalRequestsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineApprovalRequests(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.pipeline, requestParameters.run, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
     * @summary List the trigger matching criteria defined for Pipelines in this Application.
     * @param {PublicApiListPipelineCriteriaInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineCriteriaInApp(requestParameters: PublicApiListPipelineCriteriaInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineCriteriaInApp(requestParameters.orgId, requestParameters.appId, requestParameters.pipeline, requestParameters.match, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the details of the jobs within a pipeline run.
     * @param {PublicApiListPipelineJobsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineJobs(requestParameters: PublicApiListPipelineJobsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineJobs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.status, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List runs within a pipeline.
     * @param {PublicApiListPipelineRunsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineRuns(requestParameters: PublicApiListPipelineRunsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineRuns(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all pipeline runs within the Org. This can be filtered by app, pipeline, and status.
     * @param {PublicApiListPipelineRunsByOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineRunsByOrg(requestParameters: PublicApiListPipelineRunsByOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineRunsByOrg(requestParameters.orgId, requestParameters.app, requestParameters.pipeline, requestParameters.env, requestParameters.status, requestParameters.completed, requestParameters.createdAfter, requestParameters.createdBefore, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a page of log output for a given step within a job.
     * @param {PublicApiListPipelineStepLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineStepLogs(requestParameters: PublicApiListPipelineStepLogsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineStepLogs(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.jobId, requestParameters.stepIndex, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all versions of the pipeline
     * @param {PublicApiListPipelineVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelineVersions(requestParameters: PublicApiListPipelineVersionsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelineVersions(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Pipelines within an Application.
     * @param {PublicApiListPipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelines(requestParameters: PublicApiListPipelinesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelines(requestParameters.orgId, requestParameters.appId, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Pipelines within an Organization. This can be filtered by Application.
     * @param {PublicApiListPipelinesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPipelinesInOrg(requestParameters: PublicApiListPipelinesInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPipelinesInOrg(requestParameters.orgId, requestParameters.app, requestParameters.perPage, requestParameters.page, requestParameters.trigger, requestParameters.metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all public keys associated to an organization.
     * @param {PublicApiListPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listPublicKeys(requestParameters: PublicApiListPublicKeysRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listPublicKeys(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {PublicApiListResourceAccountTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listResourceAccountTypes(requestParameters: PublicApiListResourceAccountTypesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listResourceAccountTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {PublicApiListResourceAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listResourceAccounts(requestParameters: PublicApiListResourceAccountsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listResourceAccounts(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {PublicApiListResourceDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listResourceDefinitions(requestParameters: PublicApiListResourceDefinitionsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listResourceDefinitions(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, requestParameters._class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {PublicApiListResourceDriversRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listResourceDrivers(requestParameters: PublicApiListResourceDriversRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listResourceDrivers(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Types.
     * @param {PublicApiListResourceTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listResourceTypes(requestParameters: PublicApiListResourceTypesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listResourceTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific multiple environments.
     * @param {PublicApiListRuntimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listRuntime(requestParameters: PublicApiListRuntimeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an App
     * @param {PublicApiListUserRolesInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listUserRolesInApp(requestParameters: PublicApiListUserRolesInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listUserRolesInApp(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Environment Type
     * @param {PublicApiListUserRolesInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listUserRolesInEnvType(requestParameters: PublicApiListUserRolesInEnvTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listUserRolesInEnvType(requestParameters.orgId, requestParameters.envType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {PublicApiListUserRolesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listUserRolesInOrg(requestParameters: PublicApiListUserRolesInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listUserRolesInOrg(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists tokens associated with a user
     * @param {PublicApiListUserTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listUserTokens(requestParameters: PublicApiListUserTokensRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listUserTokens(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all Workload Profile Chart Versions for the given organization.
     * @summary Workload Profile Chart Versions for the given organization.
     * @param {PublicApiListWorkloadProfileChartVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWorkloadProfileChartVersions(requestParameters: PublicApiListWorkloadProfileChartVersionsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWorkloadProfileChartVersions(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.id, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profile features available to the organization.
     * @param {PublicApiListWorkloadProfileFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWorkloadProfileFeatures(requestParameters: PublicApiListWorkloadProfileFeaturesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWorkloadProfileFeatures(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile.
     * @param {PublicApiListWorkloadProfileVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWorkloadProfileVersions(requestParameters: PublicApiListWorkloadProfileVersionsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWorkloadProfileVersions(requestParameters.orgId, requestParameters.profileQid, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {PublicApiListWorkloadProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public listWorkloadProfiles(requestParameters: PublicApiListWorkloadProfilesRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).listWorkloadProfiles(requestParameters.orgId, requestParameters.deprecated, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Environment Version history.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Version history.
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {PublicApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEventsGet(requestParameters: PublicApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {PublicApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesGet(requestParameters: PublicApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {PublicApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesPost(requestParameters: PublicApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdDelete(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdPatch(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of Secret Stores for the given organization.
     * @param {PublicApiOrgsOrgIdSecretstoresGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdSecretstoresGet(requestParameters: PublicApiOrgsOrgIdSecretstoresGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdSecretstoresGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Secret Store for the given organization.
     * @param {PublicApiOrgsOrgIdSecretstoresPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdSecretstoresPost(requestParameters: PublicApiOrgsOrgIdSecretstoresPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdSecretstoresPost(requestParameters.orgId, requestParameters.createSecretStorePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the Secret Store.
     * @param {PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdSecretstoresStoreIdDelete(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdDelete(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Secret Store.
     * @param {PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdSecretstoresStoreIdGet(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdGet(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Secret Store.
     * @param {PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdSecretstoresStoreIdPatch(requestParameters: PublicApiOrgsOrgIdSecretstoresStoreIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdPatch(requestParameters.orgId, requestParameters.storeId, requestParameters.updateSecretStorePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the description of an Agent.
     * @param {PublicApiPatchAgentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchAgent(requestParameters: PublicApiPatchAgentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchAgent(requestParameters.orgId, requestParameters.agentId, requestParameters.agentPatchBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {PublicApiPatchArtefactVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchArtefactVersion(requestParameters: PublicApiPatchArtefactVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchArtefactVersion(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {PublicApiPatchReplicasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchReplicas(requestParameters: PublicApiPatchReplicasRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchReplicas(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {PublicApiPatchResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchResourceAccount(requestParameters: PublicApiPatchResourceAccountRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchResourceAccount(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {PublicApiPatchResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public patchResourceDefinition(requestParameters: PublicApiPatchResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).patchResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {PublicApiPutDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public putDelta(requestParameters: PublicApiPutDeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @param {PublicApiQueryResourceGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public queryResourceGraph(requestParameters: PublicApiQueryResourceGraphRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).queryResourceGraph(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {PublicApiRebaseEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public rebaseEnvironment(requestParameters: PublicApiRebaseEnvironmentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).rebaseEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to copy and restart the specified Run. The run must be in a completed state. 
     * @summary Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
     * @param {PublicApiRestartPipelineRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public restartPipelineRun(requestParameters: PublicApiRestartPipelineRunRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).restartPipelineRun(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.runId, requestParameters.idempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {PublicApiUpdateCurrentUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateCurrentUser(requestParameters: PublicApiUpdateCurrentUserRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateCurrentUser(requestParameters.userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific Environment in an Application.
     * @summary Update a specific Environment.
     * @param {PublicApiUpdateEnvironmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateEnvironment(requestParameters: PublicApiUpdateEnvironmentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateEnvironment(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.environmentBaseUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates Environment Type.
     * @summary Updates Environment Type
     * @param {PublicApiUpdateEnvironmentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateEnvironmentType(requestParameters: PublicApiUpdateEnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateEnvironmentType(requestParameters.orgId, requestParameters.envTypeId, requestParameters.updateEnvironmentTypePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {PublicApiUpdatePausedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updatePaused(requestParameters: PublicApiUpdatePausedRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updatePaused(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update a Pipeline within an Application.
     * @param {PublicApiUpdatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updatePipeline(requestParameters: PublicApiUpdatePipelineRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updatePipeline(requestParameters.orgId, requestParameters.appId, requestParameters.pipelineId, requestParameters.body, requestParameters.ifMatch, requestParameters.dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {PublicApiUpdateResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateResourceDefinition(requestParameters: PublicApiUpdateResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Update all Matching Criteria of a Resource Definition.
     * @param {PublicApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateResourceDefinitionCriteria(requestParameters: PublicApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {PublicApiUpdateResourceDriverRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateResourceDriver(requestParameters: PublicApiUpdateResourceDriverRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateResourceDriver(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Application
     * @param {PublicApiUpdateUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateUserRoleInApp(requestParameters: PublicApiUpdateUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Environment Type
     * @param {PublicApiUpdateUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateUserRoleInEnvType(requestParameters: PublicApiUpdateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Organization
     * @param {PublicApiUpdateUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateUserRoleInOrg(requestParameters: PublicApiUpdateUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateUserRoleInOrg(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Workload Profile
     * @param {PublicApiUpdateWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public updateWorkloadProfile(requestParameters: PublicApiUpdateWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).updateWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, requestParameters.workloadProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicKeysApi - axios parameter creator
 * @export
 */
export const PublicKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} body A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey: async (orgId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createPublicKey', 'orgId', orgId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createPublicKey', 'body', body)
            const localVarPath = `/orgs/{orgId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey: async (orgId: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deletePublicKey', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deletePublicKey', 'keyId', keyId)
            const localVarPath = `/orgs/{orgId}/keys/{keyId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (orgId: string, keyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getPublicKey', 'orgId', orgId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('getPublicKey', 'keyId', keyId)
            const localVarPath = `/orgs/{orgId}/keys/{keyId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} [fingerprint] The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys: async (orgId: string, fingerprint?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listPublicKeys', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/keys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicKeysApi - functional programming interface
 * @export
 */
export const PublicKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} body A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicKey(orgId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicKey(orgId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicKey(orgId: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicKey(orgId, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} keyId The public key ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(orgId: string, keyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(orgId, keyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {string} orgId The organization ID.
         * @param {string} [fingerprint] The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublicKeys(orgId: string, fingerprint?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicKeys(orgId, fingerprint, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicKeysApi - factory interface
 * @export
 */
export const PublicKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicKeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Associate a new RSA public key to an organization.
         * @param {PublicKeysApiCreatePublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicKey(requestParameters: PublicKeysApiCreatePublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.createPublicKey(requestParameters.orgId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a public key associated to an organization.
         * @param {PublicKeysApiDeletePublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicKey(requestParameters: PublicKeysApiDeletePublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a single public key associated to an organization.
         * @param {PublicKeysApiGetPublicKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(requestParameters: PublicKeysApiGetPublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.getPublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all public keys associated to an organization.
         * @param {PublicKeysApiListPublicKeysRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicKeys(requestParameters: PublicKeysApiListPublicKeysRequest, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>> {
            return localVarFp.listPublicKeys(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPublicKey operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiCreatePublicKeyRequest
 */
export interface PublicKeysApiCreatePublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicKeysApiCreatePublicKey
     */
    readonly orgId: string

    /**
     * A pcks8 RSA public key PEM encoded (as the ones produced by openssl), whose module length is greater or equal than 4096 bits. It should be provided as a single line. This might be accomplished through the usage of &#x60;awk&#x60; bash tool: &#x60;awk -v ORS&#x3D;\&#39;\\n\&#39; \&#39;1\&#39; public_key.pem&#x60;
     * @type {string}
     * @memberof PublicKeysApiCreatePublicKey
     */
    readonly body: string
}

/**
 * Request parameters for deletePublicKey operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiDeletePublicKeyRequest
 */
export interface PublicKeysApiDeletePublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicKeysApiDeletePublicKey
     */
    readonly orgId: string

    /**
     * The public key ID.
     * @type {string}
     * @memberof PublicKeysApiDeletePublicKey
     */
    readonly keyId: string
}

/**
 * Request parameters for getPublicKey operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiGetPublicKeyRequest
 */
export interface PublicKeysApiGetPublicKeyRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicKeysApiGetPublicKey
     */
    readonly orgId: string

    /**
     * The public key ID.
     * @type {string}
     * @memberof PublicKeysApiGetPublicKey
     */
    readonly keyId: string
}

/**
 * Request parameters for listPublicKeys operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiListPublicKeysRequest
 */
export interface PublicKeysApiListPublicKeysRequest {
    /**
     * The organization ID.
     * @type {string}
     * @memberof PublicKeysApiListPublicKeys
     */
    readonly orgId: string

    /**
     * The fingerprint (the hexadecimal representation of the sha256 hash of the DER representation of the key) of the requested key. If a value is provided, the result will contain a single key, if any.
     * @type {string}
     * @memberof PublicKeysApiListPublicKeys
     */
    readonly fingerprint?: string
}

/**
 * PublicKeysApi - object-oriented interface
 * @export
 * @class PublicKeysApi
 * @extends {BaseAPI}
 */
export class PublicKeysApi extends BaseAPI {
    /**
     * 
     * @summary Associate a new RSA public key to an organization.
     * @param {PublicKeysApiCreatePublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public createPublicKey(requestParameters: PublicKeysApiCreatePublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).createPublicKey(requestParameters.orgId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a public key associated to an organization.
     * @param {PublicKeysApiDeletePublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public deletePublicKey(requestParameters: PublicKeysApiDeletePublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).deletePublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a single public key associated to an organization.
     * @param {PublicKeysApiGetPublicKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public getPublicKey(requestParameters: PublicKeysApiGetPublicKeyRequest, options?: AxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).getPublicKey(requestParameters.orgId, requestParameters.keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all public keys associated to an organization.
     * @param {PublicKeysApiListPublicKeysRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public listPublicKeys(requestParameters: PublicKeysApiListPublicKeysRequest, options?: AxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).listPublicKeys(requestParameters.orgId, requestParameters.fingerprint, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {RegistryApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(requestParameters: RegistryApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {RegistryApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(requestParameters: RegistryApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdRegistriesGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesPost operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesPostRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesPostRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesPost
     */
    readonly orgId: string

    /**
     * A new record details.  
     * @type {RegistryRequest}
     * @memberof RegistryApiOrgsOrgIdRegistriesPost
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdCredsGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdDelete operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdPatch operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly regId: string

    /**
     * Record details to update.  
     * @type {RegistryRequest}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly registryRequest: RegistryRequest
}

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {RegistryApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesGet(requestParameters: RegistryApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {RegistryApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesPost(requestParameters: RegistryApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdDelete(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdPatch(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReplicasApi - axios parameter creator
 * @export
 */
export const ReplicasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReplicas: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchReplicas', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('patchReplicas', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('patchReplicas', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('patchReplicas', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReplicasApi - functional programming interface
 * @export
 */
export const ReplicasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReplicasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchReplicas(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchReplicas(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReplicasApi - factory interface
 * @export
 */
export const ReplicasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReplicasApiFp(configuration)
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {ReplicasApiPatchReplicasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchReplicas(requestParameters: ReplicasApiPatchReplicasRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchReplicas(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for patchReplicas operation in ReplicasApi.
 * @export
 * @interface ReplicasApiPatchReplicasRequest
 */
export interface ReplicasApiPatchReplicasRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof ReplicasApiPatchReplicas
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof ReplicasApiPatchReplicas
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof ReplicasApiPatchReplicas
     */
    readonly envId: string

    /**
     * map of replicas by modules.
     * @type {{ [key: string]: number; }}
     * @memberof ReplicasApiPatchReplicas
     */
    readonly requestBody: { [key: string]: number; }
}

/**
 * ReplicasApi - object-oriented interface
 * @export
 * @class ReplicasApi
 * @extends {BaseAPI}
 */
export class ReplicasApi extends BaseAPI {
    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {ReplicasApiPatchReplicasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReplicasApi
     */
    public patchReplicas(requestParameters: ReplicasApiPatchReplicasRequest, options?: AxiosRequestConfig) {
        return ReplicasApiFp(this.configuration).patchReplicas(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceAccountApi - axios parameter creator
 * @export
 */
export const ResourceAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceAccount: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceAccount', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('createResourceAccount', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceAccount: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('deleteResourceAccount', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceAccount: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('getResourceAccount', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccounts: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceAccounts', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceAccount: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchResourceAccount', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('patchResourceAccount', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('patchResourceAccount', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceAccountApi - functional programming interface
 * @export
 */
export const ResourceAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceAccount(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAccount(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceAccount(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAccount(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceAccount(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAccount(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceAccounts(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAccounts(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchResourceAccount(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchResourceAccount(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceAccountApi - factory interface
 * @export
 */
export const ResourceAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {ResourceAccountApiCreateResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceAccount(requestParameters: ResourceAccountApiCreateResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.createResourceAccount(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {ResourceAccountApiDeleteResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceAccount(requestParameters: ResourceAccountApiDeleteResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {ResourceAccountApiGetResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceAccount(requestParameters: ResourceAccountApiGetResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.getResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {ResourceAccountApiListResourceAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceAccounts(requestParameters: ResourceAccountApiListResourceAccountsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.listResourceAccounts(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {ResourceAccountApiPatchResourceAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceAccount(requestParameters: ResourceAccountApiPatchResourceAccountRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.patchResourceAccount(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourceAccount operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiCreateResourceAccountRequest
 */
export interface ResourceAccountApiCreateResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiCreateResourceAccount
     */
    readonly orgId: string

    /**
     * 
     * @type {CreateResourceAccountRequestRequest}
     * @memberof ResourceAccountApiCreateResourceAccount
     */
    readonly createResourceAccountRequestRequest: CreateResourceAccountRequestRequest
}

/**
 * Request parameters for deleteResourceAccount operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiDeleteResourceAccountRequest
 */
export interface ResourceAccountApiDeleteResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiDeleteResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiDeleteResourceAccount
     */
    readonly accId: string
}

/**
 * Request parameters for getResourceAccount operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiGetResourceAccountRequest
 */
export interface ResourceAccountApiGetResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiGetResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiGetResourceAccount
     */
    readonly accId: string
}

/**
 * Request parameters for listResourceAccounts operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiListResourceAccountsRequest
 */
export interface ResourceAccountApiListResourceAccountsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiListResourceAccounts
     */
    readonly orgId: string
}

/**
 * Request parameters for patchResourceAccount operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiPatchResourceAccountRequest
 */
export interface ResourceAccountApiPatchResourceAccountRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiPatchResourceAccount
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiPatchResourceAccount
     */
    readonly accId: string

    /**
     * 
     * @type {UpdateResourceAccountRequestRequest}
     * @memberof ResourceAccountApiPatchResourceAccount
     */
    readonly updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest
}

/**
 * ResourceAccountApi - object-oriented interface
 * @export
 * @class ResourceAccountApi
 * @extends {BaseAPI}
 */
export class ResourceAccountApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {ResourceAccountApiCreateResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public createResourceAccount(requestParameters: ResourceAccountApiCreateResourceAccountRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).createResourceAccount(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an unused Resource Account.
     * @param {ResourceAccountApiDeleteResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public deleteResourceAccount(requestParameters: ResourceAccountApiDeleteResourceAccountRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).deleteResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {ResourceAccountApiGetResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public getResourceAccount(requestParameters: ResourceAccountApiGetResourceAccountRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).getResourceAccount(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {ResourceAccountApiListResourceAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public listResourceAccounts(requestParameters: ResourceAccountApiListResourceAccountsRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).listResourceAccounts(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {ResourceAccountApiPatchResourceAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public patchResourceAccount(requestParameters: ResourceAccountApiPatchResourceAccountRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).patchResourceAccount(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceDefinitionApi - axios parameter creator
 * @export
 */
export const ResourceDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinition: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDefinition', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('createResourceDefinition', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('createResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinition: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('deleteResourceDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('deleteResourceDefinitionCriteria', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDefinition: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('getResourceDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('listActiveResourceByDefinition', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {string} [_class] (Optional) Filter Resource Definitions that may match a specific Class.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDefinitions: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, _class?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceDefinitions', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }

            if (_class !== undefined) {
                localVarQueryParameter['class'] = _class;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceDefinition: async (orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('patchResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('patchResourceDefinition', 'defId', defId)
            // verify required parameter 'patchResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('patchResourceDefinition', 'patchResourceDefinitionRequestRequest', patchResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinition: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDefinition', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('updateResourceDefinition', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('updateResourceDefinition', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria: async (orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('updateResourceDefinitionCriteria', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceDefinitionApi - functional programming interface
 * @export
 */
export const ResourceDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDefinition(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDefinition(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDefinition(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDefinition(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceDefinitionCriteria(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceDefinitionCriteria(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceDefinition(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceDefinition(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveResourceByDefinition(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveResourceByDefinition(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {string} [_class] (Optional) Filter Resource Definitions that may match a specific Class.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceDefinitions(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, _class?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceDefinitions(orgId, app, env, envType, res, resType, _class, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchResourceDefinition(orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchResourceDefinition(orgId, defId, patchResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDefinition(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDefinition(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {Array<MatchingCriteriaRuleRequest>} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceDefinitionCriteria(orgId: string, defId: string, matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchingCriteriaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceDefinitionCriteria(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceDefinitionApi - factory interface
 * @export
 */
export const ResourceDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {ResourceDefinitionApiCreateResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinition(requestParameters: ResourceDefinitionApiCreateResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.createResourceDefinition(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {ResourceDefinitionApiDeleteResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinition(requestParameters: ResourceDefinitionApiDeleteResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {ResourceDefinitionApiGetResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDefinition(requestParameters: ResourceDefinitionApiGetResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.getResourceDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {ResourceDefinitionApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveResourceByDefinition(requestParameters: ResourceDefinitionApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {ResourceDefinitionApiListResourceDefinitionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceDefinitions(requestParameters: ResourceDefinitionApiListResourceDefinitionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.listResourceDefinitions(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, requestParameters._class, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {ResourceDefinitionApiPatchResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchResourceDefinition(requestParameters: ResourceDefinitionApiPatchResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.patchResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {ResourceDefinitionApiUpdateResourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinition(requestParameters: ResourceDefinitionApiUpdateResourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.updateResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
         * @summary Update all Matching Criteria of a Resource Definition.
         * @param {ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig): AxiosPromise<Array<MatchingCriteriaResponse>> {
            return localVarFp.updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createResourceDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiCreateResourceDefinitionRequest
 */
export interface ResourceDefinitionApiCreateResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiCreateResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition details.  
     * @type {CreateResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiCreateResourceDefinition
     */
    readonly createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest
}

/**
 * Request parameters for createResourceDefinitionCriteria operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest
 */
export interface ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiCreateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiCreateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof ResourceDefinitionApiCreateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * Request parameters for deleteResourceDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiDeleteResourceDefinitionRequest
 */
export interface ResourceDefinitionApiDeleteResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiDeleteResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiDeleteResourceDefinition
     */
    readonly defId: string

    /**
     * If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @type {boolean}
     * @memberof ResourceDefinitionApiDeleteResourceDefinition
     */
    readonly force?: boolean
}

/**
 * Request parameters for deleteResourceDefinitionCriteria operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest
 */
export interface ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiDeleteResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiDeleteResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiDeleteResourceDefinitionCriteria
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof ResourceDefinitionApiDeleteResourceDefinitionCriteria
     */
    readonly force?: boolean
}

/**
 * Request parameters for getResourceDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiGetResourceDefinitionRequest
 */
export interface ResourceDefinitionApiGetResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiGetResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiGetResourceDefinition
     */
    readonly defId: string
}

/**
 * Request parameters for listActiveResourceByDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiListActiveResourceByDefinitionRequest
 */
export interface ResourceDefinitionApiListActiveResourceByDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiListActiveResourceByDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiListActiveResourceByDefinition
     */
    readonly defId: string
}

/**
 * Request parameters for listResourceDefinitions operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiListResourceDefinitionsRequest
 */
export interface ResourceDefinitionApiListResourceDefinitionsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly orgId: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Application.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly app?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly env?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly envType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly res?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly resType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Class.  
     * @type {string}
     * @memberof ResourceDefinitionApiListResourceDefinitions
     */
    readonly _class?: string
}

/**
 * Request parameters for patchResourceDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiPatchResourceDefinitionRequest
 */
export interface ResourceDefinitionApiPatchResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiPatchResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiPatchResourceDefinition
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @type {PatchResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiPatchResourceDefinition
     */
    readonly patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest
}

/**
 * Request parameters for updateResourceDefinition operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiUpdateResourceDefinitionRequest
 */
export interface ResourceDefinitionApiUpdateResourceDefinitionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiUpdateResourceDefinition
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiUpdateResourceDefinition
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
     * @type {UpdateResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiUpdateResourceDefinition
     */
    readonly updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest
}

/**
 * Request parameters for updateResourceDefinitionCriteria operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest
 */
export interface ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiUpdateResourceDefinitionCriteria
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiUpdateResourceDefinitionCriteria
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {Array<MatchingCriteriaRuleRequest>}
     * @memberof ResourceDefinitionApiUpdateResourceDefinitionCriteria
     */
    readonly matchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>
}

/**
 * ResourceDefinitionApi - object-oriented interface
 * @export
 * @class ResourceDefinitionApi
 * @extends {BaseAPI}
 */
export class ResourceDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {ResourceDefinitionApiCreateResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public createResourceDefinition(requestParameters: ResourceDefinitionApiCreateResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).createResourceDefinition(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public createResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiCreateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).createResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {ResourceDefinitionApiDeleteResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public deleteResourceDefinition(requestParameters: ResourceDefinitionApiDeleteResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).deleteResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public deleteResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiDeleteResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).deleteResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {ResourceDefinitionApiGetResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public getResourceDefinition(requestParameters: ResourceDefinitionApiGetResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).getResourceDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {ResourceDefinitionApiListActiveResourceByDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public listActiveResourceByDefinition(requestParameters: ResourceDefinitionApiListActiveResourceByDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).listActiveResourceByDefinition(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {ResourceDefinitionApiListResourceDefinitionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public listResourceDefinitions(requestParameters: ResourceDefinitionApiListResourceDefinitionsRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).listResourceDefinitions(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, requestParameters._class, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {ResourceDefinitionApiPatchResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public patchResourceDefinition(requestParameters: ResourceDefinitionApiPatchResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).patchResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {ResourceDefinitionApiUpdateResourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public updateResourceDefinition(requestParameters: ResourceDefinitionApiUpdateResourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).updateResourceDefinition(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * @summary Update all Matching Criteria of a Resource Definition.
     * @param {ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public updateResourceDefinitionCriteria(requestParameters: ResourceDefinitionApiUpdateResourceDefinitionCriteriaRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).updateResourceDefinitionCriteria(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceProvisionApi - axios parameter creator
 * @export
 */
export const ResourceProvisionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResourceGraph: async (orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('queryResourceGraph', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('queryResourceGraph', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('queryResourceGraph', 'envId', envId)
            // verify required parameter 'resourceProvisionRequestRequest' is not null or undefined
            assertParamExists('queryResourceGraph', 'resourceProvisionRequestRequest', resourceProvisionRequestRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graph`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceProvisionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceProvisionApi - functional programming interface
 * @export
 */
export const ResourceProvisionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceProvisionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryResourceGraph(orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeBodyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryResourceGraph(orgId, appId, envId, resourceProvisionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceProvisionApi - factory interface
 * @export
 */
export const ResourceProvisionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceProvisionApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {ResourceProvisionApiQueryResourceGraphRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryResourceGraph(requestParameters: ResourceProvisionApiQueryResourceGraphRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeBodyResponse>> {
            return localVarFp.queryResourceGraph(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for queryResourceGraph operation in ResourceProvisionApi.
 * @export
 * @interface ResourceProvisionApiQueryResourceGraphRequest
 */
export interface ResourceProvisionApiQueryResourceGraphRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceProvisionApiQueryResourceGraph
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ResourceProvisionApiQueryResourceGraph
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ResourceProvisionApiQueryResourceGraph
     */
    readonly envId: string

    /**
     * Resources to provision.  
     * @type {Array<ResourceProvisionRequestRequest>}
     * @memberof ResourceProvisionApiQueryResourceGraph
     */
    readonly resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>
}

/**
 * ResourceProvisionApi - object-oriented interface
 * @export
 * @class ResourceProvisionApi
 * @extends {BaseAPI}
 */
export class ResourceProvisionApi extends BaseAPI {
    /**
     * 
     * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @param {ResourceProvisionApiQueryResourceGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceProvisionApi
     */
    public queryResourceGraph(requestParameters: ResourceProvisionApiQueryResourceGraphRequest, options?: AxiosRequestConfig) {
        return ResourceProvisionApiFp(this.configuration).queryResourceGraph(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceTypeApi - axios parameter creator
 * @export
 */
export const ResourceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceTypes: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listResourceTypes', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceTypeApi - functional programming interface
 * @export
 */
export const ResourceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourceTypes(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceTypes(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceTypeApi - factory interface
 * @export
 */
export const ResourceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {ResourceTypeApiListResourceTypesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourceTypes(requestParameters: ResourceTypeApiListResourceTypesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.listResourceTypes(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listResourceTypes operation in ResourceTypeApi.
 * @export
 * @interface ResourceTypeApiListResourceTypesRequest
 */
export interface ResourceTypeApiListResourceTypesRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceTypeApiListResourceTypes
     */
    readonly orgId: string
}

/**
 * ResourceTypeApi - object-oriented interface
 * @export
 * @class ResourceTypeApi
 * @extends {BaseAPI}
 */
export class ResourceTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Types.
     * @param {ResourceTypeApiListResourceTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypeApi
     */
    public listResourceTypes(requestParameters: ResourceTypeApiListResourceTypesRequest, options?: AxiosRequestConfig) {
        return ResourceTypeApiFp(this.configuration).listResourceTypes(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuntimeInfoApi - axios parameter creator
 * @export
 */
export const RuntimeInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntime: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getRuntime', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getRuntime', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getRuntime', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {Array<string>} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuntime: async (orgId: string, appId: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listRuntime', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listRuntime', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuntimeInfoApi - functional programming interface
 * @export
 */
export const RuntimeInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuntimeInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} envId The Environment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRuntime(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponseV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRuntime(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {Array<string>} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuntime(orgId: string, appId: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuntime(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuntimeInfoApi - factory interface
 * @export
 */
export const RuntimeInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuntimeInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {RuntimeInfoApiGetRuntimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntime(requestParameters: RuntimeInfoApiGetRuntimeRequest, options?: AxiosRequestConfig): AxiosPromise<RuntimeInfoResponseV1> {
            return localVarFp.getRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific multiple environments.
         * @param {RuntimeInfoApiListRuntimeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuntime(requestParameters: RuntimeInfoApiListRuntimeRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.listRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getRuntime operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiGetRuntimeRequest
 */
export interface RuntimeInfoApiGetRuntimeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof RuntimeInfoApiGetRuntime
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof RuntimeInfoApiGetRuntime
     */
    readonly appId: string

    /**
     * The Environment ID
     * @type {string}
     * @memberof RuntimeInfoApiGetRuntime
     */
    readonly envId: string
}

/**
 * Request parameters for listRuntime operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiListRuntimeRequest
 */
export interface RuntimeInfoApiListRuntimeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof RuntimeInfoApiListRuntime
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof RuntimeInfoApiListRuntime
     */
    readonly appId: string

    /**
     * Filter environments by ID (required). Up to 5 ids can be supplied per request.
     * @type {Array<string>}
     * @memberof RuntimeInfoApiListRuntime
     */
    readonly id?: Array<string>
}

/**
 * RuntimeInfoApi - object-oriented interface
 * @export
 * @class RuntimeInfoApi
 * @extends {BaseAPI}
 */
export class RuntimeInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {RuntimeInfoApiGetRuntimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public getRuntime(requestParameters: RuntimeInfoApiGetRuntimeRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).getRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific multiple environments.
     * @param {RuntimeInfoApiListRuntimeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public listRuntime(requestParameters: RuntimeInfoApiListRuntimeRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).listRuntime(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecretStoreApi - axios parameter creator
 * @export
 */
export const SecretStoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/secretstores`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateSecretStorePayloadRequest} createSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresPost: async (orgId: string, createSecretStorePayloadRequest: CreateSecretStorePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresPost', 'orgId', orgId)
            // verify required parameter 'createSecretStorePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresPost', 'createSecretStorePayloadRequest', createSecretStorePayloadRequest)
            const localVarPath = `/orgs/{orgId}/secretstores`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSecretStorePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdDelete: async (orgId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdDelete', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdDelete', 'storeId', storeId)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdGet: async (orgId: string, storeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdGet', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdGet', 'storeId', storeId)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {UpdateSecretStorePayloadRequest} updateSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdPatch: async (orgId: string, storeId: string, updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'orgId', orgId)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'storeId', storeId)
            // verify required parameter 'updateSecretStorePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdSecretstoresStoreIdPatch', 'updateSecretStorePayloadRequest', updateSecretStorePayloadRequest)
            const localVarPath = `/orgs/{orgId}/secretstores/{storeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"storeId"}}`, encodeURIComponent(String(storeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSecretStorePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretStoreApi - functional programming interface
 * @export
 */
export const SecretStoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretStoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecretStoreResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateSecretStorePayloadRequest} createSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresPost(orgId: string, createSecretStorePayloadRequest: CreateSecretStorePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresPost(orgId, createSecretStorePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdDelete(orgId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdDelete(orgId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdGet(orgId: string, storeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdGet(orgId, storeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {string} orgId The Organization ID.  
         * @param {string} storeId The Secret Store ID.  
         * @param {UpdateSecretStorePayloadRequest} updateSecretStorePayloadRequest Secret Store data.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdSecretstoresStoreIdPatch(orgId: string, storeId: string, updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdSecretstoresStoreIdPatch(orgId, storeId, updateSecretStorePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecretStoreApi - factory interface
 * @export
 */
export const SecretStoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretStoreApiFp(configuration)
    return {
        /**
         * 
         * @summary Get list of Secret Stores for the given organization.
         * @param {SecretStoreApiOrgsOrgIdSecretstoresGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresGet(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SecretStoreResponse>> {
            return localVarFp.orgsOrgIdSecretstoresGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Secret Store for the given organization.
         * @param {SecretStoreApiOrgsOrgIdSecretstoresPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresPost(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresPostRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresPost(requestParameters.orgId, requestParameters.createSecretStorePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the Secret Store.
         * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdDelete(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdDelete(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Secret Store.
         * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdGet(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdGet(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Secret Store.
         * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdSecretstoresStoreIdPatch(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<SecretStoreResponse> {
            return localVarFp.orgsOrgIdSecretstoresStoreIdPatch(requestParameters.orgId, requestParameters.storeId, requestParameters.updateSecretStorePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdSecretstoresGet operation in SecretStoreApi.
 * @export
 * @interface SecretStoreApiOrgsOrgIdSecretstoresGetRequest
 */
export interface SecretStoreApiOrgsOrgIdSecretstoresGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresPost operation in SecretStoreApi.
 * @export
 * @interface SecretStoreApiOrgsOrgIdSecretstoresPostRequest
 */
export interface SecretStoreApiOrgsOrgIdSecretstoresPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresPost
     */
    readonly orgId: string

    /**
     * Secret Store data.  
     * @type {CreateSecretStorePayloadRequest}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresPost
     */
    readonly createSecretStorePayloadRequest: CreateSecretStorePayloadRequest
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdDelete operation in SecretStoreApi.
 * @export
 * @interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest
 */
export interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdDelete
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdDelete
     */
    readonly storeId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdGet operation in SecretStoreApi.
 * @export
 * @interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest
 */
export interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdGet
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdGet
     */
    readonly storeId: string
}

/**
 * Request parameters for orgsOrgIdSecretstoresStoreIdPatch operation in SecretStoreApi.
 * @export
 * @interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest
 */
export interface SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly orgId: string

    /**
     * The Secret Store ID.  
     * @type {string}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly storeId: string

    /**
     * Secret Store data.  
     * @type {UpdateSecretStorePayloadRequest}
     * @memberof SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatch
     */
    readonly updateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest
}

/**
 * SecretStoreApi - object-oriented interface
 * @export
 * @class SecretStoreApi
 * @extends {BaseAPI}
 */
export class SecretStoreApi extends BaseAPI {
    /**
     * 
     * @summary Get list of Secret Stores for the given organization.
     * @param {SecretStoreApiOrgsOrgIdSecretstoresGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretStoreApi
     */
    public orgsOrgIdSecretstoresGet(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresGetRequest, options?: AxiosRequestConfig) {
        return SecretStoreApiFp(this.configuration).orgsOrgIdSecretstoresGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Secret Store for the given organization.
     * @param {SecretStoreApiOrgsOrgIdSecretstoresPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretStoreApi
     */
    public orgsOrgIdSecretstoresPost(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresPostRequest, options?: AxiosRequestConfig) {
        return SecretStoreApiFp(this.configuration).orgsOrgIdSecretstoresPost(requestParameters.orgId, requestParameters.createSecretStorePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the Secret Store.
     * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretStoreApi
     */
    public orgsOrgIdSecretstoresStoreIdDelete(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdDeleteRequest, options?: AxiosRequestConfig) {
        return SecretStoreApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdDelete(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Secret Store.
     * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretStoreApi
     */
    public orgsOrgIdSecretstoresStoreIdGet(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdGetRequest, options?: AxiosRequestConfig) {
        return SecretStoreApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdGet(requestParameters.orgId, requestParameters.storeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Secret Store.
     * @param {SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretStoreApi
     */
    public orgsOrgIdSecretstoresStoreIdPatch(requestParameters: SecretStoreApiOrgsOrgIdSecretstoresStoreIdPatchRequest, options?: AxiosRequestConfig) {
        return SecretStoreApiFp(this.configuration).orgsOrgIdSecretstoresStoreIdPatch(requestParameters.orgId, requestParameters.storeId, requestParameters.updateSecretStorePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetApi - axios parameter creator
 * @export
 */
export const SetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSets', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSets', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, diff?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetApi - functional programming interface
 * @export
 */
export const SetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSets(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSets(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainDeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, diff?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, diff, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetApi - factory interface
 * @export
 */
export const SetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {SetApiGetSetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets(requestParameters: SetApiGetSetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SetResponse>> {
            return localVarFp.getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlainDeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSets operation in SetApi.
 * @export
 * @interface SetApiGetSetsRequest
 */
export interface SetApiGetSetsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof SetApiGetSets
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof SetApiGetSets
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to diff against.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly sourceSetId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdGet operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to compared against.
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly diff?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdPost operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly orgId: string

    /**
     * The Application ID
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly setId: string

    /**
     * The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @type {DeltaRequest}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * SetApi - object-oriented interface
 * @export
 * @class SetApi
 * @extends {BaseAPI}
 */
export class SetApi extends BaseAPI {
    /**
     * 
     * @summary Get all Deployment Sets
     * @param {SetApiGetSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public getSets(requestParameters: SetApiGetSetsRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenInfoApi - axios parameter creator
 * @export
 */
export const TokenInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserToken: async (userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createUserToken', 'userId', userId)
            // verify required parameter 'tokenDefinitionRequest' is not null or undefined
            assertParamExists('createUserToken', 'tokenDefinitionRequest', tokenDefinitionRequest)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserToken: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteUserToken', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserToken', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('getUserToken', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTokens: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserTokens', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenInfoApi - functional programming interface
 * @export
 */
export const TokenInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserToken(userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserToken(userId, tokenDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserToken(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserToken(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserToken(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserTokens(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserTokens(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenInfoApi - factory interface
 * @export
 */
export const TokenInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenInfoApiFp(configuration)
    return {
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {TokenInfoApiCreateUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserToken(requestParameters: TokenInfoApiCreateUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.createUserToken(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
         * @summary Deletes a specific token associated with a user
         * @param {TokenInfoApiDeleteUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserToken(requestParameters: TokenInfoApiDeleteUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {TokenInfoApiGetUserTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserToken(requestParameters: TokenInfoApiGetUserTokenRequest, options?: AxiosRequestConfig): AxiosPromise<TokenInfoResponse> {
            return localVarFp.getUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {TokenInfoApiListUserTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTokens(requestParameters: TokenInfoApiListUserTokensRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TokenInfoResponse>> {
            return localVarFp.listUserTokens(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createUserToken operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiCreateUserTokenRequest
 */
export interface TokenInfoApiCreateUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiCreateUserToken
     */
    readonly userId: string

    /**
     * The definition of the token.  
     * @type {TokenDefinitionRequest}
     * @memberof TokenInfoApiCreateUserToken
     */
    readonly tokenDefinitionRequest: TokenDefinitionRequest
}

/**
 * Request parameters for deleteUserToken operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiDeleteUserTokenRequest
 */
export interface TokenInfoApiDeleteUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiDeleteUserToken
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof TokenInfoApiDeleteUserToken
     */
    readonly tokenId: string
}

/**
 * Request parameters for getUserToken operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiGetUserTokenRequest
 */
export interface TokenInfoApiGetUserTokenRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiGetUserToken
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof TokenInfoApiGetUserToken
     */
    readonly tokenId: string
}

/**
 * Request parameters for listUserTokens operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiListUserTokensRequest
 */
export interface TokenInfoApiListUserTokensRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiListUserTokens
     */
    readonly userId: string
}

/**
 * TokenInfoApi - object-oriented interface
 * @export
 * @class TokenInfoApi
 * @extends {BaseAPI}
 */
export class TokenInfoApi extends BaseAPI {
    /**
     * This is only supported for users of type `service`.
     * @summary Creates a new static token for a user.
     * @param {TokenInfoApiCreateUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public createUserToken(requestParameters: TokenInfoApiCreateUserTokenRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).createUserToken(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
     * @summary Deletes a specific token associated with a user
     * @param {TokenInfoApiDeleteUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public deleteUserToken(requestParameters: TokenInfoApiDeleteUserTokenRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).deleteUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific token associated with a user
     * @param {TokenInfoApiGetUserTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public getUserToken(requestParameters: TokenInfoApiGetUserTokenRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).getUserToken(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists tokens associated with a user
     * @param {TokenInfoApiListUserTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public listUserTokens(requestParameters: TokenInfoApiListUserTokensRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).listUserTokens(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserInviteApi - axios parameter creator
 * @export
 */
export const UserInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesInOrg: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listInvitesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInviteApi - functional programming interface
 * @export
 */
export const UserInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvitesInOrg(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvitesInOrg(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserInviteApi - factory interface
 * @export
 */
export const UserInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInviteApiFp(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {UserInviteApiListInvitesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvitesInOrg(requestParameters: UserInviteApiListInvitesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.listInvitesInOrg(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listInvitesInOrg operation in UserInviteApi.
 * @export
 * @interface UserInviteApiListInvitesInOrgRequest
 */
export interface UserInviteApiListInvitesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserInviteApiListInvitesInOrg
     */
    readonly orgId: string
}

/**
 * UserInviteApi - object-oriented interface
 * @export
 * @class UserInviteApi
 * @extends {BaseAPI}
 */
export class UserInviteApi extends BaseAPI {
    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {UserInviteApiListInvitesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInviteApi
     */
    public listInvitesInOrg(requestParameters: UserInviteApiListInvitesInOrgRequest, options?: AxiosRequestConfig) {
        return UserInviteApiFp(this.configuration).listInvitesInOrg(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID
         * @param {NewServiceUserRequest} newServiceUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceUserInOrg: async (orgId: string, newServiceUserRequest: NewServiceUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createServiceUserInOrg', 'orgId', orgId)
            // verify required parameter 'newServiceUserRequest' is not null or undefined
            assertParamExists('createServiceUserInOrg', 'newServiceUserRequest', newServiceUserRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newServiceUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('updateCurrentUser', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID
         * @param {NewServiceUserRequest} newServiceUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceUserInOrg(orgId: string, newServiceUserRequest: NewServiceUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceUserInOrg(orgId, newServiceUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentUser(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentUser(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {UserProfileApiCreateServiceUserInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceUserInOrg(requestParameters: UserProfileApiCreateServiceUserInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.createServiceUserInOrg(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileApiUpdateCurrentUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentUser(requestParameters: UserProfileApiUpdateCurrentUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.updateCurrentUser(requestParameters.userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createServiceUserInOrg operation in UserProfileApi.
 * @export
 * @interface UserProfileApiCreateServiceUserInOrgRequest
 */
export interface UserProfileApiCreateServiceUserInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserProfileApiCreateServiceUserInOrg
     */
    readonly orgId: string

    /**
     * 
     * @type {NewServiceUserRequest}
     * @memberof UserProfileApiCreateServiceUserInOrg
     */
    readonly newServiceUserRequest: NewServiceUserRequest
}

/**
 * Request parameters for updateCurrentUser operation in UserProfileApi.
 * @export
 * @interface UserProfileApiUpdateCurrentUserRequest
 */
export interface UserProfileApiUpdateCurrentUserRequest {
    /**
     * 
     * @type {UserProfileExtendedRequest}
     * @memberof UserProfileApiUpdateCurrentUser
     */
    readonly userProfileExtendedRequest: UserProfileExtendedRequest
}

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new service user.
     * @param {UserProfileApiCreateServiceUserInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public createServiceUserInOrg(requestParameters: UserProfileApiCreateServiceUserInOrgRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).createServiceUserInOrg(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileApiUpdateCurrentUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public updateCurrentUser(requestParameters: UserProfileApiUpdateCurrentUserRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).updateCurrentUser(requestParameters.userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRoleApi - axios parameter creator
 * @export
 */
export const UserRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteInOrg: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createInviteInOrg', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('createInviteInOrg', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInApp: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('createUserRoleInApp', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('createUserRoleInApp', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInEnvType: async (orgId: string, envType: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('createUserRoleInEnvType', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInApp: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInApp', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInEnvType: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInEnvType', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInOrg: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserRoleInOrg', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInApp: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInApp', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInEnvType: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInEnvType', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInOrg: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserRoleInOrg', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInApp: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('listUserRolesInApp', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInEnvType: async (orgId: string, envType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('listUserRolesInEnvType', 'envType', envType)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInOrg: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listUserRolesInOrg', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInApp: async (orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInApp', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInEnvType: async (orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInEnvType', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInOrg: async (orgId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('updateUserRoleInOrg', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRoleApi - functional programming interface
 * @export
 */
export const UserRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteInOrg(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteInOrg(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserRoleInApp(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRoleInApp(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserRoleInEnvType(orgId: string, envType: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserRoleInEnvType(orgId, envType, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInApp(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInApp(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInEnvType(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInEnvType(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserRoleInOrg(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserRoleInOrg(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInApp(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInApp(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInEnvType(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInEnvType(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserRoleInOrg(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserRoleInOrg(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInApp(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInApp(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInEnvType(orgId: string, envType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInEnvType(orgId, envType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRolesInOrg(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRolesInOrg(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInApp(orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInApp(orgId, appId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInEnvType(orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInEnvType(orgId, envType, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRoleInOrg(orgId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRoleInOrg(orgId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRoleApi - factory interface
 * @export
 */
export const UserRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRoleApiFp(configuration)
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {UserRoleApiCreateInviteInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteInOrg(requestParameters: UserRoleApiCreateInviteInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.createInviteInOrg(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {UserRoleApiCreateUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInApp(requestParameters: UserRoleApiCreateUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.createUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {UserRoleApiCreateUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserRoleInEnvType(requestParameters: UserRoleApiCreateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.createUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {UserRoleApiDeleteUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInApp(requestParameters: UserRoleApiDeleteUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {UserRoleApiDeleteUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInEnvType(requestParameters: UserRoleApiDeleteUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {UserRoleApiDeleteUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserRoleInOrg(requestParameters: UserRoleApiDeleteUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {UserRoleApiGetUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInApp(requestParameters: UserRoleApiGetUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {UserRoleApiGetUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInEnvType(requestParameters: UserRoleApiGetUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {UserRoleApiGetUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoleInOrg(requestParameters: UserRoleApiGetUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.getUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {UserRoleApiListUserRolesInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInApp(requestParameters: UserRoleApiListUserRolesInAppRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInApp(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Environment Type
         * @param {UserRoleApiListUserRolesInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInEnvType(requestParameters: UserRoleApiListUserRolesInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInEnvType(requestParameters.orgId, requestParameters.envType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {UserRoleApiListUserRolesInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRolesInOrg(requestParameters: UserRoleApiListUserRolesInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.listUserRolesInOrg(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {UserRoleApiUpdateUserRoleInAppRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInApp(requestParameters: UserRoleApiUpdateUserRoleInAppRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {UserRoleApiUpdateUserRoleInEnvTypeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInEnvType(requestParameters: UserRoleApiUpdateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {UserRoleApiUpdateUserRoleInOrgRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoleInOrg(requestParameters: UserRoleApiUpdateUserRoleInOrgRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.updateUserRoleInOrg(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createInviteInOrg operation in UserRoleApi.
 * @export
 * @interface UserRoleApiCreateInviteInOrgRequest
 */
export interface UserRoleApiCreateInviteInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiCreateInviteInOrg
     */
    readonly orgId: string

    /**
     * The email and the desired role  
     * @type {UserInviteRequestRequest}
     * @memberof UserRoleApiCreateInviteInOrg
     */
    readonly userInviteRequestRequest: UserInviteRequestRequest
}

/**
 * Request parameters for createUserRoleInApp operation in UserRoleApi.
 * @export
 * @interface UserRoleApiCreateUserRoleInAppRequest
 */
export interface UserRoleApiCreateUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiCreateUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiCreateUserRoleInApp
     */
    readonly appId: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof UserRoleApiCreateUserRoleInApp
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for createUserRoleInEnvType operation in UserRoleApi.
 * @export
 * @interface UserRoleApiCreateUserRoleInEnvTypeRequest
 */
export interface UserRoleApiCreateUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiCreateUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiCreateUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof UserRoleApiCreateUserRoleInEnvType
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for deleteUserRoleInApp operation in UserRoleApi.
 * @export
 * @interface UserRoleApiDeleteUserRoleInAppRequest
 */
export interface UserRoleApiDeleteUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInApp
     */
    readonly userId: string
}

/**
 * Request parameters for deleteUserRoleInEnvType operation in UserRoleApi.
 * @export
 * @interface UserRoleApiDeleteUserRoleInEnvTypeRequest
 */
export interface UserRoleApiDeleteUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInEnvType
     */
    readonly userId: string
}

/**
 * Request parameters for deleteUserRoleInOrg operation in UserRoleApi.
 * @export
 * @interface UserRoleApiDeleteUserRoleInOrgRequest
 */
export interface UserRoleApiDeleteUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiDeleteUserRoleInOrg
     */
    readonly userId: string
}

/**
 * Request parameters for getUserRoleInApp operation in UserRoleApi.
 * @export
 * @interface UserRoleApiGetUserRoleInAppRequest
 */
export interface UserRoleApiGetUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInApp
     */
    readonly userId: string
}

/**
 * Request parameters for getUserRoleInEnvType operation in UserRoleApi.
 * @export
 * @interface UserRoleApiGetUserRoleInEnvTypeRequest
 */
export interface UserRoleApiGetUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInEnvType
     */
    readonly userId: string
}

/**
 * Request parameters for getUserRoleInOrg operation in UserRoleApi.
 * @export
 * @interface UserRoleApiGetUserRoleInOrgRequest
 */
export interface UserRoleApiGetUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiGetUserRoleInOrg
     */
    readonly userId: string
}

/**
 * Request parameters for listUserRolesInApp operation in UserRoleApi.
 * @export
 * @interface UserRoleApiListUserRolesInAppRequest
 */
export interface UserRoleApiListUserRolesInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiListUserRolesInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiListUserRolesInApp
     */
    readonly appId: string
}

/**
 * Request parameters for listUserRolesInEnvType operation in UserRoleApi.
 * @export
 * @interface UserRoleApiListUserRolesInEnvTypeRequest
 */
export interface UserRoleApiListUserRolesInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiListUserRolesInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiListUserRolesInEnvType
     */
    readonly envType: string
}

/**
 * Request parameters for listUserRolesInOrg operation in UserRoleApi.
 * @export
 * @interface UserRoleApiListUserRolesInOrgRequest
 */
export interface UserRoleApiListUserRolesInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiListUserRolesInOrg
     */
    readonly orgId: string
}

/**
 * Request parameters for updateUserRoleInApp operation in UserRoleApi.
 * @export
 * @interface UserRoleApiUpdateUserRoleInAppRequest
 */
export interface UserRoleApiUpdateUserRoleInAppRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInApp
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInApp
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInApp
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof UserRoleApiUpdateUserRoleInApp
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for updateUserRoleInEnvType operation in UserRoleApi.
 * @export
 * @interface UserRoleApiUpdateUserRoleInEnvTypeRequest
 */
export interface UserRoleApiUpdateUserRoleInEnvTypeRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInEnvType
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInEnvType
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInEnvType
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof UserRoleApiUpdateUserRoleInEnvType
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for updateUserRoleInOrg operation in UserRoleApi.
 * @export
 * @interface UserRoleApiUpdateUserRoleInOrgRequest
 */
export interface UserRoleApiUpdateUserRoleInOrgRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInOrg
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiUpdateUserRoleInOrg
     */
    readonly userId: string

    /**
     * The new user the role  
     * @type {RoleRequest}
     * @memberof UserRoleApiUpdateUserRoleInOrg
     */
    readonly roleRequest: RoleRequest
}

/**
 * UserRoleApi - object-oriented interface
 * @export
 * @class UserRoleApi
 * @extends {BaseAPI}
 */
export class UserRoleApi extends BaseAPI {
    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {UserRoleApiCreateInviteInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public createInviteInOrg(requestParameters: UserRoleApiCreateInviteInOrgRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).createInviteInOrg(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {UserRoleApiCreateUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public createUserRoleInApp(requestParameters: UserRoleApiCreateUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).createUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Environment Type with a Role
     * @param {UserRoleApiCreateUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public createUserRoleInEnvType(requestParameters: UserRoleApiCreateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).createUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Application
     * @param {UserRoleApiDeleteUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public deleteUserRoleInApp(requestParameters: UserRoleApiDeleteUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).deleteUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Environment Type
     * @param {UserRoleApiDeleteUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public deleteUserRoleInEnvType(requestParameters: UserRoleApiDeleteUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).deleteUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Organization
     * @param {UserRoleApiDeleteUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public deleteUserRoleInOrg(requestParameters: UserRoleApiDeleteUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).deleteUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {UserRoleApiGetUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public getUserRoleInApp(requestParameters: UserRoleApiGetUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).getUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {UserRoleApiGetUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public getUserRoleInEnvType(requestParameters: UserRoleApiGetUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).getUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Organization
     * @param {UserRoleApiGetUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public getUserRoleInOrg(requestParameters: UserRoleApiGetUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).getUserRoleInOrg(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an App
     * @param {UserRoleApiListUserRolesInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public listUserRolesInApp(requestParameters: UserRoleApiListUserRolesInAppRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).listUserRolesInApp(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Environment Type
     * @param {UserRoleApiListUserRolesInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public listUserRolesInEnvType(requestParameters: UserRoleApiListUserRolesInEnvTypeRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).listUserRolesInEnvType(requestParameters.orgId, requestParameters.envType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {UserRoleApiListUserRolesInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public listUserRolesInOrg(requestParameters: UserRoleApiListUserRolesInOrgRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).listUserRolesInOrg(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Application
     * @param {UserRoleApiUpdateUserRoleInAppRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public updateUserRoleInApp(requestParameters: UserRoleApiUpdateUserRoleInAppRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).updateUserRoleInApp(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Environment Type
     * @param {UserRoleApiUpdateUserRoleInEnvTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public updateUserRoleInEnvType(requestParameters: UserRoleApiUpdateUserRoleInEnvTypeRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).updateUserRoleInEnvType(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Organization
     * @param {UserRoleApiUpdateUserRoleInOrgRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public updateUserRoleInOrg(requestParameters: UserRoleApiUpdateUserRoleInOrgRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).updateUserRoleInOrg(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueApi - axios parameter creator
 * @export
 */
export const ValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueApi - functional programming interface
 * @export
 */
export const ValueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueApi - factory interface
 * @export
 */
export const ValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesGet operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesPost operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly envId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesGet operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesGetRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPatch operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPut operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesPost operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesPostRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly appId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * ValueApi - object-oriented interface
 * @export
 * @class ValueApi
 * @extends {BaseAPI}
 */
export class ValueApi extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueSetVersionApi - axios parameter creator
 * @export
 */
export const ValueSetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueSetVersionApi - functional programming interface
 * @export
 */
export const ValueSetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueSetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueSetVersionApi - factory interface
 * @export
 */
export const ValueSetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueSetVersionApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly envId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * ValueSetVersionApi - object-oriented interface
 * @export
 * @class ValueSetVersionApi
 * @extends {BaseAPI}
 */
export class ValueSetVersionApi extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Environment Version history.
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Version history.
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkloadProfileApi - axios parameter creator
 * @export
 */
export const WorkloadProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfile: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('createWorkloadProfile', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {string} orgId The Organization ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfileChartVersion: async (orgId: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('createWorkloadProfileChartVersion', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-chart-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...(localVarFormParams as any).getHeaders?.(), ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkloadProfile: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('deleteWorkloadProfile', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadProfile: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getWorkloadProfile', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [id] Filter Chart Versions by Chart Version ID.
         * @param {string} [version] Filter Chart Versions by Chart Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileChartVersions: async (orgId: string, perPage?: number, page?: string, id?: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileChartVersions', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-chart-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileVersions: async (orgId: string, profileQid: string, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileVersions', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('listWorkloadProfileVersions', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID
         * @param {boolean} [deprecated] Whether to include deprecated profiles
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfiles: async (orgId: string, deprecated?: boolean, perPage?: number, page?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfiles', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deprecated !== undefined) {
                localVarQueryParameter['deprecated'] = deprecated;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {WorkloadProfileUpdateRequest} workloadProfileUpdateRequest Workload profile details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkloadProfile: async (orgId: string, profileQid: string, workloadProfileUpdateRequest: WorkloadProfileUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'profileQid', profileQid)
            // verify required parameter 'workloadProfileUpdateRequest' is not null or undefined
            assertParamExists('updateWorkloadProfile', 'workloadProfileUpdateRequest', workloadProfileUpdateRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkloadProfileApi - functional programming interface
 * @export
 */
export const WorkloadProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkloadProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkloadProfile(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkloadProfile(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {string} orgId The Organization ID
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkloadProfileChartVersion(orgId: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileChartVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkloadProfileChartVersion(orgId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkloadProfile(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkloadProfile(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getLatestWorkloadProfileVersion(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestWorkloadProfileVersion(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkloadProfile(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkloadProfile(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {string} orgId The Organization ID
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {string} [id] Filter Chart Versions by Chart Version ID.
         * @param {string} [version] Filter Chart Versions by Chart Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileChartVersions(orgId: string, perPage?: number, page?: string, id?: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileChartVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileChartVersions(orgId, perPage, page, id, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileVersions(orgId: string, profileQid: string, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileVersions(orgId, profileQid, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID
         * @param {boolean} [deprecated] Whether to include deprecated profiles
         * @param {number} [perPage] The maximum number of items to return in a page of results
         * @param {string} [page] The page token to request from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfiles(orgId: string, deprecated?: boolean, perPage?: number, page?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfiles(orgId, deprecated, perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {string} orgId The Organization ID
         * @param {string} profileQid The Workload Profile ID.
         * @param {WorkloadProfileUpdateRequest} workloadProfileUpdateRequest Workload profile details. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkloadProfile(orgId: string, profileQid: string, workloadProfileUpdateRequest: WorkloadProfileUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkloadProfile(orgId, profileQid, workloadProfileUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkloadProfileApi - factory interface
 * @export
 */
export const WorkloadProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkloadProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {WorkloadProfileApiCreateWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfile(requestParameters: WorkloadProfileApiCreateWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.createWorkloadProfile(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
         * @summary Add new Workload Profile Chart Version
         * @param {WorkloadProfileApiCreateWorkloadProfileChartVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkloadProfileChartVersion(requestParameters: WorkloadProfileApiCreateWorkloadProfileChartVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileChartVersionResponse> {
            return localVarFp.createWorkloadProfileChartVersion(requestParameters.orgId, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {WorkloadProfileApiDeleteWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkloadProfile(requestParameters: WorkloadProfileApiDeleteWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {WorkloadProfileApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion(requestParameters: WorkloadProfileApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {WorkloadProfileApiGetWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkloadProfile(requestParameters: WorkloadProfileApiGetWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.getWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all Workload Profile Chart Versions for the given organization.
         * @summary Workload Profile Chart Versions for the given organization.
         * @param {WorkloadProfileApiListWorkloadProfileChartVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileChartVersions(requestParameters: WorkloadProfileApiListWorkloadProfileChartVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileChartVersionResponse>> {
            return localVarFp.listWorkloadProfileChartVersions(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.id, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile.
         * @param {WorkloadProfileApiListWorkloadProfileVersionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileVersions(requestParameters: WorkloadProfileApiListWorkloadProfileVersionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.listWorkloadProfileVersions(requestParameters.orgId, requestParameters.profileQid, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {WorkloadProfileApiListWorkloadProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfiles(requestParameters: WorkloadProfileApiListWorkloadProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.listWorkloadProfiles(requestParameters.orgId, requestParameters.deprecated, requestParameters.perPage, requestParameters.page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Workload Profile
         * @param {WorkloadProfileApiUpdateWorkloadProfileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkloadProfile(requestParameters: WorkloadProfileApiUpdateWorkloadProfileRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.updateWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, requestParameters.workloadProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWorkloadProfile operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiCreateWorkloadProfileRequest
 */
export interface WorkloadProfileApiCreateWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiCreateWorkloadProfile
     */
    readonly orgId: string

    /**
     * Workload profile details.  
     * @type {WorkloadProfileRequest}
     * @memberof WorkloadProfileApiCreateWorkloadProfile
     */
    readonly workloadProfileRequest: WorkloadProfileRequest
}

/**
 * Request parameters for createWorkloadProfileChartVersion operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiCreateWorkloadProfileChartVersionRequest
 */
export interface WorkloadProfileApiCreateWorkloadProfileChartVersionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiCreateWorkloadProfileChartVersion
     */
    readonly orgId: string

    /**
     * 
     * @type {File}
     * @memberof WorkloadProfileApiCreateWorkloadProfileChartVersion
     */
    readonly file?: File
}

/**
 * Request parameters for deleteWorkloadProfile operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiDeleteWorkloadProfileRequest
 */
export interface WorkloadProfileApiDeleteWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiDeleteWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof WorkloadProfileApiDeleteWorkloadProfile
     */
    readonly profileQid: string
}

/**
 * Request parameters for getLatestWorkloadProfileVersion operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiGetLatestWorkloadProfileVersionRequest
 */
export interface WorkloadProfileApiGetLatestWorkloadProfileVersionRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiGetLatestWorkloadProfileVersion
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof WorkloadProfileApiGetLatestWorkloadProfileVersion
     */
    readonly profileQid: string
}

/**
 * Request parameters for getWorkloadProfile operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiGetWorkloadProfileRequest
 */
export interface WorkloadProfileApiGetWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiGetWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof WorkloadProfileApiGetWorkloadProfile
     */
    readonly profileQid: string
}

/**
 * Request parameters for listWorkloadProfileChartVersions operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiListWorkloadProfileChartVersionsRequest
 */
export interface WorkloadProfileApiListWorkloadProfileChartVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileChartVersions
     */
    readonly orgId: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof WorkloadProfileApiListWorkloadProfileChartVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileChartVersions
     */
    readonly page?: string

    /**
     * Filter Chart Versions by Chart Version ID.
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileChartVersions
     */
    readonly id?: string

    /**
     * Filter Chart Versions by Chart Version.
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileChartVersions
     */
    readonly version?: string
}

/**
 * Request parameters for listWorkloadProfileVersions operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiListWorkloadProfileVersionsRequest
 */
export interface WorkloadProfileApiListWorkloadProfileVersionsRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileVersions
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileVersions
     */
    readonly profileQid: string

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof WorkloadProfileApiListWorkloadProfileVersions
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfileVersions
     */
    readonly page?: string
}

/**
 * Request parameters for listWorkloadProfiles operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiListWorkloadProfilesRequest
 */
export interface WorkloadProfileApiListWorkloadProfilesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfiles
     */
    readonly orgId: string

    /**
     * Whether to include deprecated profiles
     * @type {boolean}
     * @memberof WorkloadProfileApiListWorkloadProfiles
     */
    readonly deprecated?: boolean

    /**
     * The maximum number of items to return in a page of results
     * @type {number}
     * @memberof WorkloadProfileApiListWorkloadProfiles
     */
    readonly perPage?: number

    /**
     * The page token to request from
     * @type {string}
     * @memberof WorkloadProfileApiListWorkloadProfiles
     */
    readonly page?: string
}

/**
 * Request parameters for updateWorkloadProfile operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiUpdateWorkloadProfileRequest
 */
export interface WorkloadProfileApiUpdateWorkloadProfileRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileApiUpdateWorkloadProfile
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.
     * @type {string}
     * @memberof WorkloadProfileApiUpdateWorkloadProfile
     */
    readonly profileQid: string

    /**
     * Workload profile details. 
     * @type {WorkloadProfileUpdateRequest}
     * @memberof WorkloadProfileApiUpdateWorkloadProfile
     */
    readonly workloadProfileUpdateRequest: WorkloadProfileUpdateRequest
}

/**
 * WorkloadProfileApi - object-oriented interface
 * @export
 * @class WorkloadProfileApi
 * @extends {BaseAPI}
 */
export class WorkloadProfileApi extends BaseAPI {
    /**
     * 
     * @summary Create new Workload Profile
     * @param {WorkloadProfileApiCreateWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public createWorkloadProfile(requestParameters: WorkloadProfileApiCreateWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).createWorkloadProfile(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
     * @summary Add new Workload Profile Chart Version
     * @param {WorkloadProfileApiCreateWorkloadProfileChartVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public createWorkloadProfileChartVersion(requestParameters: WorkloadProfileApiCreateWorkloadProfileChartVersionRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).createWorkloadProfileChartVersion(requestParameters.orgId, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {WorkloadProfileApiDeleteWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public deleteWorkloadProfile(requestParameters: WorkloadProfileApiDeleteWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).deleteWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Latest version of the given workload profile with optional constraint.
     * @param {WorkloadProfileApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public getLatestWorkloadProfileVersion(requestParameters: WorkloadProfileApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {WorkloadProfileApiGetWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public getWorkloadProfile(requestParameters: WorkloadProfileApiGetWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).getWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all Workload Profile Chart Versions for the given organization.
     * @summary Workload Profile Chart Versions for the given organization.
     * @param {WorkloadProfileApiListWorkloadProfileChartVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public listWorkloadProfileChartVersions(requestParameters: WorkloadProfileApiListWorkloadProfileChartVersionsRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).listWorkloadProfileChartVersions(requestParameters.orgId, requestParameters.perPage, requestParameters.page, requestParameters.id, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile.
     * @param {WorkloadProfileApiListWorkloadProfileVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public listWorkloadProfileVersions(requestParameters: WorkloadProfileApiListWorkloadProfileVersionsRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).listWorkloadProfileVersions(requestParameters.orgId, requestParameters.profileQid, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {WorkloadProfileApiListWorkloadProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public listWorkloadProfiles(requestParameters: WorkloadProfileApiListWorkloadProfilesRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).listWorkloadProfiles(requestParameters.orgId, requestParameters.deprecated, requestParameters.perPage, requestParameters.page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Workload Profile
     * @param {WorkloadProfileApiUpdateWorkloadProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public updateWorkloadProfile(requestParameters: WorkloadProfileApiUpdateWorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).updateWorkloadProfile(requestParameters.orgId, requestParameters.profileQid, requestParameters.workloadProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkloadProfileFeaturesApi - axios parameter creator
 * @export
 */
export const WorkloadProfileFeaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileFeatures: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('listWorkloadProfileFeatures', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profile-features`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkloadProfileFeaturesApi - functional programming interface
 * @export
 */
export const WorkloadProfileFeaturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkloadProfileFeaturesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {string} orgId The Organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkloadProfileFeatures(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileFeatureResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkloadProfileFeatures(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkloadProfileFeaturesApi - factory interface
 * @export
 */
export const WorkloadProfileFeaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkloadProfileFeaturesApiFp(configuration)
    return {
        /**
         * 
         * @summary List workload profile features available to the organization.
         * @param {WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkloadProfileFeatures(requestParameters: WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileFeatureResponse>> {
            return localVarFp.listWorkloadProfileFeatures(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listWorkloadProfileFeatures operation in WorkloadProfileFeaturesApi.
 * @export
 * @interface WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest
 */
export interface WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest {
    /**
     * The Organization ID
     * @type {string}
     * @memberof WorkloadProfileFeaturesApiListWorkloadProfileFeatures
     */
    readonly orgId: string
}

/**
 * WorkloadProfileFeaturesApi - object-oriented interface
 * @export
 * @class WorkloadProfileFeaturesApi
 * @extends {BaseAPI}
 */
export class WorkloadProfileFeaturesApi extends BaseAPI {
    /**
     * 
     * @summary List workload profile features available to the organization.
     * @param {WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileFeaturesApi
     */
    public listWorkloadProfileFeatures(requestParameters: WorkloadProfileFeaturesApiListWorkloadProfileFeaturesRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileFeaturesApiFp(this.configuration).listWorkloadProfileFeatures(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


