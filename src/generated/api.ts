/* tslint:disable */
/* eslint-disable */
/**
 * Humanitec API
 * # Introduction The *Humanitec API* allows you to automate and integrate Humanitec into your developer and operational workflows. The API is a REST based API. It is based around a set of concepts:  * Core * External Resources * Sets and Deltas  ## Authentication Almost all requests made to the Humanitec API require Authentication. Humanitec provides 2 ways of authenticating with the API: `Bearer` and `JWT`.  ### Bearer Authentication This form of authentication makes use of a **static token**. It is intended to be used when machines interact with the Humanitec API. Bearer tokens should be used for very narrow purposes. This allows for the token to be revoked if it is compromised and so limit the scope of exposure. New Bearer tokens can be obtained via the UI:  1. Log into Humanitec at https://app.humanitec.io 1. Go to **Organization Settings** 1. Select **API tokens** 1. Enter a *name* for the new token and click on **Generate new token**  The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_TOKEN`, the request could be made as follows:  ```     curl -H \'Authorization: Bearer HUMANITEC_TOKEN\' https://api.humanitec.io/orgs/my-org/apps ```  ### JWT Authentication This form of authentication makes use of a **JSON Web Token (JWT)**. It is intended to be used when humans interact with the Humanitec API. JWTs expire after a period of time. This means that a new JWT will need to be generated regularly. This makes them well suited to working in short sessions, but not for automation. (See Bearer Authentication.) The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_JWT`, the request could be made as follows:  ```     curl -H \'Authorization: JWT HUMANITEC_JWT\' https://api.humanitec.io/orgs/my-org/apps ```  ## Content Types All of the Humanitec API unless explicitly only accepts content types of `application/json` and will always return valid `application/json` or an empty response.  ## Response Codes ### Success Any response code in the `2xx` range should be regarded as success.  | **Code** | **Meaning** | | --- | --- | | `200` | Success | | `201` | Success (In future, `201` will be replaced by `200`) | | `204` | Success, but no content in response |  _Note: We plan to simplify the interface by replacing 201 with 200 status codes._  ### Failure Any response code in the `4xx` should be regarded as an error which can be rectified by the client. `5xx` error codes indicate errors that cannot be corrected by the client.  | **Code** | **Meaning** | | --- | --- | | `400` | General error. (Body will contain details) | | `401` | Attempt to access protected resource without `Authorization` Header. | | `403` | The `Bearer` or `JWT` does not grant access to the requested resource. | | `404` | Resource not found. | | `405` | Method not allowed | | `409` | Conflict. Usually indicated a resource with that ID already exists. | | `422` | Unprocessable Entity. The body was not valid JSON, was empty or contained an object different from what was expected. | | `429` | Too many requests - request rate limit has been reached. | | `500` | Internal Error. If it occurs repeatedly, contact support. | 
 *
 * The version of the OpenAPI document: 0.21.1
 * Contact: apiteam@humanitec.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
import FormData from 'form-data'
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsRequest
 */
export interface AccountCredsRequest {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'username': string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeRequest
 */
export interface AccountTypeRequest {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'name'?: string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'type'?: string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeResponse
 */
export interface AccountTypeResponse {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'name': string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'type': string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceRequest
 */
export interface ActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'app_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'def_id'?: string;
    /**
     * The deployment that the resource was last provisioned in.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'deploy_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_id'?: string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_type'?: string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'org_id'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'res_id'?: string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'status'?: string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'type'?: string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'updated_at'?: string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceResponse
 */
export interface ActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'def_id': string;
    /**
     * The deployment that the resource was last provisioned in.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'deploy_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_type': string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'res_id': string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * AddArtefactVersionPayload describes the payload for a new ArtefactVersion request.
 * @export
 * @interface AddArtefactVersionPayloadRequest
 */
export interface AddArtefactVersionPayloadRequest {
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'digest'?: string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'ref'?: string;
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'type': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationCreationRequest
 */
export interface ApplicationCreationRequest {
    /**
     * 
     * @type {EnvironmentBaseRequest}
     * @memberof ApplicationCreationRequest
     */
    'env'?: EnvironmentBaseRequest;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationCreationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationCreationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Workloads that work together. When deployed, all Workloads in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Workloads that work together. When deployed, all Workloads in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * The timestamp in UTC indicates when the Application was created.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_at': string;
    /**
     * The user who created the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_by': string;
    /**
     * The Environments associated with the Application.
     * @type {Array<EnvironmentBaseResponse>}
     * @memberof ApplicationResponse
     */
    'envs': Array<EnvironmentBaseResponse>;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactRequest
 */
export interface ArtefactRequest {
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'type': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactResponse
 */
export interface ArtefactResponse {
    /**
     * The time when the Artefact was added to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'type': string;
    /**
     * The time when the Artefact was updated for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who updated the Artefact for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_by'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionRequest
 */
export interface ArtefactVersionRequest {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionRequest
     */
    'archived'?: boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'digest'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'ref'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'version'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionResponse
 */
export interface ArtefactVersionResponse {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionResponse
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'commit': string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'digest': string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'ref': string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'version': string;
}
/**
 * An Automation Rule defining how and when artefacts in an environment should be updated.
 * @export
 * @interface AutomationRuleRequest
 */
export interface AutomationRuleRequest {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'active'?: boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'artefacts_filter'?: Array<string>;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_artefacts_filter'?: boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_images_filter'?: boolean;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'images_filter'?: Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match'?: string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match_ref'?: string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'update_to'?: string;
}
/**
 * An Automation Rule defining how and when artefacts in an environment should be updated.
 * @export
 * @interface AutomationRuleResponse
 */
export interface AutomationRuleResponse {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'active': boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'artefacts_filter': Array<string>;
    /**
     * The timestamp in UTC of when the Automation Rule was created.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'created_at': string;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_artefacts_filter': boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_images_filter': boolean;
    /**
     * The unique ID for this rule.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'id': string;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'images_filter': Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match': string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match_ref': string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'update_to': string;
    /**
     * The timestamp in UTC of when the Automation Rule was updated.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'updated_at': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretRequest
 */
export interface ClusterSecretRequest {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'secret': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretResponse
 */
export interface ClusterSecretResponse {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'secret': string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerRequest
 */
export interface ControllerRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PodStateRequest>}
     * @memberof ControllerRequest
     */
    'pods'?: Array<PodStateRequest>;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'replicas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'status'?: string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerResponse
 */
export interface ControllerResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<PodStateResponse>}
     * @memberof ControllerResponse
     */
    'pods': Array<PodStateResponse>;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'replicas': number;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'status': string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestRequest
 */
export interface CreateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'type': string;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestRequest
 */
export interface CreateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'id'?: string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'type'?: string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestRequest
 */
export interface CreateResourceDefinitionRequestRequest {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeltaMetadataRequest
 */
export interface DeltaMetadataRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataRequest
     */
    'contributers'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'last_modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'shared'?: boolean;
}
/**
 * 
 * @export
 * @interface DeltaMetadataResponse
 */
export interface DeltaMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'archived': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataResponse
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'last_modified_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'shared'?: boolean;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaRequest
 */
export interface DeltaRequest {
    /**
     * Ignored, but can be provided.
     * @type {string}
     * @memberof DeltaRequest
     */
    'id'?: string;
    /**
     * 
     * @type {DeltaMetadataRequest}
     * @memberof DeltaRequest
     */
    'metadata'?: DeltaMetadataRequest;
    /**
     * 
     * @type {ModuleDeltasRequest}
     * @memberof DeltaRequest
     */
    'modules'?: ModuleDeltasRequest;
    /**
     * 
     * @type {Array<UpdateActionRequest>}
     * @memberof DeltaRequest
     */
    'shared'?: Array<UpdateActionRequest> | null;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaResponse
 */
export interface DeltaResponse {
    /**
     * A unique ID for the Delta
     * @type {string}
     * @memberof DeltaResponse
     */
    'id': string;
    /**
     * 
     * @type {DeltaMetadataResponse}
     * @memberof DeltaResponse
     */
    'metadata': DeltaMetadataResponse;
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof DeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof DeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionRequest
 */
export interface DeployConditionRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'success'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionRequest
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'when'?: string;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionResponse
 */
export interface DeployConditionResponse {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'success': string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionResponse
     */
    'timeout': number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'when': string;
}
/**
 * Error happening during deployment.
 * @export
 * @interface DeploymentErrorRequest
 */
export interface DeploymentErrorRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'error_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'object_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'summary'?: string;
}
/**
 * Error happening during deployment.
 * @export
 * @interface DeploymentErrorResponse
 */
export interface DeploymentErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'error_type': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'object_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'summary': string;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentRequest
 */
export interface DeploymentRequest {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'comment'?: string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'delta_id'?: string;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'set_id'?: string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'value_set_version_id'?: string | null;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentResponse
 */
export interface DeploymentResponse {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'comment': string;
    /**
     * The Timestamp of when the Deployment was initiated.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_at': string;
    /**
     * The user who initiated the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_by': string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'delta_id'?: string;
    /**
     * The Environment where the Deployment occurred.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'env_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_file': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_status': string;
    /**
     * The ID of the Deployment that this Deployment was based on.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'from_id': string;
    /**
     * The ID of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'id': string;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'set_id': string;
    /**
     * The current status of the Deployment. Can be `pending`, `in progress`, `succeeded`, or `failed`.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status': string;
    /**
     * The timestamp of the last `status` change. If `status` is `succeeded` or `failed` it it will indicate when the Deployment finished.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status_changed_at': string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'value_set_version_id'?: string | null;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionRequest
 */
export interface DriverDefinitionRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionRequest
     */
    'account_types'?: Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'org_id'?: string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'type'?: string;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionResponse
 */
export interface DriverDefinitionResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'org_id': string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionResponse
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseRequest
 */
export interface EnvironmentBaseRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseResponse
 */
export interface EnvironmentBaseResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionRequest
 */
export interface EnvironmentDefinitionRequest {
    /**
     * Defines the existing Deployment the new Environment will be based on.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'from_deploy_id': string;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'type': string;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentRequest
 */
export interface EnvironmentRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'type': string;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentResponse
 */
export interface EnvironmentResponse {
    /**
     * The timestamp in UTC of when the Environment was created.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_at': string;
    /**
     * The user who created the Environment
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_by': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'from_deploy'?: DeploymentResponse;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'last_deploy'?: DeploymentResponse;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'type': string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoResponse
 */
export interface EnvironmentRuntimeInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'paused': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'status'?: string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeRequest
 */
export interface EnvironmentTypeRequest {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'description'?: string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'id': string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeResponse
 */
export interface EnvironmentTypeResponse {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'description': string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'id': string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoResponse
 */
export interface ErrorInfoResponse {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoResponse
     */
    'error': string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseRequest
 */
export interface EventBaseRequest {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseRequest
     */
    'type'?: string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseResponse
 */
export interface EventBaseResponse {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseResponse
     */
    'type': string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventResponse
     */
    'properties': Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorResponse
 */
export interface HumanitecErrorResponse {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorResponse
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'error': string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'message': string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildRequest
 */
export interface ImageBuildRequest {
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'branch'?: string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'commit'?: string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'image'?: string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildRequest
     */
    'tags'?: Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildResponse
 */
export interface ImageBuildResponse {
    /**
     * The time when the build was added to Humanitec.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'added_at'?: string;
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'branch': string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'commit': string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'image': string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildResponse
     */
    'tags': Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageRequest
 */
export interface ImageRequest {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageRequest
     */
    'added_at'?: string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildRequest>}
     * @memberof ImageRequest
     */
    'builds'?: Array<ImageBuildRequest>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageRequest
     */
    'id'?: string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageRequest
     */
    'source'?: string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageResponse
     */
    'added_at': string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildResponse>}
     * @memberof ImageResponse
     */
    'builds': Array<ImageBuildResponse>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageResponse
     */
    'id': string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageResponse
     */
    'source': string;
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsRequest
 */
export interface ImagesRegistryCredsRequest {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsRequest
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof ImagesRegistryCredsRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsResponse
 */
export interface ImagesRegistryCredsResponse {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsResponse
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof ImagesRegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
}
/**
 * 
 * @export
 * @interface InternalValueRequest
 */
export interface InternalValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_store_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_version'?: string | null;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InternalValueResponse
 */
export interface InternalValueResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_key': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_store_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_version': string | null;
    /**
     * 
     * @type {ValueSource}
     * @memberof InternalValueResponse
     */
    'source': ValueSource;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface JSONPatchRequest
 */
export interface JSONPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchRequest
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface JSONPatchResponse
 */
export interface JSONPatchResponse {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchResponse
     */
    'value'?: any;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestRequest
 */
export interface ManifestRequest {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestRequest
     */
    'data'?: any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestRequest
     */
    'location'?: string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestResponse
     */
    'data': any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestResponse
     */
    'location': string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaRequest
 */
export interface MatchingCriteriaRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'id'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'res_id'?: string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaResponse
 */
export interface MatchingCriteriaResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'id': string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleRequest
 */
export interface MatchingCriteriaRuleRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'res_id'?: string;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasRequest
 */
export interface ModuleDeltasRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof ModuleDeltasRequest
     */
    'add'?: { [key: string]: ModuleRequest; } | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasRequest
     */
    'remove'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionRequest>; }}
     * @memberof ModuleDeltasRequest
     */
    'update'?: { [key: string]: Array<UpdateActionRequest>; } | null;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasResponse
 */
export interface ModuleDeltasResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof ModuleDeltasResponse
     */
    'add': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasResponse
     */
    'remove': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionResponse>; }}
     * @memberof ModuleDeltasResponse
     */
    'update': { [key: string]: Array<UpdateActionResponse>; };
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleRequest
 */
export interface ModuleRequest {
    [key: string]: ControllerRequest | any;

    /**
     * 
     * @type {DeployConditionRequest}
     * @memberof ModuleRequest
     */
    'deploy'?: DeployConditionRequest;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'externals'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof ModuleRequest
     */
    'profile'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'spec'?: { [key: string]: any; } | null;
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleResponse
 */
export interface ModuleResponse {
    [key: string]: ControllerResponse | any;

    /**
     * 
     * @type {DeployConditionResponse}
     * @memberof ModuleResponse
     */
    'deploy'?: DeployConditionResponse;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'externals': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleResponse
     */
    'profile': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'spec': { [key: string]: any; };
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserRequest
 */
export interface NewServiceUserRequest {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'name': string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'role': string;
}
/**
 * NodeBody represents a node of a Resource Dependency Graph.
 * @export
 * @interface NodeBodyResponse
 */
export interface NodeBodyResponse {
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'criteria_id': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'def_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NodeBodyResponse
     */
    'depends_on': Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'driver': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'driver_type': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'guresid': string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'resource': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeBodyResponse
     */
    'resource_schema': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeBodyResponse
     */
    'type': string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'id'?: string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name'?: string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Timestamp when the Organization was created.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_at': string | null;
    /**
     * User ID that created the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_by': string;
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    'logo_url'?: string | null;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'name': string;
}
/**
 * @type OrgsOrgIdAppsAppIdDeltasPost200Response
 * @export
 */
export type OrgsOrgIdAppsAppIdDeltasPost200Response = DeltaResponse | string;

/**
 * @type OrgsOrgIdAppsAppIdSetsSetIdGet200Response
 * @export
 */
export type OrgsOrgIdAppsAppIdSetsSetIdGet200Response = PlainDeltaResponse | SetResponse;

/**
 * 
 * @export
 * @interface OrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest
 */
export interface OrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest {
    /**
     * 
     * @type {WorkloadProfileVersionRequest}
     * @memberof OrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest
     */
    'metadata'?: WorkloadProfileVersionRequest;
    /**
     * 
     * @type {File}
     * @memberof OrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest
     */
    'file'?: File;
}
/**
 * PatchResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface PatchResourceDefinitionRequestRequest
 */
export interface PatchResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'name'?: string | null;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource or if they have the same dependent resources.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof PatchResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
}
/**
 * Similar to the delta response, except the id and metadata properties.  **Basic Structure**  ```  {    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface PlainDeltaResponse
 */
export interface PlainDeltaResponse {
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof PlainDeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof PlainDeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateRequest
 */
export interface PodStateRequest {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateRequest
     */
    'containerStatuses'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'phase'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'podName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PodStateRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'status'?: string;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateResponse
 */
export interface PodStateResponse {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateResponse
     */
    'containerStatuses': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'phase': string;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'podName': string;
    /**
     * 
     * @type {number}
     * @memberof PodStateResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'status': string;
}
/**
 * ProvisionDependencies defines resources which are needed to be co-provisioned with the current resource.
 * @export
 * @interface ProvisionDependenciesRequest
 */
export interface ProvisionDependenciesRequest {
    /**
     * If the co-provisioned resource is dependendent on the current one.
     * @type {boolean}
     * @memberof ProvisionDependenciesRequest
     */
    'is_dependent'?: boolean;
    /**
     * If the resources dependant on the main resource, are also dependant on the co-provisioned one.
     * @type {boolean}
     * @memberof ProvisionDependenciesRequest
     */
    'match_dependents'?: boolean;
}
/**
 * ProvisionDependencies defines resources which are needed to be co-provisioned with the current resource.
 * @export
 * @interface ProvisionDependenciesResponse
 */
export interface ProvisionDependenciesResponse {
    /**
     * If the co-provisioned resource is dependendent on the current one.
     * @type {boolean}
     * @memberof ProvisionDependenciesResponse
     */
    'is_dependent': boolean;
    /**
     * If the resources dependant on the main resource, are also dependant on the co-provisioned one.
     * @type {boolean}
     * @memberof ProvisionDependenciesResponse
     */
    'match_dependents'?: boolean;
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsResponse
 */
export interface RegistryCredsResponse {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'password': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
    /**
     * Security account login or token.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'username': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryRequest
 */
export interface RegistryRequest {
    /**
     * 
     * @type {AccountCredsRequest}
     * @memberof RegistryRequest
     */
    'creds'?: AccountCredsRequest;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryRequest
     */
    'enable_ci'?: boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryRequest
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryRequest
     */
    'type': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryResponse
 */
export interface RegistryResponse {
    /**
     * The timestamp of when this record was created.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_at'?: string | null;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_by'?: string;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryResponse
     */
    'enable_ci': boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryResponse
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryResponse
     */
    'secrets'?: { [key: string]: ClusterSecretResponse; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryResponse
     */
    'type': string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountRequest
 */
export interface ResourceAccountRequest {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_at'?: string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_by'?: string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'id'?: string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountRequest
     */
    'is_used'?: boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'type'?: string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountResponse
 */
export interface ResourceAccountResponse {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_by': string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'id': string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountResponse
     */
    'is_used': boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'type': string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeResponse
 */
export interface ResourceDefinitionChangeResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'app_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'env_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'from_def': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'res_id': string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'to_def': string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionRequest
 */
export interface ResourceDefinitionRequest {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof ResourceDefinitionRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof ResourceDefinitionRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'id'?: string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'name'?: string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'org_id'?: string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof ResourceDefinitionRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'type'?: string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionResponse
 */
export interface ResourceDefinitionResponse {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof ResourceDefinitionResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof ResourceDefinitionResponse
     */
    'driver_inputs'?: ValuesSecretsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'id': string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'name': string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'org_id': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource.
     * @type {{ [key: string]: ProvisionDependenciesResponse; }}
     * @memberof ResourceDefinitionResponse
     */
    'provision'?: { [key: string]: ProvisionDependenciesResponse; };
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner, specifying the resources to be provisioned.
 * @export
 * @interface ResourceProvisionRequestRequest
 */
export interface ResourceProvisionRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set.
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'type': string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeRequest
 */
export interface ResourceTypeRequest {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'category'?: string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'name'?: string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'outputs_schema'?: { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'type'?: string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeResponse
 */
export interface ResourceTypeResponse {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'category': string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'name': string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'outputs_schema': { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'type': string;
}
/**
 * Role defines the role that will be used in request
 * @export
 * @interface RoleRequest
 */
export interface RoleRequest {
    /**
     * 
     * @type {string}
     * @memberof RoleRequest
     */
    'role'?: string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoRequest
 */
export interface RuntimeInfoRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof RuntimeInfoRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoRequest
     */
    'namespace'?: string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoResponse
 */
export interface RuntimeInfoResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof RuntimeInfoResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoResponse
     */
    'namespace': string;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetRequest
 */
export interface SetRequest {
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof SetRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetRequest
     */
    'shared'?: { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetRequest
     */
    'version'?: number;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetResponse
 */
export interface SetResponse {
    /**
     * The ID which is a hash of the content of the Deployment Set.
     * @type {string}
     * @memberof SetResponse
     */
    'id': string;
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof SetResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetResponse
     */
    'shared': { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetResponse
     */
    'version': number;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionRequest
 */
export interface TokenDefinitionRequest {
    /**
     * A description of the token. (Optional)
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'description'?: string;
    /**
     * The time the token expires. If not set, the token will not expire. (Optional)
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'expires_at'?: string;
    /**
     * Identifier of the token. Must be unique for the user.
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'id': string;
    /**
     * The type of the token. Can only be \"static\".
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'type': string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoRequest
 */
export interface TokenInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'type'?: string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoResponse
 */
export interface TokenInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'type': string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'type'?: string;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionRequest
 */
export interface UpdateActionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionRequest
     */
    'value'?: any | null;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionResponse
 */
export interface UpdateActionResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionResponse
     */
    'value'?: any;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadRequest
 */
export interface UpdateArtefactVersionPayloadRequest {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadRequest
     */
    'archived': boolean | null;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestRequest
 */
export interface UpdateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'type': string;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestRequest
 */
export interface UpdateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'name'?: string;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestRequest
 */
export interface UpdateResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The display name.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * (Optional) A map where the keys are resType#resId (if resId is omitted, the same id of the current resource definition is used) of the resources that should be provisioned when the current resource is provisioned. This also specifies if the resources have a dependency on the current resource or if they have the same dependent resources.
     * @type {{ [key: string]: ProvisionDependenciesRequest; }}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'provision'?: { [key: string]: ProvisionDependenciesRequest; };
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestRequest
 */
export interface UserInviteRequestRequest {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'role': string;
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteResponse
 */
export interface UserInviteResponse {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_by': string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'expires_at': string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'user_id': string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedRequest
 */
export interface UserProfileExtendedRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedRequest
     */
    'properties'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedRequest
     */
    'roles'?: { [key: string]: string; };
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'type'?: string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedResponse
 */
export interface UserProfileExtendedResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedResponse
     */
    'properties': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedResponse
     */
    'roles': { [key: string]: string; };
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'type': string;
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileRequest
 */
export interface UserProfileRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileRequest
     */
    'name'?: string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileRequest
     */
    'type'?: string;
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserProfileResponse
     */
    'type': string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleRequest
 */
export interface UserRoleRequest {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleRequest
     */
    'role'?: string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleRequest
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleRequest
     */
    'id'?: string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleRequest
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleRequest
     */
    'name'?: string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserRoleRequest
     */
    'type'?: string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleResponse
 */
export interface UserRoleResponse {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleResponse
     */
    'role': string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleResponse
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleResponse
     */
    'id': string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleResponse
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleResponse
     */
    'name': string;
    /**
     * The type of the account. Could be user, service or system
     * @type {string}
     * @memberof UserRoleResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadRequest
 */
export interface ValueCreatePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadRequest
 */
export interface ValueEditPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'value': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueEditPayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadRequest
 */
export interface ValuePatchPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'value'?: string | null;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueRequest
 */
export interface ValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueRequest
     */
    'key'?: string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueRequest
     */
    'value'?: string;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueResponse
 */
export interface ValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueResponse
     */
    'key': string;
    /**
     * Location of the secret value in the secret store.
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_key': string | null;
    /**
     * Version of the current secret value as returned by the secret store.
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_version': string | null;
    /**
     * 
     * @type {ValueSource}
     * @memberof ValueResponse
     */
    'source': ValueSource;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueResponse
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface ValueSetActionPayloadRequest
 */
export interface ValueSetActionPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadRequest
     */
    'comment'?: string;
}
/**
 * A Value Set Version can be used as a track record of Shared Values changes, to restore a previous version of a Shared Value or Value Set, or to purge a Shared Value if it shouldn\'t be accessible anymore.
 * @export
 * @interface ValueSetVersionResponse
 */
export interface ValueSetVersionResponse {
    /**
     * 
     * @type {Array<JSONPatchResponse>}
     * @memberof ValueSetVersionResponse
     */
    'change': Array<JSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {ValueSetVersionResultOf}
     * @memberof ValueSetVersionResponse
     */
    'result_of': ValueSetVersionResultOf | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: ValueResponse; }}
     * @memberof ValueSetVersionResponse
     */
    'values': { [key: string]: ValueResponse; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ValueSetVersionResultOf = {
    AppValueCreate: 'app_value_create',
    AppValueUpdate: 'app_value_update',
    AppValueDelete: 'app_value_delete',
    AppValuesDelete: 'app_values_delete',
    AppValueSetVersionRestore: 'app_value_set_version_restore',
    AppValueSetVersionPurge: 'app_value_set_version_purge',
    EnvValueCreate: 'env_value_create',
    EnvValueUpdate: 'env_value_update',
    EnvValueDelete: 'env_value_delete',
    EnvValuesDelete: 'env_values_delete',
    EnvValueSetVersionRestore: 'env_value_set_version_restore',
    EnvValueSetVersionPurge: 'env_value_set_version_purge'
} as const;

export type ValueSetVersionResultOf = typeof ValueSetVersionResultOf[keyof typeof ValueSetVersionResultOf];


/**
 * Source of the value, \"app\" for app level, \"env\" for app env level.
 * @export
 * @enum {string}
 */

export const ValueSource = {
    App: 'app',
    Env: 'env'
} as const;

export type ValueSource = typeof ValueSource[keyof typeof ValueSource];


/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsRequest
 */
export interface ValuesSecretsRequest {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'values'?: { [key: string]: any; };
}
/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsResponse
 */
export interface ValuesSecretsResponse {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'values'?: { [key: string]: any; };
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookRequest
 */
export interface WebhookRequest {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'headers'?: { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookRequest
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'payload'?: { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseRequest>}
     * @memberof WebhookRequest
     */
    'triggers'?: Array<EventBaseRequest>;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported).
     * @type {string}
     * @memberof WebhookRequest
     */
    'url'?: string | null;
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The timestamp of when this Job was created.
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_at'?: string;
    /**
     * The user who created this Job
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_by'?: string;
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'headers': { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookResponse
     */
    'triggers': Array<EventBaseResponse>;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported).
     * @type {string}
     * @memberof WebhookResponse
     */
    'url': string | null;
}
/**
 * Webhook is a special type of a Job. It performs an HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookUpdateResponse
 */
export interface WebhookUpdateResponse {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookUpdateResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookUpdateResponse
     */
    'headers': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookUpdateResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookUpdateResponse
     */
    'triggers': Array<EventBaseResponse> | null;
    /**
     * The webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookUpdateResponse
     */
    'url': string | null;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileRequest
 */
export interface WorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'id': string;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileResponse
 */
export interface WorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'id': string;
    /**
     * The latest version of the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'latest': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'org_id': string;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionRequest
 */
export interface WorkloadProfileVersionRequest {
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionRequest
     */
    'features'?: { [key: string]: any; };
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionRequest
     */
    'notes'?: string;
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinition}
     * @memberof WorkloadProfileVersionRequest
     */
    'spec_definition'?: WorkloadProfileVersionSpecDefinition;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionResponse
 */
export interface WorkloadProfileVersionResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_by': string;
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionResponse
     */
    'features': { [key: string]: any; };
    /**
     * OpenAPI schema used to validate the spec.
     * @type {any}
     * @memberof WorkloadProfileVersionResponse
     */
    'spec_schema': any;
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinition}
     * @memberof WorkloadProfileVersionResponse
     */
    'spec_definition'?: WorkloadProfileVersionSpecDefinition;
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'notes': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'org_id': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'profile_id': string;
    /**
     * Version
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface WorkloadProfileVersionSpecDefinition
 */
export interface WorkloadProfileVersionSpecDefinition {
    /**
     * Workload spec definition
     * @type {{ [key: string]: WorkloadProfileVersionSpecDefinitionProperty; }}
     * @memberof WorkloadProfileVersionSpecDefinition
     */
    'properties'?: { [key: string]: WorkloadProfileVersionSpecDefinitionProperty; };
    /**
     * 
     * @type {Array<WorkloadProfileVersionSpecDefinitionRuntimeProperty>}
     * @memberof WorkloadProfileVersionSpecDefinition
     */
    'runtime_properties'?: Array<WorkloadProfileVersionSpecDefinitionRuntimeProperty>;
}
/**
 * 
 * @export
 * @interface WorkloadProfileVersionSpecDefinitionProperty
 */
export interface WorkloadProfileVersionSpecDefinitionProperty {
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinitionPropertyType}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'type': WorkloadProfileVersionSpecDefinitionPropertyType;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'feature_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinitionPropertyUIHints}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'ui_hints'?: WorkloadProfileVersionSpecDefinitionPropertyUIHints;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'schema'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<WorkloadProfileVersionSpecDefinitionRuntimeProperty>}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'runtime_properties'?: Array<WorkloadProfileVersionSpecDefinitionRuntimeProperty>;
    /**
     * Workload spec definition
     * @type {{ [key: string]: WorkloadProfileVersionSpecDefinitionProperty; }}
     * @memberof WorkloadProfileVersionSpecDefinitionProperty
     */
    'properties'?: { [key: string]: WorkloadProfileVersionSpecDefinitionProperty; };
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkloadProfileVersionSpecDefinitionPropertyType = {
    Feature: 'feature',
    Collection: 'collection',
    Schema: 'schema'
} as const;

export type WorkloadProfileVersionSpecDefinitionPropertyType = typeof WorkloadProfileVersionSpecDefinitionPropertyType[keyof typeof WorkloadProfileVersionSpecDefinitionPropertyType];


/**
 * 
 * @export
 * @interface WorkloadProfileVersionSpecDefinitionPropertyUIHints
 */
export interface WorkloadProfileVersionSpecDefinitionPropertyUIHints {
    /**
     * 
     * @type {number}
     * @memberof WorkloadProfileVersionSpecDefinitionPropertyUIHints
     */
    'order'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkloadProfileVersionSpecDefinitionPropertyUIHints
     */
    'hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface WorkloadProfileVersionSpecDefinitionRuntimeProperty
 */
export interface WorkloadProfileVersionSpecDefinitionRuntimeProperty {
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinitionRuntimePropertyType}
     * @memberof WorkloadProfileVersionSpecDefinitionRuntimeProperty
     */
    'type': WorkloadProfileVersionSpecDefinitionRuntimePropertyType;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionRuntimeProperty
     */
    'feature_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionRuntimeProperty
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkloadProfileVersionSpecDefinitionRuntimeProperty
     */
    'version'?: string;
    /**
     * 
     * @type {WorkloadProfileVersionSpecDefinitionPropertyUIHints}
     * @memberof WorkloadProfileVersionSpecDefinitionRuntimeProperty
     */
    'ui_hints'?: WorkloadProfileVersionSpecDefinitionPropertyUIHints;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkloadProfileVersionSpecDefinitionRuntimePropertyType = {
    Feature: 'feature',
    Collection: 'collection'
} as const;

export type WorkloadProfileVersionSpecDefinitionRuntimePropertyType = typeof WorkloadProfileVersionSpecDefinitionRuntimePropertyType[keyof typeof WorkloadProfileVersionSpecDefinitionRuntimePropertyType];



/**
 * AccountTypeApi - axios parameter creator
 * @export
 */
export const AccountTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTypeApi - functional programming interface
 * @export
 */
export const AccountTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountTypeApi - factory interface
 * @export
 */
export const AccountTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(requestParameters: AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesAccountTypesGet operation in AccountTypeApi.
 * @export
 * @interface AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest
 */
export interface AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AccountTypeApiOrgsOrgIdResourcesAccountTypesGet
     */
    readonly orgId: string
}

/**
 * AccountTypeApi - object-oriented interface
 * @export
 * @class AccountTypeApi
 * @extends {BaseAPI}
 */
export class AccountTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTypeApi
     */
    public orgsOrgIdResourcesAccountTypesGet(requestParameters: AccountTypeApiOrgsOrgIdResourcesAccountTypesGetRequest, options?: AxiosRequestConfig) {
        return AccountTypeApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActiveResourceApi - axios parameter creator
 * @export
 */
export const ActiveResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveResourceApi - functional programming interface
 * @export
 */
export const ActiveResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActiveResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActiveResourceApi - factory interface
 * @export
 */
export const ActiveResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActiveResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters: ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters: ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest
 */
export interface ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest
 */
export interface ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly envId: string

    /**
     * The Resource Type.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly type: string

    /**
     * The Resource ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly resId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdResourcesGet operation in ActiveResourceApi.
 * @export
 * @interface ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest
 */
export interface ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly defId: string
}

/**
 * ActiveResourceApi - object-oriented interface
 * @export
 * @class ActiveResourceApi
 * @extends {BaseAPI}
 */
export class ActiveResourceApi extends BaseAPI {
    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters: ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters: ActiveResourceApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: ActiveResourceApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationCreationRequest: ApplicationCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationCreationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationCreationRequest', applicationCreationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationCreationRequest: ApplicationCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(requestParameters: ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {ApplicationApiOrgsOrgIdAppsAppIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(requestParameters: ApplicationApiOrgsOrgIdAppsAppIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {ApplicationApiOrgsOrgIdAppsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(requestParameters: ApplicationApiOrgsOrgIdAppsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {ApplicationApiOrgsOrgIdAppsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(requestParameters: ApplicationApiOrgsOrgIdAppsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdDelete operation in ApplicationApi.
 * @export
 * @interface ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest
 */
export interface ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsAppIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsAppIdDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdGet operation in ApplicationApi.
 * @export
 * @interface ApplicationApiOrgsOrgIdAppsAppIdGetRequest
 */
export interface ApplicationApiOrgsOrgIdAppsAppIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsAppIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsAppIdGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsGet operation in ApplicationApi.
 * @export
 * @interface ApplicationApiOrgsOrgIdAppsGetRequest
 */
export interface ApplicationApiOrgsOrgIdAppsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdAppsPost operation in ApplicationApi.
 * @export
 * @interface ApplicationApiOrgsOrgIdAppsPostRequest
 */
export interface ApplicationApiOrgsOrgIdAppsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ApplicationApiOrgsOrgIdAppsPost
     */
    readonly orgId: string

    /**
     * The request ID, Human-friendly name and environment of the Application.  
     * @type {ApplicationCreationRequest}
     * @memberof ApplicationApiOrgsOrgIdAppsPost
     */
    readonly applicationCreationRequest: ApplicationCreationRequest
}

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdDelete(requestParameters: ApplicationApiOrgsOrgIdAppsAppIdDeleteRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {ApplicationApiOrgsOrgIdAppsAppIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdGet(requestParameters: ApplicationApiOrgsOrgIdAppsAppIdGetRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {ApplicationApiOrgsOrgIdAppsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsGet(requestParameters: ApplicationApiOrgsOrgIdAppsGetRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {ApplicationApiOrgsOrgIdAppsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsPost(requestParameters: ApplicationApiOrgsOrgIdAppsPostRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsPost(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactApi - axios parameter creator
 * @export
 */
export const ArtefactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactApi - functional programming interface
 * @export
 */
export const ArtefactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactApi - factory interface
 * @export
 */
export const ArtefactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactApiFp(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(requestParameters: ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {ArtefactApiOrgsOrgIdArtefactsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(requestParameters: ArtefactApiOrgsOrgIdArtefactsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdDelete operation in ArtefactApi.
 * @export
 * @interface ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest
 */
export interface ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactApiOrgsOrgIdArtefactsArtefactIdDelete
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof ArtefactApiOrgsOrgIdArtefactsArtefactIdDelete
     */
    readonly artefactId: string
}

/**
 * Request parameters for orgsOrgIdArtefactsGet operation in ArtefactApi.
 * @export
 * @interface ArtefactApiOrgsOrgIdArtefactsGetRequest
 */
export interface ArtefactApiOrgsOrgIdArtefactsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactApiOrgsOrgIdArtefactsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefacts by type.  
     * @type {string}
     * @memberof ArtefactApiOrgsOrgIdArtefactsGet
     */
    readonly type?: string

    /**
     * (Optional) Filter Artefacts by name.  
     * @type {string}
     * @memberof ArtefactApiOrgsOrgIdArtefactsGet
     */
    readonly name?: string
}

/**
 * ArtefactApi - object-oriented interface
 * @export
 * @class ArtefactApi
 * @extends {BaseAPI}
 */
export class ArtefactApi extends BaseAPI {
    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(requestParameters: ArtefactApiOrgsOrgIdArtefactsArtefactIdDeleteRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {ArtefactApiOrgsOrgIdArtefactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsGet(requestParameters: ArtefactApiOrgsOrgIdArtefactsGetRequest, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsGet(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactVersionApi - axios parameter creator
 * @export
 */
export const ArtefactVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactVersionId The Artefact Version ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsArtefactVersionIdGet: async (orgId: string, artefactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsArtefactVersionIdGet', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsArtefactVersionIdGet', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactVersionApi - functional programming interface
 * @export
 */
export const ArtefactVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactVersionId The Artefact Version ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsArtefactVersionIdGet(orgId: string, artefactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsArtefactVersionIdGet(orgId, artefactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactVersionApi - factory interface
 * @export
 */
export const ArtefactVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactVersionApiFp(configuration)
    return {
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(requestParameters.orgId, requestParameters.addArtefactVersionPayloadRequest, requestParameters.vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdArtefactVersionsArtefactVersionIdGet operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest
 */
export interface ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGet
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGet
     */
    readonly artefactVersionId: string
}

/**
 * Request parameters for orgsOrgIdArtefactVersionsGet operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest
 */
export interface ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefact Versions by name.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsGet
     */
    readonly name?: string

    /**
     * (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsGet
     */
    readonly reference?: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsGet
     */
    readonly archived?: string
}

/**
 * Request parameters for orgsOrgIdArtefactVersionsPost operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest
 */
export interface ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsPost
     */
    readonly orgId: string

    /**
     * The data needed to register a new Artefact Version within the organization.  
     * @type {AddArtefactVersionPayloadRequest}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsPost
     */
    readonly addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest

    /**
     * (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactVersionsPost
     */
    readonly vcs?: string
}

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdVersionsGet operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest
 */
export interface ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly artefactId: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly archived?: string

    /**
     * (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly reference?: string

    /**
     * (Optional) Limit the number of versions returned by the endpoint.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly limit?: string
}

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch operation in ArtefactVersionApi.
 * @export
 * @interface ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest
 */
export interface ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly artefactId: string

    /**
     * The Version ID.  
     * @type {string}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly versionId: string

    /**
     * The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @type {UpdateArtefactVersionPayloadRequest}
     * @memberof ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest
}

/**
 * ArtefactVersionApi - object-oriented interface
 * @export
 * @class ArtefactVersionApi
 * @extends {BaseAPI}
 */
export class ArtefactVersionApi extends BaseAPI {
    /**
     * Returns a specific Artefact Version.
     * @summary Get an Artefacts Versions.
     * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsGetRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsPost(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactVersionsPostRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(requestParameters.orgId, requestParameters.addArtefactVersionPayloadRequest, requestParameters.vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters: ArtefactVersionApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutomationRuleApi - axios parameter creator
 * @export
 */
export const AutomationRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationRuleApi - functional programming interface
 * @export
 */
export const AutomationRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomationRuleApi - factory interface
 * @export
 */
export const AutomationRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesGet operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesPost operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly envId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut operation in AutomationRuleApi.
 * @export
 * @interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest
 */
export interface AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly ruleId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * AutomationRuleApi - object-oriented interface
 * @export
 * @class AutomationRuleApi
 * @extends {BaseAPI}
 */
export class AutomationRuleApi extends BaseAPI {
    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: AutomationRuleApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeltaApi - axios parameter creator
 * @export
 */
export const DeltaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta: async (orgId: string, appId: string, deltaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('getDelta', 'deltaId', deltaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta: async (orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('putDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('putDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('putDelta', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('putDelta', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeltaApi - functional programming interface
 * @export
 */
export const DeltaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeltaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelta(orgId: string, appId: string, deltaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelta(orgId, appId, deltaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDelta(orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDelta(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeltaApi - factory interface
 * @export
 */
export const DeltaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeltaApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {DeltaApiGetDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta(requestParameters: DeltaApiGetDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {DeltaApiPutDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta(requestParameters: DeltaApiPutDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDelta operation in DeltaApi.
 * @export
 * @interface DeltaApiGetDeltaRequest
 */
export interface DeltaApiGetDeltaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to fetch.  
     * @type {string}
     * @memberof DeltaApiGetDelta
     */
    readonly deltaId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly deltaId: string

    /**
     * Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @type {boolean}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly deltaId: string

    /**
     * The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly deltaId: string

    /**
     * The new name.(NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdPatch operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {Array<DeltaRequest>}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaRequest: Array<DeltaRequest>
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasGet operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly appId: string

    /**
     * If true, return archived Deltas.  
     * @type {boolean}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly archived?: boolean

    /**
     * Only return Deltas associated with the specified Environment.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly env?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasPost operation in DeltaApi.
 * @export
 * @interface DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest
 */
export interface DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly appId: string

    /**
     * A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @type {DeltaRequest}
     * @memberof DeltaApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for putDelta operation in DeltaApi.
 * @export
 * @interface DeltaApiPutDeltaRequest
 */
export interface DeltaApiPutDeltaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof DeltaApiPutDelta
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {DeltaRequest}
     * @memberof DeltaApiPutDelta
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * DeltaApi - object-oriented interface
 * @export
 * @class DeltaApi
 * @extends {BaseAPI}
 */
export class DeltaApi extends BaseAPI {
    /**
     * 
     * @summary Fetch an existing Delta
     * @param {DeltaApiGetDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public getDelta(requestParameters: DeltaApiGetDeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(requestParameters: DeltaApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {DeltaApiPutDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public putDelta(requestParameters: DeltaApiPutDeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet operation in DeploymentApi.
 * @export
 * @interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest
 */
export interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly deployId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet operation in DeploymentApi.
 * @export
 * @interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest
 */
export interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly deployId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet operation in DeploymentApi.
 * @export
 * @interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest
 */
export interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost operation in DeploymentApi.
 * @export
 * @interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest
 */
export interface DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly envId: string

    /**
     * The Delta describing the change to the Environment and a comment.  
     * @type {DeploymentRequest}
     * @memberof DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly deploymentRequest: DeploymentRequest
}

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters: DeploymentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverDefinitionApi - axios parameter creator
 * @export
 */
export const DriverDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverDefinitionApi - functional programming interface
 * @export
 */
export const DriverDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverDefinitionApi - factory interface
 * @export
 */
export const DriverDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdDelete operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest
 */
export interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDelete
     */
    readonly orgId: string

    /**
     * The Resources Driver ID to delete.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDelete
     */
    readonly driverId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdGet operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest
 */
export interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGet
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGet
     */
    readonly driverId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdPut operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest
 */
export interface DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly driverId: string

    /**
     * 
     * @type {UpdateDriverRequestRequest}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly updateDriverRequestRequest: UpdateDriverRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDriversGet operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest
 */
export interface DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversPost operation in DriverDefinitionApi.
 * @export
 * @interface DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest
 */
export interface DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversPost
     */
    readonly orgId: string

    /**
     * Resources Driver details.  
     * @type {CreateDriverRequestRequest}
     * @memberof DriverDefinitionApiOrgsOrgIdResourcesDriversPost
     */
    readonly createDriverRequestRequest: CreateDriverRequestRequest
}

/**
 * DriverDefinitionApi - object-oriented interface
 * @export
 * @class DriverDefinitionApi
 * @extends {BaseAPI}
 */
export class DriverDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdGetRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversDriverIdPutRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversGet(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversGetRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversPost(requestParameters: DriverDefinitionApiOrgsOrgIdResourcesDriversPostRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversPost(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDelete operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest
 */
export interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest
 */
export interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly envId: string

    /**
     * The Deployment ID to rebase to.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdGet operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest
 */
export interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsGet operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest
 */
export interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsPost operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest
 */
export interface EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly appId: string

    /**
     * The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @type {EnvironmentDefinitionRequest}
     * @memberof EnvironmentApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly environmentDefinitionRequest: EnvironmentDefinitionRequest
}

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsGetRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(requestParameters: EnvironmentApiOrgsOrgIdAppsAppIdEnvsPostRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentTypeApi - axios parameter creator
 * @export
 */
export const EnvironmentTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentTypeApi - functional programming interface
 * @export
 */
export const EnvironmentTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentTypeApi - factory interface
 * @export
 */
export const EnvironmentTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentTypeApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeIdDelete operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest
 */
export interface EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDelete
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDelete
     */
    readonly envTypeId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeIdGet operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest
 */
export interface EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGet
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGet
     */
    readonly envTypeId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesGet operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest
 */
export interface EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesPost operation in EnvironmentTypeApi.
 * @export
 * @interface EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest
 */
export interface EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesPost
     */
    readonly orgId: string

    /**
     * New Environment Type.  
     * @type {EnvironmentTypeRequest}
     * @memberof EnvironmentTypeApiOrgsOrgIdEnvTypesPost
     */
    readonly environmentTypeRequest: EnvironmentTypeRequest
}

/**
 * EnvironmentTypeApi - object-oriented interface
 * @export
 * @class EnvironmentTypeApi
 * @extends {BaseAPI}
 */
export class EnvironmentTypeApi extends BaseAPI {
    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesGet(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesGetRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesPost(requestParameters: EnvironmentTypeApiOrgsOrgIdEnvTypesPostRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesPost(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookUpdateResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {EventApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(requestParameters: EventApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdJobsDelete operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdDelete operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdPatch operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly jobId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksPost operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest
 */
export interface EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly appId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof EventApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdEventsGet operation in EventApi.
 * @export
 * @interface EventApiOrgsOrgIdEventsGetRequest
 */
export interface EventApiOrgsOrgIdEventsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof EventApiOrgsOrgIdEventsGet
     */
    readonly orgId: string
}

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(requestParameters: EventApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {EventApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdEventsGet(requestParameters: EventApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {ImageApiOrgsOrgIdImagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(requestParameters: ImageApiOrgsOrgIdImagesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(requestParameters: ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(requestParameters: ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {ImageApiOrgsOrgIdImagesImageIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(requestParameters: ImageApiOrgsOrgIdImagesImageIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdImagesGet operation in ImageApi.
 * @export
 * @interface ImageApiOrgsOrgIdImagesGetRequest
 */
export interface ImageApiOrgsOrgIdImagesGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdImagesImageIdBuildsGet operation in ImageApi.
 * @export
 * @interface ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest
 */
export interface ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdBuildsGet
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdBuildsGet
     */
    readonly imageId: string
}

/**
 * Request parameters for orgsOrgIdImagesImageIdBuildsPost operation in ImageApi.
 * @export
 * @interface ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest
 */
export interface ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly imageId: string

    /**
     * The metadata associated with the build.  
     * @type {ImageBuildRequest}
     * @memberof ImageApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly imageBuildRequest: ImageBuildRequest
}

/**
 * Request parameters for orgsOrgIdImagesImageIdGet operation in ImageApi.
 * @export
 * @interface ImageApiOrgsOrgIdImagesImageIdGetRequest
 */
export interface ImageApiOrgsOrgIdImagesImageIdGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdGet
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof ImageApiOrgsOrgIdImagesImageIdGet
     */
    readonly imageId: string
}

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {ImageApiOrgsOrgIdImagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesGet(requestParameters: ImageApiOrgsOrgIdImagesGetRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(requestParameters: ImageApiOrgsOrgIdImagesImageIdBuildsGetRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(requestParameters: ImageApiOrgsOrgIdImagesImageIdBuildsPostRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {ImageApiOrgsOrgIdImagesImageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdGet(requestParameters: ImageApiOrgsOrgIdImagesImageIdGetRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchingCriteriaApi - axios parameter creator
 * @export
 */
export const MatchingCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingCriteriaApi - functional programming interface
 * @export
 */
export const MatchingCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingCriteriaApi - factory interface
 * @export
 */
export const MatchingCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingCriteriaApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete operation in MatchingCriteriaApi.
 * @export
 * @interface MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest
 */
export interface MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly force?: boolean
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaPost operation in MatchingCriteriaApi.
 * @export
 * @interface MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest
 */
export interface MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * MatchingCriteriaApi - object-oriented interface
 * @export
 * @class MatchingCriteriaApi
 * @extends {BaseAPI}
 */
export class MatchingCriteriaApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: MatchingCriteriaApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: AxiosRequestConfig): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {OrganizationApiOrgsOrgIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(requestParameters: OrganizationApiOrgsOrgIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdGet operation in OrganizationApi.
 * @export
 * @interface OrganizationApiOrgsOrgIdGetRequest
 */
export interface OrganizationApiOrgsOrgIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof OrganizationApiOrgsOrgIdGet
     */
    readonly orgId: string
}

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {OrganizationApiOrgsOrgIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsOrgIdGet(requestParameters: OrganizationApiOrgsOrgIdGetRequest, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsOrgIdGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta: async (orgId: string, appId: string, deltaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('getDelta', 'deltaId', deltaId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSets', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSets', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost: async (orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'envId', envId)
            // verify required parameter 'resourceProvisionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'resourceProvisionRequestRequest', resourceProvisionRequestRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graph`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceProvisionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, diff?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdDelete: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdPatch: async (orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPatch', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationCreationRequest: ApplicationCreationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationCreationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationCreationRequest', applicationCreationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationCreationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactVersionId The Artefact Version ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsArtefactVersionIdGet: async (orgId: string, artefactVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsArtefactVersionIdGet', 'orgId', orgId)
            // verify required parameter 'artefactVersionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsArtefactVersionIdGet', 'artefactVersionId', artefactVersionId)
            const localVarPath = `/orgs/{orgId}/artefact-versions/{artefactVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(artefactVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersPost: async (orgId: string, envType: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'envType', envType)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch: async (orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdDelete: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdDelete', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdDelete', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'patchResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'patchResourceDefinitionRequestRequest', patchResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPut: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {NewServiceUserRequest} newServiceUserRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, newServiceUserRequest: NewServiceUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'newServiceUserRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'newServiceUserRequest', newServiceUserRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newServiceUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdDelete: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdGet: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdPatch: async (orgId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidDelete: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidDelete', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidDelete', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} [metadata] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsPost: async (orgId: string, profileQid: string, metadata?: WorkloadProfileVersionRequest, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsPost', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...(localVarFormParams as any).getHeaders?.(), ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta: async (orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('putDelta', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('putDelta', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('putDelta', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('putDelta', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensGet: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensGet', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensPost: async (userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensPost', 'userId', userId)
            // verify required parameter 'tokenDefinitionRequest' is not null or undefined
            assertParamExists('usersUserIdTokensPost', 'tokenDefinitionRequest', tokenDefinitionRequest)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdDelete: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdDelete', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdGet: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdGet', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdGet', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to fetch.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelta(orgId: string, appId: string, deltaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelta(orgId, appId, deltaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestWorkloadProfileVersion(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestWorkloadProfileVersion(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSets(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSets(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeBodyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(orgId, appId, envId, resourceProvisionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainDeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, diff?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, diff, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdDelete(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdDelete(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdPatch(orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdPatch(orgId, appId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPatch(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationCreationRequest} applicationCreationRequest The request ID, Human-friendly name and environment of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationCreationRequest: ApplicationCreationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationCreationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactVersionId The Artefact Version ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsArtefactVersionIdGet(orgId: string, artefactVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsArtefactVersionIdGet(orgId, artefactVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersPost(orgId: string, envType: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersPost(orgId, envType, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(orgId, envType, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdDelete(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdDelete(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, patchResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPut(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPut(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {NewServiceUserRequest} newServiceUserRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, newServiceUserRequest: NewServiceUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, newServiceUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdDelete(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdDelete(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdGet(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdGet(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdPatch(orgId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdPatch(orgId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidDelete(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidDelete(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} [metadata] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsPost(orgId: string, profileQid: string, metadata?: WorkloadProfileVersionRequest, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsPost(orgId, profileQid, metadata, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {DeltaRequest} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDelta(orgId: string, appId: string, deltaId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDelta(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensGet(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensPost(userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensPost(userId, tokenDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensTokenIdDelete(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensTokenIdDelete(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensTokenIdGet(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensTokenIdGet(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {PublicApiCurrentUserPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(requestParameters: PublicApiCurrentUserPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(requestParameters.userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch an existing Delta
         * @param {PublicApiGetDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelta(requestParameters: PublicApiGetDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {PublicApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion(requestParameters: PublicApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {PublicApiGetSetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets(requestParameters: PublicApiGetSetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SetResponse>> {
            return localVarFp.getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: AxiosRequestConfig): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdDeltasPost200Response> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest, options?: AxiosRequestConfig): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeBodyResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest, options?: AxiosRequestConfig): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {PublicApiOrgsOrgIdAppsAppIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlainDeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {PublicApiOrgsOrgIdAppsAppIdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {PublicApiOrgsOrgIdAppsAppIdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {PublicApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookUpdateResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {PublicApiOrgsOrgIdAppsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(requestParameters: PublicApiOrgsOrgIdAppsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {PublicApiOrgsOrgIdAppsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(requestParameters: PublicApiOrgsOrgIdAppsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific Artefact Version.
         * @summary Get an Artefacts Versions.
         * @param {PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters: PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {PublicApiOrgsOrgIdArtefactVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(requestParameters: PublicApiOrgsOrgIdArtefactVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {PublicApiOrgsOrgIdArtefactVersionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(requestParameters: PublicApiOrgsOrgIdArtefactVersionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(requestParameters.orgId, requestParameters.addArtefactVersionPayloadRequest, requestParameters.vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {PublicApiOrgsOrgIdArtefactsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(requestParameters: PublicApiOrgsOrgIdArtefactsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {PublicApiOrgsOrgIdEnvTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(requestParameters: PublicApiOrgsOrgIdEnvTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {PublicApiOrgsOrgIdEnvTypesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(requestParameters: PublicApiOrgsOrgIdEnvTypesPostRequest, options?: AxiosRequestConfig): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {PublicApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(requestParameters: PublicApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {PublicApiOrgsOrgIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(requestParameters: PublicApiOrgsOrgIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {PublicApiOrgsOrgIdImagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(requestParameters: PublicApiOrgsOrgIdImagesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(requestParameters: PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(requestParameters: PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {PublicApiOrgsOrgIdImagesImageIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(requestParameters: PublicApiOrgsOrgIdImagesImageIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {PublicApiOrgsOrgIdInvitationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(requestParameters: PublicApiOrgsOrgIdInvitationsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {PublicApiOrgsOrgIdInvitationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(requestParameters: PublicApiOrgsOrgIdInvitationsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {PublicApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(requestParameters: PublicApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {PublicApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(requestParameters: PublicApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {PublicApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {PublicApiOrgsOrgIdResourcesAccountTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdDelete(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {PublicApiOrgsOrgIdResourcesAccountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {PublicApiOrgsOrgIdResourcesAccountsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(requestParameters: PublicApiOrgsOrgIdResourcesAccountsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPut(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPut(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {PublicApiOrgsOrgIdResourcesDefsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {PublicApiOrgsOrgIdResourcesDefsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(requestParameters: PublicApiOrgsOrgIdResourcesDefsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {PublicApiOrgsOrgIdResourcesDriversGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(requestParameters: PublicApiOrgsOrgIdResourcesDriversGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {PublicApiOrgsOrgIdResourcesDriversPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(requestParameters: PublicApiOrgsOrgIdResourcesDriversPostRequest, options?: AxiosRequestConfig): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {PublicApiOrgsOrgIdResourcesTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(requestParameters: PublicApiOrgsOrgIdResourcesTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {PublicApiOrgsOrgIdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(requestParameters: PublicApiOrgsOrgIdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {PublicApiOrgsOrgIdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(requestParameters: PublicApiOrgsOrgIdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.orgsOrgIdUsersPost(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {PublicApiOrgsOrgIdUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdUsersUserIdDelete(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {PublicApiOrgsOrgIdUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdUsersUserIdGet(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {PublicApiOrgsOrgIdUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdUsersUserIdPatch(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {PublicApiOrgsOrgIdWorkloadProfilesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {PublicApiOrgsOrgIdWorkloadProfilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesPostRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters.orgId, requestParameters.profileId, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters.orgId, requestParameters.profileQid, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters.orgId, requestParameters.profileQid, requestParameters.metadata, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {PublicApiPutDeltaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDelta(requestParameters: PublicApiPutDeltaRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {PublicApiTokensTokenIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(requestParameters: PublicApiTokensTokenIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {PublicApiUsersUserIdTokensGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensGet(requestParameters: PublicApiUsersUserIdTokensGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TokenInfoResponse>> {
            return localVarFp.usersUserIdTokensGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {PublicApiUsersUserIdTokensPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensPost(requestParameters: PublicApiUsersUserIdTokensPostRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.usersUserIdTokensPost(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {PublicApiUsersUserIdTokensTokenIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdDelete(requestParameters: PublicApiUsersUserIdTokensTokenIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdTokensTokenIdDelete(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {PublicApiUsersUserIdTokensTokenIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdGet(requestParameters: PublicApiUsersUserIdTokensTokenIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<TokenInfoResponse> {
            return localVarFp.usersUserIdTokensTokenIdGet(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for currentUserPatch operation in PublicApi.
 * @export
 * @interface PublicApiCurrentUserPatchRequest
 */
export interface PublicApiCurrentUserPatchRequest {
    /**
     * 
     * @type {UserProfileExtendedRequest}
     * @memberof PublicApiCurrentUserPatch
     */
    readonly userProfileExtendedRequest: UserProfileExtendedRequest
}

/**
 * Request parameters for getDelta operation in PublicApi.
 * @export
 * @interface PublicApiGetDeltaRequest
 */
export interface PublicApiGetDeltaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to fetch.  
     * @type {string}
     * @memberof PublicApiGetDelta
     */
    readonly deltaId: string
}

/**
 * Request parameters for getLatestWorkloadProfileVersion operation in PublicApi.
 * @export
 * @interface PublicApiGetLatestWorkloadProfileVersionRequest
 */
export interface PublicApiGetLatestWorkloadProfileVersionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetLatestWorkloadProfileVersion
     */
    readonly orgId: string

    /**
     * The Workload profile qualified ID.  
     * @type {string}
     * @memberof PublicApiGetLatestWorkloadProfileVersion
     */
    readonly profileQid: string
}

/**
 * Request parameters for getSets operation in PublicApi.
 * @export
 * @interface PublicApiGetSetsRequest
 */
export interface PublicApiGetSetsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiGetSets
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiGetSets
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly deltaId: string

    /**
     * Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly deltaId: string

    /**
     * The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly appId: string

    /**
     * ID of the Deployment Delta.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly deltaId: string

    /**
     * The new name.(NOTE: The string must still be JSON encoded.)  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasDeltaIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {Array<DeltaRequest>}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatch
     */
    readonly deltaRequest: Array<DeltaRequest>
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly appId: string

    /**
     * If true, return archived Deltas.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly archived?: boolean

    /**
     * Only return Deltas associated with the specified Environment.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasGet
     */
    readonly env?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdDeltasPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly appId: string

    /**
     * A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @type {DeltaRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdDeltasPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet
     */
    readonly deployId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly envId: string

    /**
     * The Deployment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet
     */
    readonly deployId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly envId: string

    /**
     * The Delta describing the change to the Environment and a comment.  
     * @type {DeploymentRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPost
     */
    readonly deploymentRequest: DeploymentRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly envId: string

    /**
     * The Deployment ID to rebase to.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut
     */
    readonly body: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly envId: string

    /**
     * Resources to provision.  
     * @type {Array<ResourceProvisionRequestRequest>}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly envId: string

    /**
     * The Resource Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly type: string

    /**
     * The Resource ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete
     */
    readonly resId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly envId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPost
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet
     */
    readonly ruleId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly envId: string

    /**
     * The Automation Rule ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly ruleId: string

    /**
     * The definition of the Automation Rule.  
     * @type {AutomationRuleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut
     */
    readonly automationRuleRequest: AutomationRuleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly envId: string

    /**
     * If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly envId: string

    /**
     * map of replicas by modules.  
     * @type {{ [key: string]: number; }}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly requestBody: { [key: string]: number; }
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly envId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly envId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly appId: string

    /**
     * The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @type {EnvironmentDefinitionRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdEnvsPost
     */
    readonly environmentDefinitionRequest: EnvironmentDefinitionRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdJobsDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdJobsDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdRuntimeGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly appId: string

    /**
     * Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly id?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to diff against.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly sourceSetId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to compared against.
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly diff?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly setId: string

    /**
     * The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @type {DeltaRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdUsersGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdUsersGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdUsersPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly appId: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdValuesPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly appId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDelete
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGet
     */
    readonly jobId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksJobIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly appId: string

    /**
     * The Webhook ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly jobId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatch
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdWebhooksPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest
 */
export interface PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly appId: string

    /**
     * 
     * @type {WebhookRequest}
     * @memberof PublicApiOrgsOrgIdAppsAppIdWebhooksPost
     */
    readonly webhookRequest: WebhookRequest
}

/**
 * Request parameters for orgsOrgIdAppsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsGetRequest
 */
export interface PublicApiOrgsOrgIdAppsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdAppsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdAppsPostRequest
 */
export interface PublicApiOrgsOrgIdAppsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdAppsPost
     */
    readonly orgId: string

    /**
     * The request ID, Human-friendly name and environment of the Application.  
     * @type {ApplicationCreationRequest}
     * @memberof PublicApiOrgsOrgIdAppsPost
     */
    readonly applicationCreationRequest: ApplicationCreationRequest
}

/**
 * Request parameters for orgsOrgIdArtefactVersionsArtefactVersionIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest
 */
export interface PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGet
     */
    readonly orgId: string

    /**
     * The Artefact Version ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGet
     */
    readonly artefactVersionId: string
}

/**
 * Request parameters for orgsOrgIdArtefactVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdArtefactVersionsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefact Versions by name.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsGet
     */
    readonly name?: string

    /**
     * (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsGet
     */
    readonly reference?: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsGet
     */
    readonly archived?: string
}

/**
 * Request parameters for orgsOrgIdArtefactVersionsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactVersionsPostRequest
 */
export interface PublicApiOrgsOrgIdArtefactVersionsPostRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsPost
     */
    readonly orgId: string

    /**
     * The data needed to register a new Artefact Version within the organization.  
     * @type {AddArtefactVersionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsPost
     */
    readonly addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest

    /**
     * (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactVersionsPost
     */
    readonly vcs?: string
}

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdDelete
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdDelete
     */
    readonly artefactId: string
}

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly artefactId: string

    /**
     * (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly archived?: string

    /**
     * (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly reference?: string

    /**
     * (Optional) Limit the number of versions returned by the endpoint.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGet
     */
    readonly limit?: string
}

/**
 * Request parameters for orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest
 */
export interface PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly orgId: string

    /**
     * The Artefact ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly artefactId: string

    /**
     * The Version ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly versionId: string

    /**
     * The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @type {UpdateArtefactVersionPayloadRequest}
     * @memberof PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch
     */
    readonly updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdArtefactsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdArtefactsGetRequest
 */
export interface PublicApiOrgsOrgIdArtefactsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Artefacts by type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsGet
     */
    readonly type?: string

    /**
     * (Optional) Filter Artefacts by name.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdArtefactsGet
     */
    readonly name?: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeIdDelete
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeIdDelete
     */
    readonly envTypeId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeIdGet
     */
    readonly orgId: string

    /**
     * ID of the Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeIdGet
     */
    readonly envTypeId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly envType: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for orgsOrgIdEnvTypesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesGetRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEnvTypesPostRequest
 */
export interface PublicApiOrgsOrgIdEnvTypesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEnvTypesPost
     */
    readonly orgId: string

    /**
     * New Environment Type.  
     * @type {EnvironmentTypeRequest}
     * @memberof PublicApiOrgsOrgIdEnvTypesPost
     */
    readonly environmentTypeRequest: EnvironmentTypeRequest
}

/**
 * Request parameters for orgsOrgIdEventsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdEventsGetRequest
 */
export interface PublicApiOrgsOrgIdEventsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdEventsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdGetRequest
 */
export interface PublicApiOrgsOrgIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdImagesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdImagesGetRequest
 */
export interface PublicApiOrgsOrgIdImagesGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdImagesImageIdBuildsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest
 */
export interface PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdBuildsGet
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdBuildsGet
     */
    readonly imageId: string
}

/**
 * Request parameters for orgsOrgIdImagesImageIdBuildsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest
 */
export interface PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly imageId: string

    /**
     * The metadata associated with the build.  
     * @type {ImageBuildRequest}
     * @memberof PublicApiOrgsOrgIdImagesImageIdBuildsPost
     */
    readonly imageBuildRequest: ImageBuildRequest
}

/**
 * Request parameters for orgsOrgIdImagesImageIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdImagesImageIdGetRequest
 */
export interface PublicApiOrgsOrgIdImagesImageIdGetRequest {
    /**
     * The organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdGet
     */
    readonly orgId: string

    /**
     * The Image ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdImagesImageIdGet
     */
    readonly imageId: string
}

/**
 * Request parameters for orgsOrgIdInvitationsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdInvitationsGetRequest
 */
export interface PublicApiOrgsOrgIdInvitationsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdInvitationsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdInvitationsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdInvitationsPostRequest
 */
export interface PublicApiOrgsOrgIdInvitationsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdInvitationsPost
     */
    readonly orgId: string

    /**
     * The email and the desired role  
     * @type {UserInviteRequestRequest}
     * @memberof PublicApiOrgsOrgIdInvitationsPost
     */
    readonly userInviteRequestRequest: UserInviteRequestRequest
}

/**
 * Request parameters for orgsOrgIdRegistriesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesPostRequest
 */
export interface PublicApiOrgsOrgIdRegistriesPostRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesPost
     */
    readonly orgId: string

    /**
     * A new record details.  
     * @type {RegistryRequest}
     * @memberof PublicApiOrgsOrgIdRegistriesPost
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdCredsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdGetRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdRegistriesRegIdPatchRequest
 */
export interface PublicApiOrgsOrgIdRegistriesRegIdPatchRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly regId: string

    /**
     * Record details to update.  
     * @type {RegistryRequest}
     * @memberof PublicApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdResourcesAccountTypesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountTypesGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountTypesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdDelete
     */
    readonly accId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdGet
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdGet
     */
    readonly accId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly accId: string

    /**
     * 
     * @type {UpdateResourceAccountRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountsGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesAccountsPostRequest
 */
export interface PublicApiOrgsOrgIdResourcesAccountsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsPost
     */
    readonly orgId: string

    /**
     * 
     * @type {CreateResourceAccountRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesAccountsPost
     */
    readonly createResourceAccountRequestRequest: CreateResourceAccountRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly force?: boolean
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly defId: string

    /**
     * If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @type {boolean}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly force?: boolean
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdGet
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdGet
     */
    readonly defId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @type {PatchResourceDefinitionRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
     * @type {UpdateResourceDefinitionRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdResourcesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly defId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Application.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly app?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly env?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly envType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly res?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsGet
     */
    readonly resType?: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDefsPostRequest
 */
export interface PublicApiOrgsOrgIdResourcesDefsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDefsPost
     */
    readonly orgId: string

    /**
     * The Resource Definition details.  
     * @type {CreateResourceDefinitionRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDefsPost
     */
    readonly createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdDelete
     */
    readonly orgId: string

    /**
     * The Resources Driver ID to delete.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdDelete
     */
    readonly driverId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdGet
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdGet
     */
    readonly driverId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversDriverIdPut operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest
 */
export interface PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly orgId: string

    /**
     * The Resource Driver ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly driverId: string

    /**
     * 
     * @type {UpdateDriverRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDriversDriverIdPut
     */
    readonly updateDriverRequestRequest: UpdateDriverRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDriversGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDriversGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesDriversGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDriversPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesDriversPostRequest
 */
export interface PublicApiOrgsOrgIdResourcesDriversPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesDriversPost
     */
    readonly orgId: string

    /**
     * Resources Driver details.  
     * @type {CreateDriverRequestRequest}
     * @memberof PublicApiOrgsOrgIdResourcesDriversPost
     */
    readonly createDriverRequestRequest: CreateDriverRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesTypesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdResourcesTypesGetRequest
 */
export interface PublicApiOrgsOrgIdResourcesTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdResourcesTypesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdUsersGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdUsersGetRequest
 */
export interface PublicApiOrgsOrgIdUsersGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdUsersPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdUsersPostRequest
 */
export interface PublicApiOrgsOrgIdUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersPost
     */
    readonly orgId: string

    /**
     * The user ID and the role  
     * @type {NewServiceUserRequest}
     * @memberof PublicApiOrgsOrgIdUsersPost
     */
    readonly newServiceUserRequest: NewServiceUserRequest
}

/**
 * Request parameters for orgsOrgIdUsersUserIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdUsersUserIdDeleteRequest
 */
export interface PublicApiOrgsOrgIdUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdUsersUserIdGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdUsersUserIdGetRequest
 */
export interface PublicApiOrgsOrgIdUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdUsersUserIdPatch operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdUsersUserIdPatchRequest
 */
export interface PublicApiOrgsOrgIdUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user the role  
     * @type {RoleRequest}
     * @memberof PublicApiOrgsOrgIdUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesGetRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesPostRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesPost
     */
    readonly orgId: string

    /**
     * Workload profile details.  
     * @type {WorkloadProfileRequest}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesPost
     */
    readonly workloadProfileRequest: WorkloadProfileRequest
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly orgId: string

    /**
     * The Workload profile ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly profileId: string

    /**
     * The Version.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly version: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidDelete operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidDelete
     */
    readonly orgId: string

    /**
     * The Workload profile ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidDelete
     */
    readonly profileQid: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidGet
     */
    readonly orgId: string

    /**
     * The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidGet
     */
    readonly profileQid: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidVersionsGet operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly orgId: string

    /**
     * The Workload profile qualified ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly profileQid: string

    /**
     * Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly version?: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidVersionsPost operation in PublicApi.
 * @export
 * @interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest
 */
export interface PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.  
     * @type {string}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly profileQid: string

    /**
     * 
     * @type {WorkloadProfileVersionRequest}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly metadata?: WorkloadProfileVersionRequest

    /**
     * 
     * @type {File}
     * @memberof PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly file?: File
}

/**
 * Request parameters for putDelta operation in PublicApi.
 * @export
 * @interface PublicApiPutDeltaRequest
 */
export interface PublicApiPutDeltaRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly appId: string

    /**
     * ID of the Delta to update.  
     * @type {string}
     * @memberof PublicApiPutDelta
     */
    readonly deltaId: string

    /**
     * An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @type {DeltaRequest}
     * @memberof PublicApiPutDelta
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * Request parameters for tokensTokenIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiTokensTokenIdDeleteRequest
 */
export interface PublicApiTokensTokenIdDeleteRequest {
    /**
     * The token ID  
     * @type {string}
     * @memberof PublicApiTokensTokenIdDelete
     */
    readonly tokenId: string
}

/**
 * Request parameters for usersUserIdTokensGet operation in PublicApi.
 * @export
 * @interface PublicApiUsersUserIdTokensGetRequest
 */
export interface PublicApiUsersUserIdTokensGetRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensGet
     */
    readonly userId: string
}

/**
 * Request parameters for usersUserIdTokensPost operation in PublicApi.
 * @export
 * @interface PublicApiUsersUserIdTokensPostRequest
 */
export interface PublicApiUsersUserIdTokensPostRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensPost
     */
    readonly userId: string

    /**
     * The definition of the token.  
     * @type {TokenDefinitionRequest}
     * @memberof PublicApiUsersUserIdTokensPost
     */
    readonly tokenDefinitionRequest: TokenDefinitionRequest
}

/**
 * Request parameters for usersUserIdTokensTokenIdDelete operation in PublicApi.
 * @export
 * @interface PublicApiUsersUserIdTokensTokenIdDeleteRequest
 */
export interface PublicApiUsersUserIdTokensTokenIdDeleteRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensTokenIdDelete
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensTokenIdDelete
     */
    readonly tokenId: string
}

/**
 * Request parameters for usersUserIdTokensTokenIdGet operation in PublicApi.
 * @export
 * @interface PublicApiUsersUserIdTokensTokenIdGetRequest
 */
export interface PublicApiUsersUserIdTokensTokenIdGetRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensTokenIdGet
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof PublicApiUsersUserIdTokensTokenIdGet
     */
    readonly tokenId: string
}

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {PublicApiCurrentUserPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserPatch(requestParameters: PublicApiCurrentUserPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserPatch(requestParameters.userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch an existing Delta
     * @param {PublicApiGetDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getDelta(requestParameters: PublicApiGetDeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Latest version of the given workload profile with optional constraint.
     * @param {PublicApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getLatestWorkloadProfileVersion(requestParameters: PublicApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Deployment Sets
     * @param {PublicApiGetSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public getSets(requestParameters: PublicApiGetSetsRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataArchivedPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataEnvIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdMetadataNamePut(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasDeltaIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(requestParameters.orgId, requestParameters.appId, requestParameters.archived, requestParameters.env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdDeltasPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(requestParameters.orgId, requestParameters.appId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdDeploysPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.type, requestParameters.resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.ruleId, requestParameters.automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Environment Version history.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdEnvsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(requestParameters.orgId, requestParameters.appId, requestParameters.environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {PublicApiOrgsOrgIdAppsAppIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdJobsDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdRuntimeGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an App
     * @param {PublicApiOrgsOrgIdAppsAppIdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {PublicApiOrgsOrgIdAppsAppIdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Version history.
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {PublicApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.jobId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(requestParameters: PublicApiOrgsOrgIdAppsAppIdWebhooksPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(requestParameters.orgId, requestParameters.appId, requestParameters.webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {PublicApiOrgsOrgIdAppsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsGet(requestParameters: PublicApiOrgsOrgIdAppsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {PublicApiOrgsOrgIdAppsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsPost(requestParameters: PublicApiOrgsOrgIdAppsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsPost(requestParameters.orgId, requestParameters.applicationCreationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific Artefact Version.
     * @summary Get an Artefacts Versions.
     * @param {PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters: PublicApiOrgsOrgIdArtefactVersionsArtefactVersionIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsArtefactVersionIdGet(requestParameters.orgId, requestParameters.artefactVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {PublicApiOrgsOrgIdArtefactVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsGet(requestParameters: PublicApiOrgsOrgIdArtefactVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(requestParameters.orgId, requestParameters.name, requestParameters.reference, requestParameters.archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {PublicApiOrgsOrgIdArtefactVersionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsPost(requestParameters: PublicApiOrgsOrgIdArtefactVersionsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(requestParameters.orgId, requestParameters.addArtefactVersionPayloadRequest, requestParameters.vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(requestParameters.orgId, requestParameters.artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(requestParameters.orgId, requestParameters.artefactId, requestParameters.archived, requestParameters.reference, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters: PublicApiOrgsOrgIdArtefactsArtefactIdVersionsVersionIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(requestParameters.orgId, requestParameters.artefactId, requestParameters.versionId, requestParameters.updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {PublicApiOrgsOrgIdArtefactsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsGet(requestParameters: PublicApiOrgsOrgIdArtefactsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsGet(requestParameters.orgId, requestParameters.type, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(requestParameters.orgId, requestParameters.envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Environment Type with a Role
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {PublicApiOrgsOrgIdEnvTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesGet(requestParameters: PublicApiOrgsOrgIdEnvTypesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {PublicApiOrgsOrgIdEnvTypesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesPost(requestParameters: PublicApiOrgsOrgIdEnvTypesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesPost(requestParameters.orgId, requestParameters.environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {PublicApiOrgsOrgIdEventsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEventsGet(requestParameters: PublicApiOrgsOrgIdEventsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEventsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {PublicApiOrgsOrgIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdGet(requestParameters: PublicApiOrgsOrgIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {PublicApiOrgsOrgIdImagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesGet(requestParameters: PublicApiOrgsOrgIdImagesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(requestParameters: PublicApiOrgsOrgIdImagesImageIdBuildsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(requestParameters: PublicApiOrgsOrgIdImagesImageIdBuildsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(requestParameters.orgId, requestParameters.imageId, requestParameters.imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {PublicApiOrgsOrgIdImagesImageIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdGet(requestParameters: PublicApiOrgsOrgIdImagesImageIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdGet(requestParameters.orgId, requestParameters.imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {PublicApiOrgsOrgIdInvitationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsGet(requestParameters: PublicApiOrgsOrgIdInvitationsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {PublicApiOrgsOrgIdInvitationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsPost(requestParameters: PublicApiOrgsOrgIdInvitationsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsPost(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {PublicApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesGet(requestParameters: PublicApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {PublicApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesPost(requestParameters: PublicApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdDelete(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdGet(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {PublicApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdPatch(requestParameters: PublicApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {PublicApiOrgsOrgIdResourcesAccountTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountTypesGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountTypesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an unused Resource Account.
     * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdDelete(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(requestParameters: PublicApiOrgsOrgIdResourcesAccountsAccIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {PublicApiOrgsOrgIdResourcesAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsGet(requestParameters: PublicApiOrgsOrgIdResourcesAccountsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {PublicApiOrgsOrgIdResourcesAccountsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsPost(requestParameters: PublicApiOrgsOrgIdResourcesAccountsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdPut(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPut(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {PublicApiOrgsOrgIdResourcesDefsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsGet(requestParameters: PublicApiOrgsOrgIdResourcesDefsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsGet(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {PublicApiOrgsOrgIdResourcesDefsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsPost(requestParameters: PublicApiOrgsOrgIdResourcesDefsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsPost(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(requestParameters.orgId, requestParameters.driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(requestParameters: PublicApiOrgsOrgIdResourcesDriversDriverIdPutRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(requestParameters.orgId, requestParameters.driverId, requestParameters.updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {PublicApiOrgsOrgIdResourcesDriversGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversGet(requestParameters: PublicApiOrgsOrgIdResourcesDriversGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {PublicApiOrgsOrgIdResourcesDriversPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversPost(requestParameters: PublicApiOrgsOrgIdResourcesDriversPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversPost(requestParameters.orgId, requestParameters.createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Types.
     * @param {PublicApiOrgsOrgIdResourcesTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesTypesGet(requestParameters: PublicApiOrgsOrgIdResourcesTypesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {PublicApiOrgsOrgIdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersGet(requestParameters: PublicApiOrgsOrgIdUsersGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {PublicApiOrgsOrgIdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersPost(requestParameters: PublicApiOrgsOrgIdUsersPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersPost(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Organization
     * @param {PublicApiOrgsOrgIdUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersUserIdDelete(requestParameters: PublicApiOrgsOrgIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersUserIdDelete(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Organization
     * @param {PublicApiOrgsOrgIdUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersUserIdGet(requestParameters: PublicApiOrgsOrgIdUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersUserIdGet(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Organization
     * @param {PublicApiOrgsOrgIdUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersUserIdPatch(requestParameters: PublicApiOrgsOrgIdUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersUserIdPatch(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {PublicApiOrgsOrgIdWorkloadProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {PublicApiOrgsOrgIdWorkloadProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesPost(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters.orgId, requestParameters.profileId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters.orgId, requestParameters.profileQid, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters: PublicApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters.orgId, requestParameters.profileQid, requestParameters.metadata, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {PublicApiPutDeltaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public putDelta(requestParameters: PublicApiPutDeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).putDelta(requestParameters.orgId, requestParameters.appId, requestParameters.deltaId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {PublicApiTokensTokenIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensTokenIdDelete(requestParameters: PublicApiTokensTokenIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensTokenIdDelete(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists tokens associated with a user
     * @param {PublicApiUsersUserIdTokensGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersUserIdTokensGet(requestParameters: PublicApiUsersUserIdTokensGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersUserIdTokensGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is only supported for users of type `service`.
     * @summary Creates a new static token for a user.
     * @param {PublicApiUsersUserIdTokensPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersUserIdTokensPost(requestParameters: PublicApiUsersUserIdTokensPostRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersUserIdTokensPost(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
     * @summary Deletes a specific token associated with a user
     * @param {PublicApiUsersUserIdTokensTokenIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersUserIdTokensTokenIdDelete(requestParameters: PublicApiUsersUserIdTokensTokenIdDeleteRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersUserIdTokensTokenIdDelete(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific token associated with a user
     * @param {PublicApiUsersUserIdTokensTokenIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersUserIdTokensTokenIdGet(requestParameters: PublicApiUsersUserIdTokensTokenIdGetRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersUserIdTokensTokenIdGet(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {RegistryApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(requestParameters: RegistryApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {RegistryApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(requestParameters: RegistryApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdRegistriesGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesPost operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesPostRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesPostRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesPost
     */
    readonly orgId: string

    /**
     * A new record details.  
     * @type {RegistryRequest}
     * @memberof RegistryApiOrgsOrgIdRegistriesPost
     */
    readonly registryRequest: RegistryRequest
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdCredsGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdCredsGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdDelete operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdDelete
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdGet operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdGetRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdGetRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdGet
     */
    readonly regId: string
}

/**
 * Request parameters for orgsOrgIdRegistriesRegIdPatch operation in RegistryApi.
 * @export
 * @interface RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest
 */
export interface RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest {
    /**
     * Unique (alpha-numerical) organization identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly orgId: string

    /**
     * Unique (alpha-numerical) registry identifier.  
     * @type {string}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly regId: string

    /**
     * Record details to update.  
     * @type {RegistryRequest}
     * @memberof RegistryApiOrgsOrgIdRegistriesRegIdPatch
     */
    readonly registryRequest: RegistryRequest
}

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {RegistryApiOrgsOrgIdRegistriesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesGet(requestParameters: RegistryApiOrgsOrgIdRegistriesGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {RegistryApiOrgsOrgIdRegistriesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesPost(requestParameters: RegistryApiOrgsOrgIdRegistriesPostRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesPost(requestParameters.orgId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdCredsGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdDelete(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdDeleteRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdGet(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdGetRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(requestParameters.orgId, requestParameters.regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdPatch(requestParameters: RegistryApiOrgsOrgIdRegistriesRegIdPatchRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(requestParameters.orgId, requestParameters.regId, requestParameters.registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceAccountApi - axios parameter creator
 * @export
 */
export const ResourceAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdDelete: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdDelete', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdDelete', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceAccountApi - functional programming interface
 * @export
 */
export const ResourceAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdDelete(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdDelete(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceAccountApi - factory interface
 * @export
 */
export const ResourceAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an unused Resource Account.
         * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdDelete(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdDelete(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(requestParameters.orgId, requestParameters.accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdDelete operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest
 */
export interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDelete
     */
    readonly accId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdGet operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest
 */
export interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGet
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGet
     */
    readonly accId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsAccIdPatch operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest
 */
export interface ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly orgId: string

    /**
     * The Resource Account ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly accId: string

    /**
     * 
     * @type {UpdateResourceAccountRequestRequest}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatch
     */
    readonly updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsGet operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest
 */
export interface ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdResourcesAccountsPost operation in ResourceAccountApi.
 * @export
 * @interface ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest
 */
export interface ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsPost
     */
    readonly orgId: string

    /**
     * 
     * @type {CreateResourceAccountRequestRequest}
     * @memberof ResourceAccountApiOrgsOrgIdResourcesAccountsPost
     */
    readonly createResourceAccountRequestRequest: CreateResourceAccountRequestRequest
}

/**
 * ResourceAccountApi - object-oriented interface
 * @export
 * @class ResourceAccountApi
 * @extends {BaseAPI}
 */
export class ResourceAccountApi extends BaseAPI {
    /**
     * 
     * @summary Delete an unused Resource Account.
     * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdDelete(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdDeleteRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdDelete(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdGetRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(requestParameters.orgId, requestParameters.accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsAccIdPatchRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(requestParameters.orgId, requestParameters.accId, requestParameters.updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsGet(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsGetRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsPost(requestParameters: ResourceAccountApiOrgsOrgIdResourcesAccountsPostRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(requestParameters.orgId, requestParameters.createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceDefinitionApi - axios parameter creator
 * @export
 */
export const ResourceDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'patchResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'patchResourceDefinitionRequestRequest', patchResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPut: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPut', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceDefinitionApi - functional programming interface
 * @export
 */
export const ResourceDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {PatchResourceDefinitionRequestRequest} patchResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, patchResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPut(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPut(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceDefinitionApi - factory interface
 * @export
 */
export const ResourceDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceDefinitionApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPut(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPut(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly defId: string

    /**
     * The Matching Criteria ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly criteriaId: string

    /**
     * If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @type {boolean}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete
     */
    readonly force?: boolean
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdCriteriaPost operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly defId: string

    /**
     * Matching Criteria rules.  
     * @type {MatchingCriteriaRuleRequest}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPost
     */
    readonly matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdDelete operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly defId: string

    /**
     * If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @type {boolean}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDelete
     */
    readonly force?: boolean
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdGet operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGet
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGet
     */
    readonly defId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdPatch operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as PatchResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @type {PatchResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatch
     */
    readonly patchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdPut operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly defId: string

    /**
     * The Resource Definition record details.  The PUT operation updates a resource definition using the provided payload. An empty driver_account or driver_inputs property will unset the existing values.  Currently the resource and driver types can\&#39;t be changed.
     * @type {UpdateResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPut
     */
    readonly updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest
}

/**
 * Request parameters for orgsOrgIdResourcesDefsDefIdResourcesGet operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly orgId: string

    /**
     * The Resource Definition ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGet
     */
    readonly defId: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsGet operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly orgId: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Application.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly app?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly env?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly envType?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly res?: string

    /**
     * (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsGet
     */
    readonly resType?: string
}

/**
 * Request parameters for orgsOrgIdResourcesDefsPost operation in ResourceDefinitionApi.
 * @export
 * @interface ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest
 */
export interface ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsPost
     */
    readonly orgId: string

    /**
     * The Resource Definition details.  
     * @type {CreateResourceDefinitionRequestRequest}
     * @memberof ResourceDefinitionApiOrgsOrgIdResourcesDefsPost
     */
    readonly createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest
}

/**
 * ResourceDefinitionApi - object-oriented interface
 * @export
 * @class ResourceDefinitionApi
 * @extends {BaseAPI}
 */
export class ResourceDefinitionApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDeleteRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.criteriaId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdCriteriaPostRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(requestParameters.orgId, requestParameters.defId, requestParameters.matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdDeleteRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(requestParameters.orgId, requestParameters.defId, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdGetRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPatchRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(requestParameters.orgId, requestParameters.defId, requestParameters.patchResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdPut(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdPutRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPut(requestParameters.orgId, requestParameters.defId, requestParameters.updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsDefIdResourcesGetRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(requestParameters.orgId, requestParameters.defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsGet(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsGetRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsGet(requestParameters.orgId, requestParameters.app, requestParameters.env, requestParameters.envType, requestParameters.res, requestParameters.resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsPost(requestParameters: ResourceDefinitionApiOrgsOrgIdResourcesDefsPostRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsPost(requestParameters.orgId, requestParameters.createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceProvisionApi - axios parameter creator
 * @export
 */
export const ResourceProvisionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost: async (orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'envId', envId)
            // verify required parameter 'resourceProvisionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost', 'resourceProvisionRequestRequest', resourceProvisionRequestRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graph`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resourceProvisionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceProvisionApi - functional programming interface
 * @export
 */
export const ResourceProvisionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceProvisionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {Array<ResourceProvisionRequestRequest>} resourceProvisionRequestRequest Resources to provision.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(orgId: string, appId: string, envId: string, resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeBodyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(orgId, appId, envId, resourceProvisionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceProvisionApi - factory interface
 * @export
 */
export const ResourceProvisionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceProvisionApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
         * @param {ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters: ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeBodyResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost operation in ResourceProvisionApi.
 * @export
 * @interface ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest
 */
export interface ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly envId: string

    /**
     * Resources to provision.  
     * @type {Array<ResourceProvisionRequestRequest>}
     * @memberof ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost
     */
    readonly resourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>
}

/**
 * ResourceProvisionApi - object-oriented interface
 * @export
 * @class ResourceProvisionApi
 * @extends {BaseAPI}
 */
export class ResourceProvisionApi extends BaseAPI {
    /**
     * 
     * @summary Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @param {ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceProvisionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters: ResourceProvisionApiOrgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPostRequest, options?: AxiosRequestConfig) {
        return ResourceProvisionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGraphPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.resourceProvisionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceTypeApi - axios parameter creator
 * @export
 */
export const ResourceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceTypeApi - functional programming interface
 * @export
 */
export const ResourceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceTypeApi - factory interface
 * @export
 */
export const ResourceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(requestParameters: ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdResourcesTypesGet operation in ResourceTypeApi.
 * @export
 * @interface ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest
 */
export interface ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ResourceTypeApiOrgsOrgIdResourcesTypesGet
     */
    readonly orgId: string
}

/**
 * ResourceTypeApi - object-oriented interface
 * @export
 * @class ResourceTypeApi
 * @extends {BaseAPI}
 */
export class ResourceTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Types.
     * @param {ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypeApi
     */
    public orgsOrgIdResourcesTypesGet(requestParameters: ResourceTypeApiOrgsOrgIdResourcesTypesGetRequest, options?: AxiosRequestConfig) {
        return ResourceTypeApiFp(this.configuration).orgsOrgIdResourcesTypesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuntimeInfoApi - axios parameter creator
 * @export
 */
export const RuntimeInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuntimeInfoApi - functional programming interface
 * @export
 */
export const RuntimeInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuntimeInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuntimeInfoApi - factory interface
 * @export
 */
export const RuntimeInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuntimeInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest, options?: AxiosRequestConfig): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest
 */
export interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest
 */
export interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly envId: string

    /**
     * If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @type {boolean}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut
     */
    readonly body: boolean
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest
 */
export interface RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly envId: string

    /**
     * map of replicas by modules.  
     * @type {{ [key: string]: number; }}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch
     */
    readonly requestBody: { [key: string]: number; }
}

/**
 * Request parameters for orgsOrgIdAppsAppIdRuntimeGet operation in RuntimeInfoApi.
 * @export
 * @interface RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest
 */
export interface RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly appId: string

    /**
     * Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @type {string}
     * @memberof RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGet
     */
    readonly id?: string
}

/**
 * RuntimeInfoApi - object-oriented interface
 * @export
 * @class RuntimeInfoApi
 * @extends {BaseAPI}
 */
export class RuntimeInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeGetRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPutRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatchRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(requestParameters: RuntimeInfoApiOrgsOrgIdAppsAppIdRuntimeGetRequest, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(requestParameters.orgId, requestParameters.appId, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetApi - axios parameter creator
 * @export
 */
export const SetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getSets', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('getSets', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, diff?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (diff !== undefined) {
                localVarQueryParameter['diff'] = diff;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetApi - functional programming interface
 * @export
 */
export const SetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSets(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSets(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainDeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} [diff] ID of the Deployment Set to compared against.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, diff?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, diff, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetApi - factory interface
 * @export
 */
export const SetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all Deployment Sets
         * @param {SetApiGetSetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSets(requestParameters: SetApiGetSetsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<SetResponse>> {
            return localVarFp.getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PlainDeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<OrgsOrgIdAppsAppIdSetsSetIdGet200Response> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSets operation in SetApi.
 * @export
 * @interface SetApiGetSetsRequest
 */
export interface SetApiGetSetsRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SetApiGetSets
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof SetApiGetSets
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to diff against.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet
     */
    readonly sourceSetId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdGet operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly setId: string

    /**
     * ID of the Deployment Set to compared against.
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdGet
     */
    readonly diff?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdSetsSetIdPost operation in SetApi.
 * @export
 * @interface SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest
 */
export interface SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly appId: string

    /**
     * ID of the Deployment Set.  
     * @type {string}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly setId: string

    /**
     * The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @type {DeltaRequest}
     * @memberof SetApiOrgsOrgIdAppsAppIdSetsSetIdPost
     */
    readonly deltaRequest: DeltaRequest
}

/**
 * SetApi - object-oriented interface
 * @export
 * @class SetApi
 * @extends {BaseAPI}
 */
export class SetApi extends BaseAPI {
    /**
     * 
     * @summary Get all Deployment Sets
     * @param {SetApiGetSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public getSets(requestParameters: SetApiGetSetsRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).getSets(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGetRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdGetRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.diff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters: SetApiOrgsOrgIdAppsAppIdSetsSetIdPostRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(requestParameters.orgId, requestParameters.appId, requestParameters.setId, requestParameters.deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenInfoApi - axios parameter creator
 * @export
 */
export const TokenInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensGet: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensGet', 'userId', userId)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensPost: async (userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensPost', 'userId', userId)
            // verify required parameter 'tokenDefinitionRequest' is not null or undefined
            assertParamExists('usersUserIdTokensPost', 'tokenDefinitionRequest', tokenDefinitionRequest)
            const localVarPath = `/users/{userId}/tokens`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdDelete: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdDelete', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdGet: async (userId: string, tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdGet', 'userId', userId)
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('usersUserIdTokensTokenIdGet', 'tokenId', tokenId)
            const localVarPath = `/users/{userId}/tokens/{tokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenInfoApi - functional programming interface
 * @export
 */
export const TokenInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {string} userId The user ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensGet(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {string} userId The user ID.  
         * @param {TokenDefinitionRequest} tokenDefinitionRequest The definition of the token.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensPost(userId: string, tokenDefinitionRequest: TokenDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensPost(userId, tokenDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensTokenIdDelete(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensTokenIdDelete(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {string} userId The user ID.  
         * @param {string} tokenId The token ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdTokensTokenIdGet(userId: string, tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdTokensTokenIdGet(userId, tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenInfoApi - factory interface
 * @export
 */
export const TokenInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists tokens associated with a user
         * @param {TokenInfoApiUsersUserIdTokensGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensGet(requestParameters: TokenInfoApiUsersUserIdTokensGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<TokenInfoResponse>> {
            return localVarFp.usersUserIdTokensGet(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This is only supported for users of type `service`.
         * @summary Creates a new static token for a user.
         * @param {TokenInfoApiUsersUserIdTokensPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensPost(requestParameters: TokenInfoApiUsersUserIdTokensPostRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.usersUserIdTokensPost(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
         * @summary Deletes a specific token associated with a user
         * @param {TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdDelete(requestParameters: TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersUserIdTokensTokenIdDelete(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a specific token associated with a user
         * @param {TokenInfoApiUsersUserIdTokensTokenIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdTokensTokenIdGet(requestParameters: TokenInfoApiUsersUserIdTokensTokenIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<TokenInfoResponse> {
            return localVarFp.usersUserIdTokensTokenIdGet(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersUserIdTokensGet operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiUsersUserIdTokensGetRequest
 */
export interface TokenInfoApiUsersUserIdTokensGetRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensGet
     */
    readonly userId: string
}

/**
 * Request parameters for usersUserIdTokensPost operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiUsersUserIdTokensPostRequest
 */
export interface TokenInfoApiUsersUserIdTokensPostRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensPost
     */
    readonly userId: string

    /**
     * The definition of the token.  
     * @type {TokenDefinitionRequest}
     * @memberof TokenInfoApiUsersUserIdTokensPost
     */
    readonly tokenDefinitionRequest: TokenDefinitionRequest
}

/**
 * Request parameters for usersUserIdTokensTokenIdDelete operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest
 */
export interface TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensTokenIdDelete
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensTokenIdDelete
     */
    readonly tokenId: string
}

/**
 * Request parameters for usersUserIdTokensTokenIdGet operation in TokenInfoApi.
 * @export
 * @interface TokenInfoApiUsersUserIdTokensTokenIdGetRequest
 */
export interface TokenInfoApiUsersUserIdTokensTokenIdGetRequest {
    /**
     * The user ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensTokenIdGet
     */
    readonly userId: string

    /**
     * The token ID.  
     * @type {string}
     * @memberof TokenInfoApiUsersUserIdTokensTokenIdGet
     */
    readonly tokenId: string
}

/**
 * TokenInfoApi - object-oriented interface
 * @export
 * @class TokenInfoApi
 * @extends {BaseAPI}
 */
export class TokenInfoApi extends BaseAPI {
    /**
     * 
     * @summary Lists tokens associated with a user
     * @param {TokenInfoApiUsersUserIdTokensGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public usersUserIdTokensGet(requestParameters: TokenInfoApiUsersUserIdTokensGetRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).usersUserIdTokensGet(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is only supported for users of type `service`.
     * @summary Creates a new static token for a user.
     * @param {TokenInfoApiUsersUserIdTokensPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public usersUserIdTokensPost(requestParameters: TokenInfoApiUsersUserIdTokensPostRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).usersUserIdTokensPost(requestParameters.userId, requestParameters.tokenDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is only possible for static tokens. To revoke session tokens - use `POST /auth/logout` with the required session token.
     * @summary Deletes a specific token associated with a user
     * @param {TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public usersUserIdTokensTokenIdDelete(requestParameters: TokenInfoApiUsersUserIdTokensTokenIdDeleteRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).usersUserIdTokensTokenIdDelete(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a specific token associated with a user
     * @param {TokenInfoApiUsersUserIdTokensTokenIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenInfoApi
     */
    public usersUserIdTokensTokenIdGet(requestParameters: TokenInfoApiUsersUserIdTokensTokenIdGetRequest, options?: AxiosRequestConfig) {
        return TokenInfoApiFp(this.configuration).usersUserIdTokensTokenIdGet(requestParameters.userId, requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserInviteApi - axios parameter creator
 * @export
 */
export const UserInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInviteApi - functional programming interface
 * @export
 */
export const UserInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserInviteApi - factory interface
 * @export
 */
export const UserInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInviteApiFp(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {UserInviteApiOrgsOrgIdInvitationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(requestParameters: UserInviteApiOrgsOrgIdInvitationsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdInvitationsGet operation in UserInviteApi.
 * @export
 * @interface UserInviteApiOrgsOrgIdInvitationsGetRequest
 */
export interface UserInviteApiOrgsOrgIdInvitationsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserInviteApiOrgsOrgIdInvitationsGet
     */
    readonly orgId: string
}

/**
 * UserInviteApi - object-oriented interface
 * @export
 * @class UserInviteApi
 * @extends {BaseAPI}
 */
export class UserInviteApi extends BaseAPI {
    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {UserInviteApiOrgsOrgIdInvitationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInviteApi
     */
    public orgsOrgIdInvitationsGet(requestParameters: UserInviteApiOrgsOrgIdInvitationsGetRequest, options?: AxiosRequestConfig) {
        return UserInviteApiFp(this.configuration).orgsOrgIdInvitationsGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {NewServiceUserRequest} newServiceUserRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, newServiceUserRequest: NewServiceUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'newServiceUserRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'newServiceUserRequest', newServiceUserRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newServiceUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {NewServiceUserRequest} newServiceUserRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, newServiceUserRequest: NewServiceUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, newServiceUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileApiCurrentUserPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(requestParameters: UserProfileApiCurrentUserPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(requestParameters.userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {UserProfileApiOrgsOrgIdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(requestParameters: UserProfileApiOrgsOrgIdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.orgsOrgIdUsersPost(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {UserProfileApiTokensTokenIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(requestParameters: UserProfileApiTokensTokenIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(requestParameters.tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for currentUserPatch operation in UserProfileApi.
 * @export
 * @interface UserProfileApiCurrentUserPatchRequest
 */
export interface UserProfileApiCurrentUserPatchRequest {
    /**
     * 
     * @type {UserProfileExtendedRequest}
     * @memberof UserProfileApiCurrentUserPatch
     */
    readonly userProfileExtendedRequest: UserProfileExtendedRequest
}

/**
 * Request parameters for orgsOrgIdUsersPost operation in UserProfileApi.
 * @export
 * @interface UserProfileApiOrgsOrgIdUsersPostRequest
 */
export interface UserProfileApiOrgsOrgIdUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserProfileApiOrgsOrgIdUsersPost
     */
    readonly orgId: string

    /**
     * The user ID and the role  
     * @type {NewServiceUserRequest}
     * @memberof UserProfileApiOrgsOrgIdUsersPost
     */
    readonly newServiceUserRequest: NewServiceUserRequest
}

/**
 * Request parameters for tokensTokenIdDelete operation in UserProfileApi.
 * @export
 * @interface UserProfileApiTokensTokenIdDeleteRequest
 */
export interface UserProfileApiTokensTokenIdDeleteRequest {
    /**
     * The token ID  
     * @type {string}
     * @memberof UserProfileApiTokensTokenIdDelete
     */
    readonly tokenId: string
}

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileApiCurrentUserPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserPatch(requestParameters: UserProfileApiCurrentUserPatchRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserPatch(requestParameters.userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {UserProfileApiOrgsOrgIdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public orgsOrgIdUsersPost(requestParameters: UserProfileApiOrgsOrgIdUsersPostRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).orgsOrgIdUsersPost(requestParameters.orgId, requestParameters.newServiceUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {UserProfileApiTokensTokenIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensTokenIdDelete(requestParameters: UserProfileApiTokensTokenIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensTokenIdDelete(requestParameters.tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRoleApi - axios parameter creator
 * @export
 */
export const UserRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdDelete: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdPatch: async (orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersPost: async (orgId: string, envType: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'envType', envType)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch: async (orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/env-types/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdDelete: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdDelete', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdGet: async (orgId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdPatch: async (orgId: string, userId: string, roleRequest: RoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'userId', userId)
            // verify required parameter 'roleRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersUserIdPatch', 'roleRequest', roleRequest)
            const localVarPath = `/orgs/{orgId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRoleApi - functional programming interface
 * @export
 */
export const UserRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdDelete(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdDelete(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdPatch(orgId: string, appId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdPatch(orgId, appId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersPost(orgId: string, envType: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersPost(orgId, envType, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(orgId: string, envType: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(orgId, envType, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdDelete(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdDelete(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdGet(orgId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdGet(orgId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {string} orgId The Organization ID.  
         * @param {string} userId The User ID  
         * @param {RoleRequest} roleRequest The new user the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersUserIdPatch(orgId: string, userId: string, roleRequest: RoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersUserIdPatch(orgId, userId, roleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRoleApi - factory interface
 * @export
 */
export const UserRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRoleApiFp(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Application
         * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Application
         * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Environment Type with a Role
         * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Environment Type
         * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Environment Type
         * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {UserRoleApiOrgsOrgIdInvitationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(requestParameters: UserRoleApiOrgsOrgIdInvitationsPostRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {UserRoleApiOrgsOrgIdUsersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(requestParameters: UserRoleApiOrgsOrgIdUsersGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the role of a User on an Organization
         * @param {UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdUsersUserIdDelete(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Organization
         * @param {UserRoleApiOrgsOrgIdUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdUsersUserIdGet(requestParameters.orgId, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the role of a User on an Organization
         * @param {UserRoleApiOrgsOrgIdUsersUserIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdPatchRequest, options?: AxiosRequestConfig): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdUsersUserIdPatch(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest
 */
export interface UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersPost operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest
 */
export interface UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly appId: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersPost
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdDelete operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest
 */
export interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest
 */
export interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdUsersUserIdPatch operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest
 */
export interface UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly appId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersPost operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest
 */
export interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly envType: string

    /**
     * The user ID and the role  
     * @type {UserRoleRequest}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPost
     */
    readonly userRoleRequest: UserRoleRequest
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest
 */
export interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest
 */
export interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest
 */
export interface UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The Environment Type.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly envType: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user role  
     * @type {RoleRequest}
     * @memberof UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * Request parameters for orgsOrgIdInvitationsPost operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdInvitationsPostRequest
 */
export interface UserRoleApiOrgsOrgIdInvitationsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdInvitationsPost
     */
    readonly orgId: string

    /**
     * The email and the desired role  
     * @type {UserInviteRequestRequest}
     * @memberof UserRoleApiOrgsOrgIdInvitationsPost
     */
    readonly userInviteRequestRequest: UserInviteRequestRequest
}

/**
 * Request parameters for orgsOrgIdUsersGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdUsersGetRequest
 */
export interface UserRoleApiOrgsOrgIdUsersGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdUsersUserIdDelete operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest
 */
export interface UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdDelete
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdDelete
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdUsersUserIdGet operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdUsersUserIdGetRequest
 */
export interface UserRoleApiOrgsOrgIdUsersUserIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdGet
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdGet
     */
    readonly userId: string
}

/**
 * Request parameters for orgsOrgIdUsersUserIdPatch operation in UserRoleApi.
 * @export
 * @interface UserRoleApiOrgsOrgIdUsersUserIdPatchRequest
 */
export interface UserRoleApiOrgsOrgIdUsersUserIdPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdPatch
     */
    readonly orgId: string

    /**
     * The User ID  
     * @type {string}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdPatch
     */
    readonly userId: string

    /**
     * The new user the role  
     * @type {RoleRequest}
     * @memberof UserRoleApiOrgsOrgIdUsersUserIdPatch
     */
    readonly roleRequest: RoleRequest
}

/**
 * UserRoleApi - object-oriented interface
 * @export
 * @class UserRoleApi
 * @extends {BaseAPI}
 */
export class UserRoleApi extends BaseAPI {
    /**
     * 
     * @summary List Users with roles in an App
     * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersGet(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersGetRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersPost(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersPostRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(requestParameters.orgId, requestParameters.appId, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Application
     * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdDelete(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Application
     * @param {UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdAppsAppIdUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdPatch(requestParameters.orgId, requestParameters.appId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Environment Type with a Role
     * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersPostRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersPost(requestParameters.orgId, requestParameters.envType, requestParameters.userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Environment Type
     * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdDelete(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdGet(requestParameters.orgId, requestParameters.envType, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Environment Type
     * @param {UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdEnvTypesEnvTypeUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeUsersUserIdPatch(requestParameters.orgId, requestParameters.envType, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {UserRoleApiOrgsOrgIdInvitationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdInvitationsPost(requestParameters: UserRoleApiOrgsOrgIdInvitationsPostRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdInvitationsPost(requestParameters.orgId, requestParameters.userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {UserRoleApiOrgsOrgIdUsersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersGet(requestParameters: UserRoleApiOrgsOrgIdUsersGetRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the role of a User on an Organization
     * @param {UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersUserIdDelete(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdDeleteRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersUserIdDelete(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Organization
     * @param {UserRoleApiOrgsOrgIdUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersUserIdGet(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdGetRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersUserIdGet(requestParameters.orgId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the role of a User on an Organization
     * @param {UserRoleApiOrgsOrgIdUsersUserIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersUserIdPatch(requestParameters: UserRoleApiOrgsOrgIdUsersUserIdPatchRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersUserIdPatch(requestParameters.orgId, requestParameters.userId, requestParameters.roleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueApi - axios parameter creator
 * @export
 */
export const ValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueApi - functional programming interface
 * @export
 */
export const ValueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueApi - factory interface
 * @export
 */
export const ValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {ValueApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDelete
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesGet operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGet
     */
    readonly envId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly envId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValuesPost operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly envId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesDelete
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesGet operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesGetRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesGet
     */
    readonly appId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyDelete operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyDelete
     */
    readonly key: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPatch operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly key: string

    /**
     * At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValuePatchPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPatch
     */
    readonly valuePatchPayloadRequest: ValuePatchPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesKeyPut operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly appId: string

    /**
     * The key to update.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly key: string

    /**
     * Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @type {ValueEditPayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesKeyPut
     */
    readonly valueEditPayloadRequest: ValueEditPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValuesPost operation in ValueApi.
 * @export
 * @interface ValueApiOrgsOrgIdAppsAppIdValuesPostRequest
 */
export interface ValueApiOrgsOrgIdAppsAppIdValuesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly appId: string

    /**
     * Definition of the new Shared Value.  
     * @type {ValueCreatePayloadRequest}
     * @memberof ValueApiOrgsOrgIdAppsAppIdValuesPost
     */
    readonly valueCreatePayloadRequest: ValueCreatePayloadRequest
}

/**
 * ValueApi - object-oriented interface
 * @export
 * @class ValueApi
 * @extends {BaseAPI}
 */
export class ValueApi extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesGet(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesGetRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(requestParameters.orgId, requestParameters.appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyDeleteRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters.orgId, requestParameters.appId, requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPatchRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesKeyPutRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(requestParameters.orgId, requestParameters.appId, requestParameters.key, requestParameters.valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {ValueApiOrgsOrgIdAppsAppIdValuesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesPost(requestParameters: ValueApiOrgsOrgIdAppsAppIdValuesPostRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueSetVersionApi - axios parameter creator
 * @export
 */
export const ValueSetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueSetVersionApi - functional programming interface
 * @export
 */
export const ValueSetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueSetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueSetVersionApi - factory interface
 * @export
 */
export const ValueSetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueSetVersionApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Environment Version history.
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
         * @summary Purge the value of a specific Shared Value from the App Version history.
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a specific key from the Value Set Version in an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
         * @summary Restore a Value Set Version in an App
         * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly envId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The Environment ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly envId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly appId: string

    /**
     * (Optional) Return only value set version where the specified key changed  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGet
     */
    readonly keyChanged?: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet
     */
    readonly valueSetVersionId: string
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be purged.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetVersionId: string

    /**
     * Key of the value to be restored.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly key: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * Request parameters for orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost operation in ValueSetVersionApi.
 * @export
 * @interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest
 */
export interface ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly orgId: string

    /**
     * The Application ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly appId: string

    /**
     * The ValueSetVersion ID.  
     * @type {string}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetVersionId: string

    /**
     * 
     * @type {ValueSetActionPayloadRequest}
     * @memberof ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost
     */
    readonly valueSetActionPayloadRequest: ValueSetActionPayloadRequest
}

/**
 * ValueSetVersionApi - object-oriented interface
 * @export
 * @class ValueSetVersionApi
 * @extends {BaseAPI}
 */
export class ValueSetVersionApi extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Environment Version history.
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.envId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters.orgId, requestParameters.appId, requestParameters.keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * @summary Purge the value of a specific Shared Value from the App Version history.
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a specific key from the Value Set Version in an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.key, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * @summary Restore a Value Set Version in an App
     * @param {ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: ValueSetVersionApiOrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters.orgId, requestParameters.appId, requestParameters.valueSetVersionId, requestParameters.valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkloadProfileApi - axios parameter creator
 * @export
 */
export const WorkloadProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('getLatestWorkloadProfileVersion', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions/latest`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidDelete: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidDelete', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidDelete', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} [metadata] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsPost: async (orgId: string, profileQid: string, metadata?: WorkloadProfileVersionRequest, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsPost', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...(localVarFormParams as any).getHeaders?.(), ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkloadProfileApi - functional programming interface
 * @export
 */
export const WorkloadProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkloadProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestWorkloadProfileVersion(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestWorkloadProfileVersion(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidDelete(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidDelete(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} [metadata] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsPost(orgId: string, profileQid: string, metadata?: WorkloadProfileVersionRequest, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsPost(orgId, profileQid, metadata, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkloadProfileApi - factory interface
 * @export
 */
export const WorkloadProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkloadProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Latest version of the given workload profile with optional constraint.
         * @param {WorkloadProfileApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestWorkloadProfileVersion(requestParameters: WorkloadProfileApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(requestParameters.orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters.orgId, requestParameters.profileId, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters.orgId, requestParameters.profileQid, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters.orgId, requestParameters.profileQid, requestParameters.metadata, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLatestWorkloadProfileVersion operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiGetLatestWorkloadProfileVersionRequest
 */
export interface WorkloadProfileApiGetLatestWorkloadProfileVersionRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiGetLatestWorkloadProfileVersion
     */
    readonly orgId: string

    /**
     * The Workload profile qualified ID.  
     * @type {string}
     * @memberof WorkloadProfileApiGetLatestWorkloadProfileVersion
     */
    readonly profileQid: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesGet operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesGet
     */
    readonly orgId: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesPost operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesPost
     */
    readonly orgId: string

    /**
     * Workload profile details.  
     * @type {WorkloadProfileRequest}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesPost
     */
    readonly workloadProfileRequest: WorkloadProfileRequest
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly orgId: string

    /**
     * The Workload profile ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly profileId: string

    /**
     * The Version.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete
     */
    readonly version: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidDelete operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDelete
     */
    readonly orgId: string

    /**
     * The Workload profile ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDelete
     */
    readonly profileQid: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidGet operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGet
     */
    readonly orgId: string

    /**
     * The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGet
     */
    readonly profileQid: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidVersionsGet operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly orgId: string

    /**
     * The Workload profile qualified ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly profileQid: string

    /**
     * Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGet
     */
    readonly version?: string
}

/**
 * Request parameters for orgsOrgIdWorkloadProfilesProfileQidVersionsPost operation in WorkloadProfileApi.
 * @export
 * @interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest
 */
export interface WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest {
    /**
     * The Organization ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly orgId: string

    /**
     * The Workload Profile ID.  
     * @type {string}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly profileQid: string

    /**
     * 
     * @type {WorkloadProfileVersionRequest}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly metadata?: WorkloadProfileVersionRequest

    /**
     * 
     * @type {File}
     * @memberof WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPost
     */
    readonly file?: File
}

/**
 * WorkloadProfileApi - object-oriented interface
 * @export
 * @class WorkloadProfileApi
 * @extends {BaseAPI}
 */
export class WorkloadProfileApi extends BaseAPI {
    /**
     * 
     * @summary Latest version of the given workload profile with optional constraint.
     * @param {WorkloadProfileApiGetLatestWorkloadProfileVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public getLatestWorkloadProfileVersion(requestParameters: WorkloadProfileApiGetLatestWorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).getLatestWorkloadProfileVersion(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesGetRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesPost(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesPostRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(requestParameters.orgId, requestParameters.workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileIdVersionsVersionDeleteRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(requestParameters.orgId, requestParameters.profileId, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidDeleteRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidDelete(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidGetRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(requestParameters.orgId, requestParameters.profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsGetRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(requestParameters.orgId, requestParameters.profileQid, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters: WorkloadProfileApiOrgsOrgIdWorkloadProfilesProfileQidVersionsPostRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsPost(requestParameters.orgId, requestParameters.profileQid, requestParameters.metadata, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}


