/* tslint:disable */
/* eslint-disable */
/**
 * Humanitec API
 * # Introduction The *Humanitec API* allows you to automate and integrate Humanitec into your developer and operational workflows. The API is a REST based API. It is based around a set of concepts:  * Core * External Resources * Sets and Deltas  ## Authentication Almost all requests made to the Humanitec API require Authentication. Humanitec provides 2 ways of authenticating with the API: `Bearer` and `JWT`.  ### Bearer Authentication This form of authentication makes use of a **static token**. It is intended to be used when machines interact with the Humanitec API. Bearer tokens should be used for very narrow purposes. This allows for the token to be revoked if it is compromised and so limit the scope of exposure. New Bearer tokens can be obtained via the UI:  1. Log into Humanitec at https://app.humanitec.io 1. Go to **Organization Settings** 1. Select **API tokens** 1. Enter a *name* for the new token and click on **Generate new token**  The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_TOKEN`, the request could be made as follows:  ```     curl -H \'Authorization: Bearer HUMANITEC_TOKEN\' https://api.humanitec.io/orgs/my-org/apps ```  ### JWT Authentication This form of authentication makes use of a **JSON Web Token (JWT)**. It is intended to be used when humans interact with the Humanitec API. JWTs expire after a period of time. This means that a new JWT will need to be generated regularly. This makes them well suited to working in short sessions, but not for automation. (See Bearer Authentication.) The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_JWT`, the request could be made as follows:  ```     curl -H \'Authorization: JWT HUMANITEC_JWT\' https://api.humanitec.io/orgs/my-org/apps ```  ## Content Types All of the Humanitec API unless explicitly only accepts content types of `application/json` and will always return valid `application/json` or an empty response.  ## Response Codes ### Success Any response code in the `2xx` range should be regarded as success.  | **Code** | **Meaning** | | --- | --- | | `200` | Success | | `201` | Success (In future, `201` will be replaced by `200`) | | `204` | Success, but no content in response |  _Note: We plan to simplify the interface by replacing 201 with 200 status codes._  ### Failure Any response code in the `4xx` should be regarded as an error which can be rectified by the client. `5xx` error codes indicate errors that cannot be corrected by the client.  | **Code** | **Meaning** | | --- | --- | | `400` | General error. (Body will contain details) | | `401` | Attempt to access protected resource without `Authorization` Header. | | `403` | The `Bearer` or `JWT` does not grant access to the requested resource. | | `404` | Resource not found. | | `405` | Method not allowed | | `409` | Conflict. Usually indicated a resource with that ID already exists. | | `422` | Unprocessable Entity. The body was not valid JSON, was empty or contained an object different from what was expected. | | `429` | Too many requests - request rate limit has been reached. | | `500` | Internal Error. If it occurs repeatedly, contact support. | 
 *
 * The version of the OpenAPI document: 0.20.3
 * Contact: apiteam@humanitec.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsRequest
 */
export interface AccountCredsRequest {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'username': string;
}
/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsResponse
 */
export interface AccountCredsResponse {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'username': string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeRequest
 */
export interface AccountTypeRequest {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'name'?: string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'type'?: string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeResponse
 */
export interface AccountTypeResponse {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'name': string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'type': string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceRequest
 */
export interface ActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'app_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'def_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_id'?: string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_type'?: string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'org_id'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'res_id'?: string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'status'?: string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'type'?: string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'updated_at'?: string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceResponse
 */
export interface ActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'def_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_type': string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'res_id': string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * AddArtefactVersionPayload describes the payload for a new ArtefactVersion request.
 * @export
 * @interface AddArtefactVersionPayloadRequest
 */
export interface AddArtefactVersionPayloadRequest {
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'digest'?: string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'ref'?: string;
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'type': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'version'?: string;
}
/**
 * AddArtefactVersionPayload describes the payload for a new ArtefactVersion request.
 * @export
 * @interface AddArtefactVersionPayloadResponse
 */
export interface AddArtefactVersionPayloadResponse {
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'commit': string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'digest': string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'ref': string;
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'type': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'version': string;
}
/**
 * An Application is a collection of Modules that work together. When deployed, all Modules in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Modules that work together. When deployed, all Modules in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * The timestamp in UTC indicates when the Application was created.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_at': string;
    /**
     * The user who created the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_by': string;
    /**
     * The Environments associated with the Application.
     * @type {Array<EnvironmentBaseResponse>}
     * @memberof ApplicationResponse
     */
    'envs': Array<EnvironmentBaseResponse>;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactRequest
 */
export interface ArtefactRequest {
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'type': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactResponse
 */
export interface ArtefactResponse {
    /**
     * The time when the Artefact was added to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'type': string;
    /**
     * The time when the Artefact was updated for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who updated the Artefact for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_by'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionRequest
 */
export interface ArtefactVersionRequest {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionRequest
     */
    'archived'?: boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'digest'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'ref'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'version'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionResponse
 */
export interface ArtefactVersionResponse {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionResponse
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'commit': string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'digest': string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'ref': string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'version': string;
}
/**
 * AsyncProgressHint describes ongoing asynchronous operation.
 * @export
 * @interface AsyncProgressHintRequest
 */
export interface AsyncProgressHintRequest {
    /**
     * The date and time of when the operation will be aborted if not yet finished.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'deadline'?: string;
    /**
     * Estimated date and time of when the operation is expected to be completed.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'estimate'?: string;
    /**
     * Current status.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'status'?: string;
    /**
     * Current (reference) date and time.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'timestamp'?: string;
}
/**
 * AsyncProgressHint describes ongoing asynchronous operation.
 * @export
 * @interface AsyncProgressHintResponse
 */
export interface AsyncProgressHintResponse {
    /**
     * The date and time of when the operation will be aborted if not yet finished.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'deadline'?: string;
    /**
     * Estimated date and time of when the operation is expected to be completed.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'estimate'?: string;
    /**
     * Current status.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'status': string;
    /**
     * Current (reference) date and time.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'timestamp'?: string;
}
/**
 * An Automation Rule defining how and when images in an environment should be updated.
 * @export
 * @interface AutomationRuleRequest
 */
export interface AutomationRuleRequest {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'active'?: boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'artefacts_filter'?: Array<string>;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_artefacts_filter'?: boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_images_filter'?: boolean;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'images_filter'?: Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match'?: string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match_ref'?: string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'update_to'?: string;
}
/**
 * An Automation Rule defining how and when images in an environment should be updated.
 * @export
 * @interface AutomationRuleResponse
 */
export interface AutomationRuleResponse {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'active': boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'artefacts_filter': Array<string>;
    /**
     * The timestamp in UTC of when the Automation Rule was created.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'created_at': string;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_artefacts_filter': boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_images_filter': boolean;
    /**
     * The unique ID for this rule.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'id': string;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'images_filter': Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match': string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match_ref': string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'update_to': string;
    /**
     * The timestamp in UTC of when the Automation Rule was updated.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'updated_at': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretRequest
 */
export interface ClusterSecretRequest {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'secret': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretResponse
 */
export interface ClusterSecretResponse {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'secret': string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerRequest
 */
export interface ControllerRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PodStateRequest>}
     * @memberof ControllerRequest
     */
    'pods'?: Array<PodStateRequest>;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'replicas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'status'?: string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerResponse
 */
export interface ControllerResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<PodStateResponse>}
     * @memberof ControllerResponse
     */
    'pods': Array<PodStateResponse>;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'replicas': number;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'status': string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestRequest
 */
export interface CreateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof CreateDriverRequestRequest
     */
    'is_public'?: boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'url_prefix'?: string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestResponse
 */
export interface CreateDriverRequestResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof CreateDriverRequestResponse
     */
    'is_public': boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestResponse
     */
    'template': any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'url_prefix': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequestRequest
 */
export interface CreateOrganizationRequestRequest {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestRequest
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequestResponse
 */
export interface CreateOrganizationRequestResponse {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestResponse
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestResponse
     */
    'name': string;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestRequest
 */
export interface CreateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'id'?: string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'type'?: string;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestResponse
 */
export interface CreateResourceAccountRequestResponse {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestResponse
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'id': string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'type': string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestRequest
 */
export interface CreateResourceDefinitionRequestRequest {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'type': string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestResponse
 */
export interface CreateResourceDefinitionRequestResponse {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_account': string;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_inputs': ValuesSecretsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'name': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeltaMetadataRequest
 */
export interface DeltaMetadataRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataRequest
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'last_modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'shared'?: boolean;
}
/**
 * 
 * @export
 * @interface DeltaMetadataResponse
 */
export interface DeltaMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'archived': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataResponse
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'last_modified_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'shared'?: boolean;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaRequest
 */
export interface DeltaRequest {
    /**
     * 
     * @type {DeltaMetadataRequest}
     * @memberof DeltaRequest
     */
    'metadata'?: DeltaMetadataRequest;
    /**
     * 
     * @type {ModuleDeltasRequest}
     * @memberof DeltaRequest
     */
    'modules'?: ModuleDeltasRequest;
    /**
     * 
     * @type {Array<UpdateActionRequest>}
     * @memberof DeltaRequest
     */
    'shared'?: Array<UpdateActionRequest>;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaResponse
 */
export interface DeltaResponse {
    /**
     * A unique ID for the Delta
     * @type {string}
     * @memberof DeltaResponse
     */
    'id': string;
    /**
     * 
     * @type {DeltaMetadataResponse}
     * @memberof DeltaResponse
     */
    'metadata': DeltaMetadataResponse;
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof DeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof DeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionRequest
 */
export interface DeployConditionRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'success'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionRequest
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'when'?: string;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionResponse
 */
export interface DeployConditionResponse {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'success': string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionResponse
     */
    'timeout': number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'when': string;
}
/**
 * DeploymentError is an error happening during deployment
 * @export
 * @interface DeploymentErrorRequest
 */
export interface DeploymentErrorRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'error_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'object_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'summary'?: string;
}
/**
 * DeploymentError is an error happening during deployment
 * @export
 * @interface DeploymentErrorResponse
 */
export interface DeploymentErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'error_type': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'object_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'summary': string;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentRequest
 */
export interface DeploymentRequest {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'comment'?: string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'delta_id'?: string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'value_set_version_id'?: string | null;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentResponse
 */
export interface DeploymentResponse {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'comment': string;
    /**
     * The Timestamp of when the Deployment was initiated.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_at': string;
    /**
     * The user who initiated the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_by': string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'delta_id'?: string;
    /**
     * The Environment where the Deployment occurred.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'env_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_file': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_status': string;
    /**
     * The ID of the Deployment that this Deployment was based on.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'from_id': string;
    /**
     * The ID of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'id': string;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'set_id': string;
    /**
     * The current status of the Deployment. Can be `pending`, `in progress`, `succeeded`, or `failed`.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status': string;
    /**
     * The timestamp of the last `status` change. If `status` is `succeeded` or `failed` it it will indicate when the Deployment finished.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status_changed_at': string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'value_set_version_id'?: string | null;
}
/**
 * DeploymentTimestamps aggregates creation dates of current and next succeful deployments
 * @export
 * @interface DeploymentTimestampsRequest
 */
export interface DeploymentTimestampsRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsRequest
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsRequest
     */
    'stopped_at'?: string | null;
}
/**
 * DeploymentTimestamps aggregates creation dates of current and next succeful deployments
 * @export
 * @interface DeploymentTimestampsResponse
 */
export interface DeploymentTimestampsResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsResponse
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsResponse
     */
    'stopped_at'?: string | null;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionRequest
 */
export interface DriverDefinitionRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionRequest
     */
    'account_types'?: Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof DriverDefinitionRequest
     */
    'is_public'?: boolean;
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'org_id'?: string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'type'?: string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see `url_prefix`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'url_prefix'?: string;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionResponse
 */
export interface DriverDefinitionResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof DriverDefinitionResponse
     */
    'is_public': boolean;
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'org_id': string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionResponse
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see `url_prefix`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'url_prefix'?: string;
}
/**
 * DriverInputs describes the resource and the input paramaters for the driver.
 * @export
 * @interface DriverInputsRequest
 */
export interface DriverInputsRequest {
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof DriverInputsRequest
     */
    'driver'?: ValuesSecretsRequest;
    /**
     * The resource-related parameters passed from the deployment set (if any).
     * @type {{ [key: string]: any; }}
     * @memberof DriverInputsRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * The type of the resource to generate.
     * @type {string}
     * @memberof DriverInputsRequest
     */
    'type'?: string;
}
/**
 * DriverInputs describes the resource and the input paramaters for the driver.
 * @export
 * @interface DriverInputsResponse
 */
export interface DriverInputsResponse {
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof DriverInputsResponse
     */
    'driver': ValuesSecretsResponse;
    /**
     * The resource-related parameters passed from the deployment set (if any).
     * @type {{ [key: string]: any; }}
     * @memberof DriverInputsResponse
     */
    'resource': { [key: string]: any; };
    /**
     * The type of the resource to generate.
     * @type {string}
     * @memberof DriverInputsResponse
     */
    'type': string;
}
/**
 * DriverOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface DriverOutputsRequest
 */
export interface DriverOutputsRequest {
    /**
     * The resource GUResID.
     * @type {string}
     * @memberof DriverOutputsRequest
     */
    'id'?: string;
    /**
     * The resource definition manifests (if any).
     * @type {Array<ManifestRequest>}
     * @memberof DriverOutputsRequest
     */
    'manifests'?: Array<ManifestRequest>;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof DriverOutputsRequest
     */
    'resource'?: ValuesSecretsRequest;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof DriverOutputsRequest
     */
    'type'?: string;
}
/**
 * DriverOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface DriverOutputsResponse
 */
export interface DriverOutputsResponse {
    /**
     * The resource GUResID.
     * @type {string}
     * @memberof DriverOutputsResponse
     */
    'id': string;
    /**
     * The resource definition manifests (if any).
     * @type {Array<ManifestResponse>}
     * @memberof DriverOutputsResponse
     */
    'manifests': Array<ManifestResponse>;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof DriverOutputsResponse
     */
    'resource': ValuesSecretsResponse;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof DriverOutputsResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseRequest
 */
export interface EnvironmentBaseRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseResponse
 */
export interface EnvironmentBaseResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionRequest
 */
export interface EnvironmentDefinitionRequest {
    /**
     * Defines the existing Deployment the new Environment will be based on.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'from_deploy_id': string;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionResponse
 */
export interface EnvironmentDefinitionResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'type': string;
}
/**
 * EnvironmentPausedInfo
 * @export
 * @interface EnvironmentPausedInfoRequest
 */
export interface EnvironmentPausedInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentPausedInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentPausedInfoRequest
     */
    'paused'?: boolean;
}
/**
 * EnvironmentPausedInfo
 * @export
 * @interface EnvironmentPausedInfoResponse
 */
export interface EnvironmentPausedInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentPausedInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentPausedInfoResponse
     */
    'paused': boolean;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentRequest
 */
export interface EnvironmentRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'type': string;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentResponse
 */
export interface EnvironmentResponse {
    /**
     * The timestamp in UTC of when the Environment was created.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_at': string;
    /**
     * The user who created the Environment
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_by': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'from_deploy'?: DeploymentResponse;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'last_deploy'?: DeploymentResponse;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'type': string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoRequest
 */
export interface EnvironmentRuntimeInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'paused'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'status'?: string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoResponse
 */
export interface EnvironmentRuntimeInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'paused': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'status'?: string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeRequest
 */
export interface EnvironmentTypeRequest {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'description'?: string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'id': string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeResponse
 */
export interface EnvironmentTypeResponse {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'description': string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'id': string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoRequest
 */
export interface ErrorInfoRequest {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoRequest
     */
    'error'?: string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoResponse
 */
export interface ErrorInfoResponse {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoResponse
     */
    'error': string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseRequest
 */
export interface EventBaseRequest {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseRequest
     */
    'type'?: string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseResponse
 */
export interface EventBaseResponse {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseResponse
     */
    'type': string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventRequest
 */
export interface EventRequest {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventRequest
     */
    'properties'?: Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventRequest
     */
    'type'?: string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventResponse
     */
    'properties': Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
}
/**
 * ExportFile is export file URL and metadata, it\'s  what export endpoint returns
 * @export
 * @interface ExportFileRequest
 */
export interface ExportFileRequest {
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'url'?: string;
}
/**
 * ExportFile is export file URL and metadata, it\'s  what export endpoint returns
 * @export
 * @interface ExportFileResponse
 */
export interface ExportFileResponse {
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'size': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'url': string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorRequest
 */
export interface HumanitecErrorRequest {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorRequest
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorRequest
     */
    'error'?: string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorRequest
     */
    'message'?: string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorResponse
 */
export interface HumanitecErrorResponse {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorResponse
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'error': string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'message': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface IdPRequest
 */
export interface IdPRequest {
    /**
     * ID of an existing user with permissions to apply roles to new users within the org.
     * @type {string}
     * @memberof IdPRequest
     */
    'authorizing_user_id': string;
    /**
     * One or more domains that this IdP should be associated to.
     * @type {Array<string>}
     * @memberof IdPRequest
     */
    'domains': Array<string>;
    /**
     * ID used to refere to the IdP in Humanitec
     * @type {string}
     * @memberof IdPRequest
     */
    'id': string;
    /**
     * Base64 encoded SAML IdP Metadata XML
     * @type {Array<number>}
     * @memberof IdPRequest
     */
    'metadata': Array<number>;
    /**
     * A possibly empty array of additional roles on objects that the user should have.
     * @type {Array<ObjectRoleRequest>}
     * @memberof IdPRequest
     */
    'object_roles': Array<ObjectRoleRequest>;
    /**
     * ID of the Organization that the new user should be added to.
     * @type {string}
     * @memberof IdPRequest
     */
    'org_id': string;
    /**
     * The role that the new user should have on the organization
     * @type {string}
     * @memberof IdPRequest
     */
    'role': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface IdPResponse
 */
export interface IdPResponse {
    /**
     * ID of an existing user with permissions to apply roles to new users within the org.
     * @type {string}
     * @memberof IdPResponse
     */
    'authorizing_user_id': string;
    /**
     * One or more domains that this IdP should be associated to.
     * @type {Array<string>}
     * @memberof IdPResponse
     */
    'domains': Array<string>;
    /**
     * ID used to refere to the IdP in Humanitec
     * @type {string}
     * @memberof IdPResponse
     */
    'id': string;
    /**
     * Base64 encoded SAML IdP Metadata XML
     * @type {Array<number>}
     * @memberof IdPResponse
     */
    'metadata': Array<number>;
    /**
     * A possibly empty array of additional roles on objects that the user should have.
     * @type {Array<ObjectRoleResponse>}
     * @memberof IdPResponse
     */
    'object_roles': Array<ObjectRoleResponse>;
    /**
     * ID of the Organization that the new user should be added to.
     * @type {string}
     * @memberof IdPResponse
     */
    'org_id': string;
    /**
     * The role that the new user should have on the organization
     * @type {string}
     * @memberof IdPResponse
     */
    'role': string;
}
/**
 * IdentityToken holds the Identity providers temporary token along with the provider it is associated to.
 * @export
 * @interface IdentityTokenRequest
 */
export interface IdentityTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenRequest
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenRequest
     */
    'token'?: string;
}
/**
 * IdentityToken holds the Identity providers temporary token along with the provider it is associated to.
 * @export
 * @interface IdentityTokenResponse
 */
export interface IdentityTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenResponse
     */
    'token': string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildRequest
 */
export interface ImageBuildRequest {
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'branch'?: string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'commit'?: string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'image'?: string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildRequest
     */
    'tags'?: Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildResponse
 */
export interface ImageBuildResponse {
    /**
     * The time when the build was added to Humanitec.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'added_at'?: string;
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'branch': string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'commit': string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'image': string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildResponse
     */
    'tags': Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageRequest
 */
export interface ImageRequest {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageRequest
     */
    'added_at'?: string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildRequest>}
     * @memberof ImageRequest
     */
    'builds'?: Array<ImageBuildRequest>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageRequest
     */
    'id'?: string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageRequest
     */
    'source'?: string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageResponse
     */
    'added_at': string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildResponse>}
     * @memberof ImageResponse
     */
    'builds': Array<ImageBuildResponse>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageResponse
     */
    'id': string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageResponse
     */
    'source': string;
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsRequest
 */
export interface ImagesRegistryCredsRequest {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsRequest
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof ImagesRegistryCredsRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsResponse
 */
export interface ImagesRegistryCredsResponse {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsResponse
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof ImagesRegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
}
/**
 * 
 * @export
 * @interface InternalActiveResourceRequest
 */
export interface InternalActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'app_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'def_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'env_id'?: string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'env_type'?: string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'gu_res_id'?: string;
    /**
     * The ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'org_id'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'res_id'?: string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof InternalActiveResourceRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'status'?: string;
    /**
     * The Resource Type of the resource.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'type'?: string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface InternalActiveResourceResponse
 */
export interface InternalActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'def_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'env_type': string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'gu_res_id': string;
    /**
     * The ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'res_id': string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof InternalActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface InternalValueRequest
 */
export interface InternalValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_store_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_version'?: string | null;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InternalValueResponse
 */
export interface InternalValueResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_key': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_store_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_version': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface InternalValueSetVersionRequest
 */
export interface InternalValueSetVersionRequest {
    /**
     * 
     * @type {Array<JSONPatchRequest>}
     * @memberof InternalValueSetVersionRequest
     */
    'change'?: Array<JSONPatchRequest>;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'result_of'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'source_value_set_version_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {{ [key: string]: InternalValueRequest; }}
     * @memberof InternalValueSetVersionRequest
     */
    'values'?: { [key: string]: InternalValueRequest; };
}
/**
 * 
 * @export
 * @interface InternalValueSetVersionResponse
 */
export interface InternalValueSetVersionResponse {
    /**
     * 
     * @type {Array<JSONPatchResponse>}
     * @memberof InternalValueSetVersionResponse
     */
    'change': Array<JSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'result_of': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: InternalValueResponse; }}
     * @memberof InternalValueSetVersionResponse
     */
    'values': { [key: string]: InternalValueResponse; };
}
/**
 * 
 * @export
 * @interface InternalWorkloadProfileRequest
 */
export interface InternalWorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof InternalWorkloadProfileRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface InternalWorkloadProfileResponse
 */
export interface InternalWorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'id': string;
    /**
     * The latest version of the profile
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'latest': string;
    /**
     * The latest version of the profile schema
     * @type {any}
     * @memberof InternalWorkloadProfileResponse
     */
    'latest_schema': any;
    /**
     * Organization ID
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'org_id': string;
}
/**
 * 
 * @export
 * @interface JSONPatchRequest
 */
export interface JSONPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchRequest
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface JSONPatchResponse
 */
export interface JSONPatchResponse {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof JSONPatchResponse
     */
    'value'?: any;
}
/**
 * 
 * @export
 * @interface LegacyTokenRequestRequest
 */
export interface LegacyTokenRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'org_id'?: string;
}
/**
 * 
 * @export
 * @interface LegacyTokenRequestResponse
 */
export interface LegacyTokenRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'org_id': string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestRequest
 */
export interface ManifestRequest {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestRequest
     */
    'data'?: any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestRequest
     */
    'location'?: string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestResponse
     */
    'data': any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestResponse
     */
    'location': string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaRequest
 */
export interface MatchingCriteriaRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'id'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'res_id'?: string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaResponse
 */
export interface MatchingCriteriaResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'id': string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleRequest
 */
export interface MatchingCriteriaRuleRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleResponse
 */
export interface MatchingCriteriaRuleResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'res_id'?: string;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasRequest
 */
export interface ModuleDeltasRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof ModuleDeltasRequest
     */
    'add'?: { [key: string]: ModuleRequest; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasRequest
     */
    'remove'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionRequest>; }}
     * @memberof ModuleDeltasRequest
     */
    'update'?: { [key: string]: Array<UpdateActionRequest>; };
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasResponse
 */
export interface ModuleDeltasResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof ModuleDeltasResponse
     */
    'add': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasResponse
     */
    'remove': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionResponse>; }}
     * @memberof ModuleDeltasResponse
     */
    'update': { [key: string]: Array<UpdateActionResponse>; };
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleRequest
 */
export interface ModuleRequest {
    [key: string]: ControllerRequest | any;

    /**
     * 
     * @type {DeployConditionRequest}
     * @memberof ModuleRequest
     */
    'deploy'?: DeployConditionRequest;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'externals'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleRequest
     */
    'profile'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'spec'?: { [key: string]: any; };
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleResponse
 */
export interface ModuleResponse {
    [key: string]: ControllerResponse | any;

    /**
     * 
     * @type {DeployConditionResponse}
     * @memberof ModuleResponse
     */
    'deploy'?: DeployConditionResponse;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'externals': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleResponse
     */
    'profile': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'spec': { [key: string]: any; };
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserRequest
 */
export interface NewServiceUserRequest {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'name'?: string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'role'?: string;
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserResponse
 */
export interface NewServiceUserResponse {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'name': string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'role': string;
}
/**
 * Node Represents a node of a Resource Dependency Graph
 * @export
 * @interface NodeRequest
 */
export interface NodeRequest {
    /**
     * List of GuResIDs of dependent resources
     * @type {Array<string>}
     * @memberof NodeRequest
     */
    'depends_on'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'driver'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'guresid'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'id'?: string;
    /**
     * Parameters with which the resource should be provisioned
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'resource_schema'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'type'?: string;
}
/**
 * Node Represents a node of a Resource Dependency Graph
 * @export
 * @interface NodeResponse
 */
export interface NodeResponse {
    /**
     * List of GuResIDs of dependent resources
     * @type {Array<string>}
     * @memberof NodeResponse
     */
    'depends_on': Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'driver': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'guresid': string;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'id': string;
    /**
     * Parameters with which the resource should be provisioned
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'resource': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'resource_schema': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'type': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface ObjectRoleRequest
 */
export interface ObjectRoleRequest {
    /**
     * The ID of the object
     * @type {string}
     * @memberof ObjectRoleRequest
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectRoleRequest
     */
    'role'?: string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface ObjectRoleResponse
 */
export interface ObjectRoleResponse {
    /**
     * The ID of the object
     * @type {string}
     * @memberof ObjectRoleResponse
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectRoleResponse
     */
    'role': string;
}
/**
 * ObjectUserRole holds the mapping of a Role that a User holds for a particular Object.
 * @export
 * @interface ObjectUserRoleRequest
 */
export interface ObjectUserRoleRequest {
    /**
     * The Object the the User holds the Role on
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'role'?: string;
    /**
     * The User ID that hold the Role on the Object
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'user'?: string;
}
/**
 * ObjectUserRole holds the mapping of a Role that a User holds for a particular Object.
 * @export
 * @interface ObjectUserRoleResponse
 */
export interface ObjectUserRoleResponse {
    /**
     * The Object the the User holds the Role on
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'object': string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'role': string;
    /**
     * The User ID that hold the Role on the Object
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'user': string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'id'?: string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name'?: string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Timestamp when the Organization was created.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_at': string | null;
    /**
     * User ID that created the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_by': string;
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'name': string;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateRequest
 */
export interface PodStateRequest {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateRequest
     */
    'containerStatuses'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'phase'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'podName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PodStateRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'status'?: string;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateResponse
 */
export interface PodStateResponse {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateResponse
     */
    'containerStatuses': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'phase': string;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'podName': string;
    /**
     * 
     * @type {number}
     * @memberof PodStateResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'status': string;
}
/**
 * RegisterIdentityToken holds the Identity providers temporary token along with the provider it is associated to. It also has a required field of `privacy_policy_accepted`.
 * @export
 * @interface RegisterIdentityTokenRequest
 */
export interface RegisterIdentityTokenRequest {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterIdentityTokenRequest
     */
    'privacy_policy_accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'provider'?: string;
    /**
     * (optional) The reference to the source of the signup.
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'signup_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'token'?: string;
}
/**
 * RegisterIdentityToken holds the Identity providers temporary token along with the provider it is associated to. It also has a required field of `privacy_policy_accepted`.
 * @export
 * @interface RegisterIdentityTokenResponse
 */
export interface RegisterIdentityTokenResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterIdentityTokenResponse
     */
    'privacy_policy_accepted': boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'provider': string;
    /**
     * (optional) The reference to the source of the signup.
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'signup_ref': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'token': string;
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsRequest
 */
export interface RegistryCredsRequest {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof RegistryCredsRequest
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof RegistryCredsRequest
     */
    'password': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryCredsRequest
     */
    'secrets': { [key: string]: ClusterSecretRequest; };
    /**
     * Security account login or token.
     * @type {string}
     * @memberof RegistryCredsRequest
     */
    'username': string;
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsResponse
 */
export interface RegistryCredsResponse {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'password': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
    /**
     * Security account login or token.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'username': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryRequest
 */
export interface RegistryRequest {
    /**
     * 
     * @type {AccountCredsRequest}
     * @memberof RegistryRequest
     */
    'creds'?: AccountCredsRequest;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryRequest
     */
    'enable_ci'?: boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryRequest
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryRequest
     */
    'type': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryResponse
 */
export interface RegistryResponse {
    /**
     * The timestamp of when this record was created.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_at'?: string | null;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_by'?: string;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryResponse
     */
    'enable_ci': boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryResponse
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryResponse
     */
    'secrets'?: { [key: string]: ClusterSecretResponse; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryResponse
     */
    'type': string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountRequest
 */
export interface ResourceAccountRequest {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_at'?: string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_by'?: string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'id'?: string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountRequest
     */
    'is_used'?: boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'type'?: string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountResponse
 */
export interface ResourceAccountResponse {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_by': string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'id': string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountResponse
     */
    'is_used': boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'type': string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeRequest
 */
export interface ResourceDefinitionChangeRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'app_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'env_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'from_def'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'res_id'?: string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'to_def'?: string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeResponse
 */
export interface ResourceDefinitionChangeResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'app_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'env_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'from_def': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'res_id': string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'to_def': string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionRequest
 */
export interface ResourceDefinitionRequest {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof ResourceDefinitionRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof ResourceDefinitionRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'id'?: string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'name'?: string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'org_id'?: string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'type'?: string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionResponse
 */
export interface ResourceDefinitionResponse {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof ResourceDefinitionResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof ResourceDefinitionResponse
     */
    'driver_inputs'?: ValuesSecretsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'id': string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'name': string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'org_id': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'type': string;
}
/**
 * ResourceOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface ResourceOutputsRequest
 */
export interface ResourceOutputsRequest {
    /**
     * The Resource Definitions ID that was used to provision the resource.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'def_id'?: string;
    /**
     * The resource ID.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'id'?: string;
    /**
     * The resource definition manifests (if any). Only available when status is \'active\'.
     * @type {Array<ManifestRequest>}
     * @memberof ResourceOutputsRequest
     */
    'manifests'?: Array<ManifestRequest>;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof ResourceOutputsRequest
     */
    'resource'?: ValuesSecretsRequest;
    /**
     * The resource availability status: pending, active, or deleting.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'status'?: string;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'type'?: string;
}
/**
 * ResourceOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface ResourceOutputsResponse
 */
export interface ResourceOutputsResponse {
    /**
     * The Resource Definitions ID that was used to provision the resource.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'def_id': string;
    /**
     * The resource ID.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'id': string;
    /**
     * The resource definition manifests (if any). Only available when status is \'active\'.
     * @type {Array<ManifestResponse>}
     * @memberof ResourceOutputsResponse
     */
    'manifests': Array<ManifestResponse>;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof ResourceOutputsResponse
     */
    'resource': ValuesSecretsResponse;
    /**
     * The resource availability status: pending, active, or deleting.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'status': string;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequestLegacy is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestLegacyRequest
 */
export interface ResourceProvisionRequestLegacyRequest {
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestLegacyRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * The resource type
     * @type {string}
     * @memberof ResourceProvisionRequestLegacyRequest
     */
    'type': string;
}
/**
 * ResourceProvisionRequestLegacy is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestLegacyResponse
 */
export interface ResourceProvisionRequestLegacyResponse {
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestLegacyResponse
     */
    'resource'?: { [key: string]: any; };
    /**
     * The resource type
     * @type {string}
     * @memberof ResourceProvisionRequestLegacyResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestRequest
 */
export interface ResourceProvisionRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestResponse
 */
export interface ResourceProvisionRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestResponse
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestResponse
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestResponse
     */
    'type': string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeRequest
 */
export interface ResourceTypeRequest {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'category'?: string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'name'?: string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'outputs_schema'?: { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'type'?: string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeResponse
 */
export interface ResourceTypeResponse {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'category': string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'name': string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'outputs_schema': { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'type': string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoRequest
 */
export interface RuntimeInfoRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof RuntimeInfoRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoRequest
     */
    'namespace'?: string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoResponse
 */
export interface RuntimeInfoResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof RuntimeInfoResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoResponse
     */
    'namespace': string;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetRequest
 */
export interface SetRequest {
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof SetRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetRequest
     */
    'shared'?: { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetRequest
     */
    'version'?: number;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetResponse
 */
export interface SetResponse {
    /**
     * The ID which is a hash of the content of the Deployment Set.
     * @type {string}
     * @memberof SetResponse
     */
    'id': string;
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof SetResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetResponse
     */
    'shared': { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetResponse
     */
    'version': number;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionRequest
 */
export interface TokenDefinitionRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'type'?: string;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionResponse
 */
export interface TokenDefinitionResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'type': string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoRequest
 */
export interface TokenInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'type'?: string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoResponse
 */
export interface TokenInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'type': string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'type'?: string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'type'?: string;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionRequest
 */
export interface UpdateActionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionRequest
     */
    'value'?: any;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionResponse
 */
export interface UpdateActionResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionResponse
     */
    'value'?: any;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadRequest
 */
export interface UpdateArtefactVersionPayloadRequest {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadRequest
     */
    'archived': boolean | null;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadResponse
 */
export interface UpdateArtefactVersionPayloadResponse {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadResponse
     */
    'archived': boolean | null;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestRequest
 */
export interface UpdateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof UpdateDriverRequestRequest
     */
    'is_public'?: boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'url_prefix'?: string;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestResponse
 */
export interface UpdateDriverRequestResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestResponse
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof UpdateDriverRequestResponse
     */
    'is_public': boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestResponse
     */
    'template': any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'url_prefix': string;
}
/**
 * UpdateEnvironmentPayload contains the `DeploymentsLocked` field that should be set in the Environment to update.
 * @export
 * @interface UpdateEnvironmentPayloadRequest
 */
export interface UpdateEnvironmentPayloadRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEnvironmentPayloadRequest
     */
    'deployments_locked'?: boolean | null;
}
/**
 * UpdateEnvironmentPayload contains the `DeploymentsLocked` field that should be set in the Environment to update.
 * @export
 * @interface UpdateEnvironmentPayloadResponse
 */
export interface UpdateEnvironmentPayloadResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEnvironmentPayloadResponse
     */
    'deployments_locked': boolean | null;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestRequest
 */
export interface UpdateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'name'?: string;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestResponse
 */
export interface UpdateResourceAccountRequestResponse {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestResponse
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestResponse
     */
    'name': string;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestRequest
 */
export interface UpdateResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'name'?: string | null;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestResponse
 */
export interface UpdateResourceDefinitionRequestResponse {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'driver_account': string | null;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'driver_inputs': ValuesSecretsResponse;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface UpdateResourceTypeRequestRequest
 */
export interface UpdateResourceTypeRequestRequest {
    /**
     * (Optional) Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'category'?: string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'name'?: string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'outputs_schema'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateResourceTypeRequestResponse
 */
export interface UpdateResourceTypeRequestResponse {
    /**
     * (Optional) Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'category': string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'name': string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'outputs_schema': { [key: string]: any; };
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteRequest
 */
export interface UserInviteRequest {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'created_at'?: string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'created_by'?: string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'expires_at'?: string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'user_id'?: string;
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestRequest
 */
export interface UserInviteRequestRequest {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'role': string;
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestResponse
 */
export interface UserInviteRequestResponse {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestResponse
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestResponse
     */
    'role': string;
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteResponse
 */
export interface UserInviteResponse {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_by': string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'expires_at': string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'user_id': string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedRequest
 */
export interface UserProfileExtendedRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedRequest
     */
    'properties'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedRequest
     */
    'roles'?: { [key: string]: string; };
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedResponse
 */
export interface UserProfileExtendedResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedResponse
     */
    'properties': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedResponse
     */
    'roles': { [key: string]: string; };
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileRequest
 */
export interface UserProfileRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileRequest
     */
    'name'?: string;
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleRequest
 */
export interface UserRoleRequest {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleRequest
     */
    'role'?: string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleRequest
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleRequest
     */
    'id'?: string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleRequest
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleRequest
     */
    'name'?: string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleResponse
 */
export interface UserRoleResponse {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleResponse
     */
    'role': string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleResponse
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleResponse
     */
    'id': string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleResponse
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadRequest
 */
export interface ValueCreatePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadResponse
 */
export interface ValueCreatePayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadResponse
     */
    'is_secret': boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadRequest
 */
export interface ValueEditPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadResponse
 */
export interface ValueEditPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadResponse
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadRequest
 */
export interface ValuePatchPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadResponse
 */
export interface ValuePatchPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadResponse
     */
    'value': string | null;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueRequest
 */
export interface ValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueRequest
     */
    'key'?: string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueRequest
     */
    'value'?: string;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueResponse
 */
export interface ValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueResponse
     */
    'key': string;
    /**
     * Version of the current secret value as returned by the secret store.
     * @type {string}
     * @memberof ValueResponse
     */
    'secret_version': string | null;
    /**
     * Source of the value, \"app\" for app level, \"env\" for app env level.
     * @type {string}
     * @memberof ValueResponse
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ValueSetActionPayloadRequest
 */
export interface ValueSetActionPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ValueSetActionPayloadResponse
 */
export interface ValueSetActionPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadResponse
     */
    'comment': string;
}
/**
 * Value Set Version can be used as a track record of Shared Value changes, restore to a previous Shared Value or purge an accidentally added Shared Value.
 * @export
 * @interface ValueSetVersionRequest
 */
export interface ValueSetVersionRequest {
    /**
     * 
     * @type {Array<JSONPatchRequest>}
     * @memberof ValueSetVersionRequest
     */
    'change'?: Array<JSONPatchRequest>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'result_of'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'source_value_set_version_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {{ [key: string]: ValueRequest; }}
     * @memberof ValueSetVersionRequest
     */
    'values'?: { [key: string]: ValueRequest; };
}
/**
 * Value Set Version can be used as a track record of Shared Value changes, restore to a previous Shared Value or purge an accidentally added Shared Value.
 * @export
 * @interface ValueSetVersionResponse
 */
export interface ValueSetVersionResponse {
    /**
     * 
     * @type {Array<JSONPatchResponse>}
     * @memberof ValueSetVersionResponse
     */
    'change': Array<JSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'result_of': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: ValueResponse; }}
     * @memberof ValueSetVersionResponse
     */
    'values': { [key: string]: ValueResponse; };
}
/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsRequest
 */
export interface ValuesSecretsRequest {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'values'?: { [key: string]: any; };
}
/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsResponse
 */
export interface ValuesSecretsResponse {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'values'?: { [key: string]: any; };
}
/**
 * Webhook is a special type of a Job, it performs a HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookRequest
 */
export interface WebhookRequest {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'headers'?: { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookRequest
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'payload'?: { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseRequest>}
     * @memberof WebhookRequest
     */
    'triggers'?: Array<EventBaseRequest>;
    /**
     * Thw webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookRequest
     */
    'url'?: string | null;
}
/**
 * Webhook is a special type of a Job, it performs a HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The timestamp of when this Job was created.
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_at'?: string;
    /**
     * The user who created this Job
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_by'?: string;
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'headers': { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookResponse
     */
    'triggers': Array<EventBaseResponse>;
    /**
     * Thw webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookResponse
     */
    'url': string | null;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileRequest
 */
export interface WorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'id': string;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileResponse
 */
export interface WorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'id': string;
    /**
     * The latest version of the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'latest': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'org_id': string;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionRequest
 */
export interface WorkloadProfileVersionRequest {
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionRequest
     */
    'features'?: { [key: string]: any; };
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionRequest
     */
    'notes'?: string;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionResponse
 */
export interface WorkloadProfileVersionResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_by': string;
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionResponse
     */
    'features': { [key: string]: any; };
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'notes': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'org_id': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'profile_id': string;
    /**
     * Version
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'version': string;
}

/**
 * AccountTypeApi - axios parameter creator
 * @export
 */
export const AccountTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTypeApi - functional programming interface
 * @export
 */
export const AccountTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountTypeApi - factory interface
 * @export
 */
export const AccountTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: any): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountTypeApi - object-oriented interface
 * @export
 * @class AccountTypeApi
 * @extends {BaseAPI}
 */
export class AccountTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTypeApi
     */
    public orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return AccountTypeApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActiveResourceApi - axios parameter creator
 * @export
 */
export const ActiveResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveResourceApi - functional programming interface
 * @export
 */
export const ActiveResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActiveResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActiveResourceApi - factory interface
 * @export
 */
export const ActiveResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActiveResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActiveResourceApi - object-oriented interface
 * @export
 * @class ActiveResourceApi
 * @extends {BaseAPI}
 */
export class ActiveResourceApi extends BaseAPI {
    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} type The Resource Type.  
     * @param {string} resId The Resource ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationRequest: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationRequest', applicationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(orgId: string, options?: any): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {string} orgId The Organization ID.  
     * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactApi - axios parameter creator
 * @export
 */
export const ArtefactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactApi - functional programming interface
 * @export
 */
export const ArtefactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactApi - factory interface
 * @export
 */
export const ArtefactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactApiFp(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: any): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtefactApi - object-oriented interface
 * @export
 * @class ArtefactApi
 * @extends {BaseAPI}
 */
export class ArtefactApi extends BaseAPI {
    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {string} orgId The organization ID.  
     * @param {string} [type] (Optional) Filter Artefacts by type.  
     * @param {string} [name] (Optional) Filter Artefacts by name.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactVersionApi - axios parameter creator
 * @export
 */
export const ArtefactVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactVersionApi - functional programming interface
 * @export
 */
export const ArtefactVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactVersionApi - factory interface
 * @export
 */
export const ArtefactVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactVersionApiFp(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: any): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtefactVersionApi - object-oriented interface
 * @export
 * @class ArtefactVersionApi
 * @extends {BaseAPI}
 */
export class ArtefactVersionApi extends BaseAPI {
    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {string} orgId The organization ID.  
     * @param {string} [name] (Optional) Filter Artefact Versions by name.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {string} orgId The organization ID.  
     * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
     * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} versionId The Version ID.  
     * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutomationRuleApi - axios parameter creator
 * @export
 */
export const AutomationRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationRuleApi - functional programming interface
 * @export
 */
export const AutomationRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomationRuleApi - factory interface
 * @export
 */
export const AutomationRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomationRuleApi - object-oriented interface
 * @export
 * @class AutomationRuleApi
 * @extends {BaseAPI}
 */
export class AutomationRuleApi extends BaseAPI {
    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeltaApi - axios parameter creator
 * @export
 */
export const DeltaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeltaApi - functional programming interface
 * @export
 */
export const DeltaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeltaApiAxiosParamCreator(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeltaApi - factory interface
 * @export
 */
export const DeltaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeltaApiFp(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: any): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeltaApi - object-oriented interface
 * @export
 * @class DeltaApi
 * @extends {BaseAPI}
 */
export class DeltaApi extends BaseAPI {
    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Delta to update.  
     * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {boolean} [archived] If true, return archived Deltas.  
     * @param {string} [env] Only return Deltas associated with the specified Environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverDefinitionApi - axios parameter creator
 * @export
 */
export const DriverDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverDefinitionApi - functional programming interface
 * @export
 */
export const DriverDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverDefinitionApi - factory interface
 * @export
 */
export const DriverDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(orgId: string, options?: any): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverDefinitionApi - object-oriented interface
 * @export
 * @class DriverDefinitionApi
 * @extends {BaseAPI}
 */
export class DriverDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resources Driver ID to delete.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} body The Deployment ID to rebase to.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentTypeApi - axios parameter creator
 * @export
 */
export const EnvironmentTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentTypeApi - functional programming interface
 * @export
 */
export const EnvironmentTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentTypeApi - factory interface
 * @export
 */
export const EnvironmentTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentTypeApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(orgId: string, options?: any): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentTypeApi - object-oriented interface
 * @export
 * @class EnvironmentTypeApi
 * @extends {BaseAPI}
 */
export class EnvironmentTypeApi extends BaseAPI {
    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(orgId: string, options?: any): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdEventsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(orgId: string, options?: any): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: any): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {string} orgId The organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchingCriteriaApi - axios parameter creator
 * @export
 */
export const MatchingCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingCriteriaApi - functional programming interface
 * @export
 */
export const MatchingCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingCriteriaApi - factory interface
 * @export
 */
export const MatchingCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingCriteriaApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchingCriteriaApi - object-oriented interface
 * @export
 * @class MatchingCriteriaApi
 * @extends {BaseAPI}
 */
export class MatchingCriteriaApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(orgId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsOrgIdGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationRequest: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationRequest', applicationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-type/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete: async (orgId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost: async (orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'profileId', profileId)
            // verify required parameter 'workloadProfileVersionRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'workloadProfileVersionRequest', workloadProfileVersionRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: any): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: any): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: any): AxiosPromise<SetResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(orgId: string, options?: any): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: any): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: any): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(orgId: string, options?: any): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(orgId: string, options?: any): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(orgId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(orgId: string, options?: any): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: any): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(orgId: string, options?: any): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(orgId: string, options?: any): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: any): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(orgId: string, options?: any): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: any): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(orgId: string, options?: any): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(orgId: string, options?: any): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(orgId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(orgId: string, options?: any): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: any): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: any): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserPatch(userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Delta to update.  
     * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {boolean} [archived] If true, return archived Deltas.  
     * @param {string} [env] Only return Deltas associated with the specified Environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} body The Deployment ID to rebase to.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} type The Resource Type.  
     * @param {string} resId The Resource ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {string} sourceSetId ID of the Deployment Set to diff against.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {UserRoleRequest} userRoleRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {string} orgId The Organization ID.  
     * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {string} orgId The organization ID.  
     * @param {string} [name] (Optional) Filter Artefact Versions by name.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {string} orgId The organization ID.  
     * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
     * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has the prefix \&quot;refs/\&quot;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined only non-archived Artefact Versions are returned, if the filter is true both archived and non-archived Versions are returned.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} versionId The Version ID.  
     * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {string} orgId The organization ID.  
     * @param {string} [type] (Optional) Filter Artefacts by type.  
     * @param {string} [name] (Optional) Filter Artefacts by name.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envType The Environment Type.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEventsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {string} orgId The organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {string} orgId The Organization ID.  
     * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {RegistryRequest} registryRequest A new record details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {RegistryRequest} registryRequest Record details to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {string} orgId The Organization ID.  
     * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
     * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resources Driver ID to delete.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Types.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {string} orgId The Organization ID.  
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload Profile ID.  
     * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {string} version The Version.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The Workload profile qualified ID.  
     * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {string} tokenId The token ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(orgId: string, options?: any): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {RegistryRequest} registryRequest A new record details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {RegistryRequest} registryRequest Record details to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceAccountApi - axios parameter creator
 * @export
 */
export const ResourceAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceAccountApi - functional programming interface
 * @export
 */
export const ResourceAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceAccountApi - factory interface
 * @export
 */
export const ResourceAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(orgId: string, options?: any): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceAccountApi - object-oriented interface
 * @export
 * @class ResourceAccountApi
 * @extends {BaseAPI}
 */
export class ResourceAccountApi extends BaseAPI {
    /**
     * 
     * @summary Get a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceDefinitionApi - axios parameter creator
 * @export
 */
export const ResourceDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceDefinitionApi - functional programming interface
 * @export
 */
export const ResourceDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceDefinitionApi - factory interface
 * @export
 */
export const ResourceDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceDefinitionApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: any): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceDefinitionApi - object-oriented interface
 * @export
 * @class ResourceDefinitionApi
 * @extends {BaseAPI}
 */
export class ResourceDefinitionApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {string} orgId The Organization ID.  
     * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
     * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceTypeApi - axios parameter creator
 * @export
 */
export const ResourceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceTypeApi - functional programming interface
 * @export
 */
export const ResourceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceTypeApi - factory interface
 * @export
 */
export const ResourceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(orgId: string, options?: any): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceTypeApi - object-oriented interface
 * @export
 * @class ResourceTypeApi
 * @extends {BaseAPI}
 */
export class ResourceTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Types.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypeApi
     */
    public orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return ResourceTypeApiFp(this.configuration).orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuntimeInfoApi - axios parameter creator
 * @export
 */
export const RuntimeInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuntimeInfoApi - functional programming interface
 * @export
 */
export const RuntimeInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuntimeInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuntimeInfoApi - factory interface
 * @export
 */
export const RuntimeInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuntimeInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: any): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RuntimeInfoApi - object-oriented interface
 * @export
 * @class RuntimeInfoApi
 * @extends {BaseAPI}
 */
export class RuntimeInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetApi - axios parameter creator
 * @export
 */
export const SetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetApi - functional programming interface
 * @export
 */
export const SetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetApi - factory interface
 * @export
 */
export const SetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: any): AxiosPromise<SetResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetApi - object-oriented interface
 * @export
 * @class SetApi
 * @extends {BaseAPI}
 */
export class SetApi extends BaseAPI {
    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {string} sourceSetId ID of the Deployment Set to diff against.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserInviteApi - axios parameter creator
 * @export
 */
export const UserInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInviteApi - functional programming interface
 * @export
 */
export const UserInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserInviteApi - factory interface
 * @export
 */
export const UserInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInviteApiFp(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(orgId: string, options?: any): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserInviteApi - object-oriented interface
 * @export
 * @class UserInviteApi
 * @extends {BaseAPI}
 */
export class UserInviteApi extends BaseAPI {
    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInviteApi
     */
    public orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig) {
        return UserInviteApiFp(this.configuration).orgsOrgIdInvitationsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserPatch(userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {string} orgId The Organization ID.  
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {string} tokenId The token ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRoleApi - axios parameter creator
 * @export
 */
export const UserRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-type/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRoleApi - functional programming interface
 * @export
 */
export const UserRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRoleApi - factory interface
 * @export
 */
export const UserRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRoleApiFp(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(orgId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserRoleApi - object-oriented interface
 * @export
 * @class UserRoleApi
 * @extends {BaseAPI}
 */
export class UserRoleApi extends BaseAPI {
    /**
     * 
     * @summary List Users with roles in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {UserRoleRequest} userRoleRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envType The Environment Type.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {string} orgId The Organization ID.  
     * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueApi - axios parameter creator
 * @export
 */
export const ValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueApi - functional programming interface
 * @export
 */
export const ValueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueApi - factory interface
 * @export
 */
export const ValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValueApi - object-oriented interface
 * @export
 * @class ValueApi
 * @extends {BaseAPI}
 */
export class ValueApi extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueSetVersionApi - axios parameter creator
 * @export
 */
export const ValueSetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueSetVersionApi - functional programming interface
 * @export
 */
export const ValueSetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueSetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueSetVersionApi - factory interface
 * @export
 */
export const ValueSetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueSetVersionApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValueSetVersionApi - object-oriented interface
 * @export
 * @class ValueSetVersionApi
 * @extends {BaseAPI}
 */
export class ValueSetVersionApi extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkloadProfileApi - axios parameter creator
 * @export
 */
export const WorkloadProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete: async (orgId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost: async (orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'profileId', profileId)
            // verify required parameter 'workloadProfileVersionRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'workloadProfileVersionRequest', workloadProfileVersionRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkloadProfileApi - functional programming interface
 * @export
 */
export const WorkloadProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkloadProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkloadProfileApi - factory interface
 * @export
 */
export const WorkloadProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkloadProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(orgId: string, options?: any): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: any): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: any): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkloadProfileApi - object-oriented interface
 * @export
 * @class WorkloadProfileApi
 * @extends {BaseAPI}
 */
export class WorkloadProfileApi extends BaseAPI {
    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload Profile ID.  
     * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {string} version The Version.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The Workload profile qualified ID.  
     * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(this.axios, this.basePath));
    }
}


