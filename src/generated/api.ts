/* tslint:disable */
/* eslint-disable */
/**
 * Humanitec API
 * # Introduction The *Humanitec API* allows you to automate and integrate Humanitec into your developer and operational workflows. The API is a REST based API. It is based around a set of concepts:  * Core * External Resources * Sets and Deltas  ## Authentication Almost all requests made to the Humanitec API require Authentication. Humanitec provides 2 ways of authenticating with the API: `Bearer` and `JWT`.  ### Bearer Authentication This form of authentication makes use of a **static token**. It is intended to be used when machines interact with the Humanitec API. Bearer tokens should be used for very narrow purposes. This allows for the token to be revoked if it is compromised and so limit the scope of exposure. New Bearer tokens can be obtained via the UI:  1. Log into Humanitec at https://app.humanitec.io 1. Go to **Organization Settings** 1. Select **API tokens** 1. Enter a *name* for the new token and click on **Generate new token**  The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_TOKEN`, the request could be made as follows:  ```     curl -H \'Authorization: Bearer HUMANITEC_TOKEN\' https://api.humanitec.io/orgs/my-org/apps ```  ### JWT Authentication This form of authentication makes use of a **JSON Web Token (JWT)**. It is intended to be used when humans interact with the Humanitec API. JWTs expire after a period of time. This means that a new JWT will need to be generated regularly. This makes them well suited to working in short sessions, but not for automation. (See Bearer Authentication.) The token is passed to the API via the `Authorization` header. Assuming the issued token is `HUMANITEC_JWT`, the request could be made as follows:  ```     curl -H \'Authorization: JWT HUMANITEC_JWT\' https://api.humanitec.io/orgs/my-org/apps ```  ## Content Types All of the Humanitec API unless explicitly only accepts content types of `application/json` and will always return valid `application/json` or an empty response.  ## Response Codes ### Success Any response code in the `2xx` range should be regarded as success.  | **Code** | **Meaning** | | --- | --- | | `200` | Success | | `201` | Success (In future, `201` will be replaced by `200`) | | `204` | Success, but no content in response |  _Note: We plan to simplify the interface by replacing 201 with 200 status codes._  ### Failure Any response code in the `4xx` should be regarded as an error which can be rectified by the client. `5xx` error codes indicate errors that cannot be corrected by the client.  | **Code** | **Meaning** | | --- | --- | | `400` | General error. (Body will contain details) | | `401` | Attempt to access protected resource without `Authorization` Header. | | `403` | The `Bearer` or `JWT` does not grant access to the requested resource. | | `404` | Resource not found. | | `405` | Method not allowed | | `409` | Conflict. Usually indicated a resource with that ID already exists. | | `422` | Unprocessable Entity. The body was not valid JSON, was empty or contained an object different from what was expected. | | `429` | Too many requests - request rate limit has been reached. | | `500` | Internal Error. If it occurs repeatedly, contact support. | 
 *
 * The version of the OpenAPI document: 0.19.0
 * Contact: apiteam@humanitec.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsRequest
 */
export interface AccountCredsRequest {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsRequest
     */
    'username': string;
}
/**
 * AccountCreds represents an account credentials (either, username- or token-based).
 * @export
 * @interface AccountCredsResponse
 */
export interface AccountCredsResponse {
    /**
     * Account credentials expiration timestamp.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'expires'?: string | null;
    /**
     * Account password or token secret.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'password': string;
    /**
     * Security account login or token.
     * @type {string}
     * @memberof AccountCredsResponse
     */
    'username': string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeRequest
 */
export interface AccountTypeRequest {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'name'?: string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeRequest
     */
    'type'?: string;
}
/**
 * Resource Account Types define cloud providers or protocols to which a resource account can belong.
 * @export
 * @interface AccountTypeResponse
 */
export interface AccountTypeResponse {
    /**
     * Display Name.
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'name': string;
    /**
     * Unique account type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof AccountTypeResponse
     */
    'type': string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceRequest
 */
export interface ActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'app_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'def_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_id'?: string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'env_type'?: string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'org_id'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'res_id'?: string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'status'?: string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'type'?: string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceRequest
     */
    'updated_at'?: string;
}
/**
 * Active Resources represent the concrete resources provisioned for an Environment. They are provisioned on the first deployment after a dependency on a particular resource type is introduced into an Environment. In general, Active Resources are only deleted when their introductory Environment is deleted.  Active Resources are provisioned based on a Resource Definition. The Resource Definition describes how to provision a concrete resource based on a Resource Type and metadata about the Environment (for example the Environment Type or the Application ID). The criteria for how to choose a Resource Definition is known as a Matching Criteria. If the Matching Criteria changes or the Resource Definition is deleted, the concrete resource represented by an Active Resource might be deleted and reprovisioned when a deployment occurs in the Environment.
 * @export
 * @interface ActiveResourceResponse
 */
export interface ActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'def_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'env_type': string;
    /**
     * the ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'res_id': string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof ActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof ActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * AddArtefactVersionPayload describes the payload for a new ArtefactVersion request.
 * @export
 * @interface AddArtefactVersionPayloadRequest
 */
export interface AddArtefactVersionPayloadRequest {
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'digest'?: string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'ref'?: string;
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'type': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof AddArtefactVersionPayloadRequest
     */
    'version'?: string;
}
/**
 * AddArtefactVersionPayload describes the payload for a new ArtefactVersion request.
 * @export
 * @interface AddArtefactVersionPayloadResponse
 */
export interface AddArtefactVersionPayloadResponse {
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'commit': string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'digest': string;
    /**
     * The Artefact name.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'ref': string;
    /**
     * The Artefact Version type.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'type': string;
    /**
     * (Optional) The Artefact Version.
     * @type {string}
     * @memberof AddArtefactVersionPayloadResponse
     */
    'version': string;
}
/**
 * An Application is a collection of Modules that work together. When deployed, all Modules in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationRequest
 */
export interface ApplicationRequest {
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationRequest
     */
    'name': string;
}
/**
 * An Application is a collection of Modules that work together. When deployed, all Modules in an Application are deployed to the same namespace.  Apps are the root of the configuration tree holding Environments, Deployments, Shared Values, and Secrets.
 * @export
 * @interface ApplicationResponse
 */
export interface ApplicationResponse {
    /**
     * The timestamp in UTC indicates when the Application was created.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_at': string;
    /**
     * The user who created the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'created_by': string;
    /**
     * The Environments associated with the Application.
     * @type {Array<EnvironmentBaseResponse>}
     * @memberof ApplicationResponse
     */
    'envs': Array<EnvironmentBaseResponse>;
    /**
     * The ID which refers to a specific application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Application.
     * @type {string}
     * @memberof ApplicationResponse
     */
    'name': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactRequest
 */
export interface ArtefactRequest {
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactRequest
     */
    'type': string;
}
/**
 * Artefacts can be registered with Humanitec. Continuous Integration (CI) pipelines notify Humanitec when a new version of an Artefact becomes available. Humanitec tracks the Artefact along with metadata about how it was built.
 * @export
 * @interface ArtefactResponse
 */
export interface ArtefactResponse {
    /**
     * The time when the Artefact was added to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact to Humanitec.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'created_by'?: string;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'name': string;
    /**
     * The type of the Artefact.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'type': string;
    /**
     * The time when the Artefact was updated for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who updated the Artefact for the last time.
     * @type {string}
     * @memberof ArtefactResponse
     */
    'updated_by'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionRequest
 */
export interface ArtefactVersionRequest {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionRequest
     */
    'archived'?: boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'commit'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'digest'?: string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'ref'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionRequest
     */
    'version'?: string;
}
/**
 * An Artefact Version represents a particular version of an Artefact that can be added to an Application.
 * @export
 * @interface ArtefactVersionResponse
 */
export interface ArtefactVersionResponse {
    /**
     * If the Artefact Version is archived.
     * @type {boolean}
     * @memberof ArtefactVersionResponse
     */
    'archived': boolean;
    /**
     * The UUID of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'artefact_id': string;
    /**
     * (Optional) The commit ID the Artefact Version was built on.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'commit': string;
    /**
     * The time when the Artefact Version was added to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_at'?: string;
    /**
     * The user ID of the user who added the Artefact Version to Humanitec.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The Artefact Version digest.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'digest': string;
    /**
     * The UUID of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'id': string;
    /**
     * The name of the Artefact.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'name': string;
    /**
     * (Optional) The ref the Artefact Version was built from.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'ref': string;
    /**
     * The time when the Artefact Version was updated for the last time.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_at'?: string;
    /**
     * The user ID of the user who performed the last updated on the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'updated_by'?: string;
    /**
     * (Optional) The version of the Artefact Version.
     * @type {string}
     * @memberof ArtefactVersionResponse
     */
    'version': string;
}
/**
 * AsyncProgressHint describes ongoing asynchronous operation.
 * @export
 * @interface AsyncProgressHintRequest
 */
export interface AsyncProgressHintRequest {
    /**
     * The date and time of when the operation will be aborted if not yet finished.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'deadline'?: string;
    /**
     * Estimated date and time of when the operation is expected to be completed.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'estimate'?: string;
    /**
     * Current status.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'status'?: string;
    /**
     * Current (reference) date and time.
     * @type {string}
     * @memberof AsyncProgressHintRequest
     */
    'timestamp'?: string;
}
/**
 * AsyncProgressHint describes ongoing asynchronous operation.
 * @export
 * @interface AsyncProgressHintResponse
 */
export interface AsyncProgressHintResponse {
    /**
     * The date and time of when the operation will be aborted if not yet finished.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'deadline'?: string;
    /**
     * Estimated date and time of when the operation is expected to be completed.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'estimate'?: string;
    /**
     * Current status.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'status': string;
    /**
     * Current (reference) date and time.
     * @type {string}
     * @memberof AsyncProgressHintResponse
     */
    'timestamp'?: string;
}
/**
 * An Automation Rule defining how and when images in an environment should be updated.
 * @export
 * @interface AutomationRuleRequest
 */
export interface AutomationRuleRequest {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'active'?: boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'artefacts_filter'?: Array<string>;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_artefacts_filter'?: boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleRequest
     */
    'exclude_images_filter'?: boolean;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleRequest
     */
    'images_filter'?: Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match'?: string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'match_ref'?: string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleRequest
     */
    'update_to'?: string;
}
/**
 * An Automation Rule defining how and when images in an environment should be updated.
 * @export
 * @interface AutomationRuleResponse
 */
export interface AutomationRuleResponse {
    /**
     * Whether the rule will be processed or not.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'active': boolean;
    /**
     * A list of artefact names to be processed by the rule. If the array is empty, it implies include all. If `exclude_artefacts_filter` is true, this list describes the artefacts to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'artefacts_filter': Array<string>;
    /**
     * The timestamp in UTC of when the Automation Rule was created.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'created_at': string;
    /**
     * Whether the artefacts specified in `artefacts_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_artefacts_filter': boolean;
    /**
     * DEPRECATED: Whether the images specified in `images_filter` should be excluded (true) or included (false) in the automation rule.
     * @type {boolean}
     * @memberof AutomationRuleResponse
     */
    'exclude_images_filter': boolean;
    /**
     * The unique ID for this rule.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'id': string;
    /**
     * DEPRECATED: A list of image IDs to be processed by the rule. If the array is empty, it implies include all. If `exclude_images_filter` is true, this list describes images to exclude.
     * @type {Array<string>}
     * @memberof AutomationRuleResponse
     */
    'images_filter': Array<string>;
    /**
     * DEPRECATED: A regular expression applied to the branch or tag name depending on the value of `update_to`. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match': string;
    /**
     * A regular expression applied to the ref of a new artefact version. Defaults to match all if omitted or empty.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'match_ref': string;
    /**
     * Specifies the type of event. Currently, only updates to either branches or tags are supported. Must be `\"update\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'type': string;
    /**
     * DEPRECATED: Specifies whether the update occurs on commit to branch or creation of tag. Must be one of `\"branch\"` or `\"tag\"`.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'update_to': string;
    /**
     * The timestamp in UTC of when the Automation Rule was updated.
     * @type {string}
     * @memberof AutomationRuleResponse
     */
    'updated_at': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretRequest
 */
export interface ClusterSecretRequest {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretRequest
     */
    'secret': string;
}
/**
 * ClusterSecret represents Kubernetes secret reference.
 * @export
 * @interface ClusterSecretResponse
 */
export interface ClusterSecretResponse {
    /**
     * Namespace to look for the Kubernetes secret definition in.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'namespace': string;
    /**
     * Name that identifies the Kubernetes secret.
     * @type {string}
     * @memberof ClusterSecretResponse
     */
    'secret': string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerRequest
 */
export interface ControllerRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'message'?: string;
    /**
     * 
     * @type {Array<PodStateRequest>}
     * @memberof ControllerRequest
     */
    'pods'?: Array<PodStateRequest>;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'replicas'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllerRequest
     */
    'status'?: string;
}
/**
 * Controller represents deployment, stateful set etc
 * @export
 * @interface ControllerResponse
 */
export interface ControllerResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'message': string;
    /**
     * 
     * @type {Array<PodStateResponse>}
     * @memberof ControllerResponse
     */
    'pods': Array<PodStateResponse>;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'replicas': number;
    /**
     * 
     * @type {number}
     * @memberof ControllerResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof ControllerResponse
     */
    'status': string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestRequest
 */
export interface CreateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof CreateDriverRequestRequest
     */
    'is_public'?: boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof CreateDriverRequestRequest
     */
    'url_prefix'?: string;
}
/**
 * CreateDriverRequest describes the new resource driver registration request.
 * @export
 * @interface CreateDriverRequestResponse
 */
export interface CreateDriverRequestResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof CreateDriverRequestResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof CreateDriverRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof CreateDriverRequestResponse
     */
    'is_public': boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof CreateDriverRequestResponse
     */
    'template': any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof CreateDriverRequestResponse
     */
    'url_prefix': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequestRequest
 */
export interface CreateOrganizationRequestRequest {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestRequest
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequestResponse
 */
export interface CreateOrganizationRequestResponse {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestResponse
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof CreateOrganizationRequestResponse
     */
    'name': string;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestRequest
 */
export interface CreateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'id'?: string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestRequest
     */
    'type'?: string;
}
/**
 * CreateResourceAccountRequest describes the request to create a new security account.
 * @export
 * @interface CreateResourceAccountRequestResponse
 */
export interface CreateResourceAccountRequestResponse {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof CreateResourceAccountRequestResponse
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'id': string;
    /**
     * Display name.
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof CreateResourceAccountRequestResponse
     */
    'type': string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestRequest
 */
export interface CreateResourceDefinitionRequestRequest {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'name': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestRequest
     */
    'type': string;
}
/**
 * CreateResourceDefinitionRequest describes a new ResourceDefinition request.
 * @export
 * @interface CreateResourceDefinitionRequestResponse
 */
export interface CreateResourceDefinitionRequestResponse {
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_account': string;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_inputs': ValuesSecretsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'driver_type': string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'id': string;
    /**
     * The display name.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'name': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof CreateResourceDefinitionRequestResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeltaMetadataRequest
 */
export interface DeltaMetadataRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'archived'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataRequest
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'last_modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataRequest
     */
    'shared'?: boolean;
}
/**
 * 
 * @export
 * @interface DeltaMetadataResponse
 */
export interface DeltaMetadataResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'archived': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeltaMetadataResponse
     */
    'contributers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'env_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'last_modified_at': string;
    /**
     * 
     * @type {string}
     * @memberof DeltaMetadataResponse
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeltaMetadataResponse
     */
    'shared'?: boolean;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaRequest
 */
export interface DeltaRequest {
    /**
     * 
     * @type {DeltaMetadataRequest}
     * @memberof DeltaRequest
     */
    'metadata'?: DeltaMetadataRequest;
    /**
     * 
     * @type {ModuleDeltasRequest}
     * @memberof DeltaRequest
     */
    'modules'?: ModuleDeltasRequest;
    /**
     * 
     * @type {Array<UpdateActionRequest>}
     * @memberof DeltaRequest
     */
    'shared'?: Array<UpdateActionRequest>;
}
/**
 * A Deployment Delta (or just \"Delta\") describes the changes that must be applied to one Deployment Set to generate another Deployment Set. Deployment Deltas are the only way to create new Deployment Sets.  Deployment Deltas can be created fully formed or combined together via PATCHing. They can also be generated from the difference between two Deployment Sets.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Delta.>,    \"metadata\": {      <Properties such as who created the Delta, which Environment it is associated to and a Human-friendly name>    }    \"modules\" : {      \"add\" : {        <ID of Module to add to the Deployment Set> : {          <An entire Modules object>        }      },      \"remove\": [        <An array of Module IDs that should be removed from the Deployment Set>      ],     \"update\": {        <ID of Module already in the Set to be updated> : [          <An array of JSON Patch (Search Results (RFC 6902) objects scoped to the module>        ]      }    }  } ```
 * @export
 * @interface DeltaResponse
 */
export interface DeltaResponse {
    /**
     * A unique ID for the Delta
     * @type {string}
     * @memberof DeltaResponse
     */
    'id': string;
    /**
     * 
     * @type {DeltaMetadataResponse}
     * @memberof DeltaResponse
     */
    'metadata': DeltaMetadataResponse;
    /**
     * 
     * @type {ModuleDeltasResponse}
     * @memberof DeltaResponse
     */
    'modules': ModuleDeltasResponse;
    /**
     * 
     * @type {Array<UpdateActionResponse>}
     * @memberof DeltaResponse
     */
    'shared': Array<UpdateActionResponse>;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionRequest
 */
export interface DeployConditionRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'success'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionRequest
     */
    'timeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionRequest
     */
    'when'?: string;
}
/**
 * A deploy condition for the workload  Possible values for \"when\" are: - \"before\", deployed before other workloads - \"deploy\", deployed in-parallel with other workloads (default) - \"after\", deployed after other workloads  Possible values for \"success\" are: - \"deploy\", workload deployed - \"available\", workload available - \"complete\", workload complete (often used with jobs)
 * @export
 * @interface DeployConditionResponse
 */
export interface DeployConditionResponse {
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'success': string;
    /**
     * 
     * @type {number}
     * @memberof DeployConditionResponse
     */
    'timeout': number;
    /**
     * 
     * @type {string}
     * @memberof DeployConditionResponse
     */
    'when': string;
}
/**
 * DeploymentError is an error happening during deployment
 * @export
 * @interface DeploymentErrorRequest
 */
export interface DeploymentErrorRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'object_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorRequest
     */
    'summary'?: string;
}
/**
 * DeploymentError is an error happening during deployment
 * @export
 * @interface DeploymentErrorResponse
 */
export interface DeploymentErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'object_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentErrorResponse
     */
    'summary': string;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentRequest
 */
export interface DeploymentRequest {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'comment'?: string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'delta_id'?: string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentRequest
     */
    'value_set_version_id'?: string | null;
}
/**
 * Deployments represent updates to the running state of an Environment.  Deployments are made by applying _Deltas_ to a state defined by an existing Deployment. The Environment’s from_deploy property defines the Deployment. This Deployment is usually but not always in the current Environment. If the Deployment is from another Environment, the state of that Environment will be \"cloned\" into the current Environment with the option to apply a Delta.
 * @export
 * @interface DeploymentResponse
 */
export interface DeploymentResponse {
    /**
     * An optional comment to help communicate the purpose of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'comment': string;
    /**
     * The Timestamp of when the Deployment was initiated.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_at': string;
    /**
     * The user who initiated the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'created_by': string;
    /**
     * ID of the Deployment Delta describing the changes to the current Environment for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'delta_id'?: string;
    /**
     * The Environment where the Deployment occurred.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'env_id': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_file': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentResponse
     */
    'export_status': string;
    /**
     * The ID of the Deployment that this Deployment was based on.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'from_id': string;
    /**
     * The ID of the Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'id': string;
    /**
     * ID of the Deployment Set describing the state of the Environment after Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'set_id': string;
    /**
     * The current status of the Deployment. Can be `pending`, `in progress`, `succeeded`, or `failed`.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status': string;
    /**
     * The timestamp of the last `status` change. If `status` is `succeeded` or `failed` it it will indicate when the Deployment finished.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'status_changed_at': string;
    /**
     * ID of the Value Set Version describe the values to be used for this Deployment.
     * @type {string}
     * @memberof DeploymentResponse
     */
    'value_set_version_id'?: string | null;
}
/**
 * DeploymentTimestamps aggregates creation dates of current and next succeful deployments
 * @export
 * @interface DeploymentTimestampsRequest
 */
export interface DeploymentTimestampsRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsRequest
     */
    'created_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsRequest
     */
    'stopped_at'?: string | null;
}
/**
 * DeploymentTimestamps aggregates creation dates of current and next succeful deployments
 * @export
 * @interface DeploymentTimestampsResponse
 */
export interface DeploymentTimestampsResponse {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsResponse
     */
    'created_at': string | null;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTimestampsResponse
     */
    'stopped_at'?: string | null;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionRequest
 */
export interface DriverDefinitionRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionRequest
     */
    'account_types'?: Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'id'?: string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof DriverDefinitionRequest
     */
    'is_public'?: boolean;
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'org_id'?: string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'type'?: string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see `url_prefix`.
     * @type {string}
     * @memberof DriverDefinitionRequest
     */
    'url_prefix'?: string;
}
/**
 * DriverDefinition describes the resource driver.  Resource Drivers are code that fulfils the Humanitec Resource Driver Interface. This interface allows for certain actions to be performed on resources such as creation and destruction. Humanitec provides numerous Resource Drivers “out of the box”. It is also possible to use 3rd party Resource Drivers or write your own.
 * @export
 * @interface DriverDefinitionResponse
 */
export interface DriverDefinitionResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof DriverDefinitionResponse
     */
    'account_types': Array<string>;
    /**
     * The ID for this driver. Is used as `driver_type`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'id': string;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof DriverDefinitionResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof DriverDefinitionResponse
     */
    'is_public': boolean;
    /**
     * The Organization this driver exists under. Useful as public drivers are accessible to other orgs.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'org_id': string;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see `target`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'target'?: string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof DriverDefinitionResponse
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see `url_prefix`.
     * @type {string}
     * @memberof DriverDefinitionResponse
     */
    'url_prefix'?: string;
}
/**
 * DriverInputs describes the resource and the input paramaters for the driver.
 * @export
 * @interface DriverInputsRequest
 */
export interface DriverInputsRequest {
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof DriverInputsRequest
     */
    'driver'?: ValuesSecretsRequest;
    /**
     * The resource-related parameters passed from the deployment set (if any).
     * @type {{ [key: string]: any; }}
     * @memberof DriverInputsRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * The type of the resource to generate.
     * @type {string}
     * @memberof DriverInputsRequest
     */
    'type'?: string;
}
/**
 * DriverInputs describes the resource and the input paramaters for the driver.
 * @export
 * @interface DriverInputsResponse
 */
export interface DriverInputsResponse {
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof DriverInputsResponse
     */
    'driver': ValuesSecretsResponse;
    /**
     * The resource-related parameters passed from the deployment set (if any).
     * @type {{ [key: string]: any; }}
     * @memberof DriverInputsResponse
     */
    'resource': { [key: string]: any; };
    /**
     * The type of the resource to generate.
     * @type {string}
     * @memberof DriverInputsResponse
     */
    'type': string;
}
/**
 * DriverOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface DriverOutputsRequest
 */
export interface DriverOutputsRequest {
    /**
     * The resource GUResID.
     * @type {string}
     * @memberof DriverOutputsRequest
     */
    'id'?: string;
    /**
     * The resource definition manifests (if any).
     * @type {Array<ManifestRequest>}
     * @memberof DriverOutputsRequest
     */
    'manifests'?: Array<ManifestRequest>;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof DriverOutputsRequest
     */
    'resource'?: ValuesSecretsRequest;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof DriverOutputsRequest
     */
    'type'?: string;
}
/**
 * DriverOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface DriverOutputsResponse
 */
export interface DriverOutputsResponse {
    /**
     * The resource GUResID.
     * @type {string}
     * @memberof DriverOutputsResponse
     */
    'id': string;
    /**
     * The resource definition manifests (if any).
     * @type {Array<ManifestResponse>}
     * @memberof DriverOutputsResponse
     */
    'manifests': Array<ManifestResponse>;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof DriverOutputsResponse
     */
    'resource': ValuesSecretsResponse;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof DriverOutputsResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseRequest
 */
export interface EnvironmentBaseRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentBaseResponse
 */
export interface EnvironmentBaseResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentBaseResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionRequest
 */
export interface EnvironmentDefinitionRequest {
    /**
     * Defines the existing Deployment the new Environment will be based on.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'from_deploy_id': string;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionRequest
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface EnvironmentDefinitionResponse
 */
export interface EnvironmentDefinitionResponse {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentDefinitionResponse
     */
    'type': string;
}
/**
 * EnvironmentPausedInfo
 * @export
 * @interface EnvironmentPausedInfoRequest
 */
export interface EnvironmentPausedInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentPausedInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentPausedInfoRequest
     */
    'paused'?: boolean;
}
/**
 * EnvironmentPausedInfo
 * @export
 * @interface EnvironmentPausedInfoResponse
 */
export interface EnvironmentPausedInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentPausedInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentPausedInfoResponse
     */
    'paused': boolean;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentRequest
 */
export interface EnvironmentRequest {
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'id': string;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentRequest
     */
    'type': string;
}
/**
 * Environments are independent spaces where Applications can run. An Application is always deployed into an Environment.
 * @export
 * @interface EnvironmentResponse
 */
export interface EnvironmentResponse {
    /**
     * The timestamp in UTC of when the Environment was created.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_at': string;
    /**
     * The user who created the Environment
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'created_by': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'from_deploy'?: DeploymentResponse;
    /**
     * The ID the Environment is referenced as.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'id': string;
    /**
     * 
     * @type {DeploymentResponse}
     * @memberof EnvironmentResponse
     */
    'last_deploy'?: DeploymentResponse;
    /**
     * The Human-friendly name for the Environment.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'name': string;
    /**
     * The Environment Type. This is used for organizing and managing Environments.
     * @type {string}
     * @memberof EnvironmentResponse
     */
    'type': string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoRequest
 */
export interface EnvironmentRuntimeInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'paused'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoRequest
     */
    'status'?: string;
}
/**
 * EnvironmentRuntimeInfo
 * @export
 * @interface EnvironmentRuntimeInfoResponse
 */
export interface EnvironmentRuntimeInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'paused': boolean;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentRuntimeInfoResponse
     */
    'status'?: string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeRequest
 */
export interface EnvironmentTypeRequest {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'description'?: string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeRequest
     */
    'id': string;
}
/**
 * Environment Types are a way of grouping and managing Environments. Every Environment has exactly 1 Environment Type.  Environment Types can be used with External Resources to manage where resources such as databases are provisioned or even which cluster to deploy to.
 * @export
 * @interface EnvironmentTypeResponse
 */
export interface EnvironmentTypeResponse {
    /**
     * A Human-readable description of the Environment Type
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'description': string;
    /**
     * The ID of the Environment Type. (Must be unique within an Organization.)
     * @type {string}
     * @memberof EnvironmentTypeResponse
     */
    'id': string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoRequest
 */
export interface ErrorInfoRequest {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoRequest
     */
    'error'?: string;
}
/**
 * ErrorInfo is returned by a handler in case of an error.
 * @export
 * @interface ErrorInfoResponse
 */
export interface ErrorInfoResponse {
    /**
     * An error details
     * @type {string}
     * @memberof ErrorInfoResponse
     */
    'error': string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseRequest
 */
export interface EventBaseRequest {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseRequest
     */
    'type'?: string;
}
/**
 * Properties which identify an event .
 * @export
 * @interface EventBaseResponse
 */
export interface EventBaseResponse {
    /**
     * Event scope
     * @type {string}
     * @memberof EventBaseResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventBaseResponse
     */
    'type': string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventRequest
 */
export interface EventRequest {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventRequest
     */
    'properties'?: Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventRequest
     */
    'scope'?: string;
    /**
     * Event type
     * @type {string}
     * @memberof EventRequest
     */
    'type'?: string;
}
/**
 * Events available for triggering automated jobs.
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * List of event properties which can be used as variables for this event
     * @type {Array<string>}
     * @memberof EventResponse
     */
    'properties': Array<string>;
    /**
     * Event scope
     * @type {string}
     * @memberof EventResponse
     */
    'scope': string;
    /**
     * Event type
     * @type {string}
     * @memberof EventResponse
     */
    'type': string;
}
/**
 * ExportFile is export file URL and metadata, it\'s  what export endpoint returns
 * @export
 * @interface ExportFileRequest
 */
export interface ExportFileRequest {
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileRequest
     */
    'url'?: string;
}
/**
 * ExportFile is export file URL and metadata, it\'s  what export endpoint returns
 * @export
 * @interface ExportFileResponse
 */
export interface ExportFileResponse {
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'size': string;
    /**
     * 
     * @type {string}
     * @memberof ExportFileResponse
     */
    'url': string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorRequest
 */
export interface HumanitecErrorRequest {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorRequest
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorRequest
     */
    'error'?: string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorRequest
     */
    'message'?: string;
}
/**
 * HumanitecError represents a standard Humanitec Error
 * @export
 * @interface HumanitecErrorResponse
 */
export interface HumanitecErrorResponse {
    /**
     * (Optional) Additional information is enclosed here.
     * @type {{ [key: string]: any; }}
     * @memberof HumanitecErrorResponse
     */
    'details'?: { [key: string]: any; };
    /**
     * A short code to help with error identification.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'error': string;
    /**
     * A Human readable message about the error.
     * @type {string}
     * @memberof HumanitecErrorResponse
     */
    'message': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface IdPRequest
 */
export interface IdPRequest {
    /**
     * ID of an existing user with permissions to apply roles to new users within the org.
     * @type {string}
     * @memberof IdPRequest
     */
    'authorizing_user_id': string;
    /**
     * One or more domains that this IdP should be associated to.
     * @type {Array<string>}
     * @memberof IdPRequest
     */
    'domains': Array<string>;
    /**
     * ID used to refere to the IdP in Humanitec
     * @type {string}
     * @memberof IdPRequest
     */
    'id': string;
    /**
     * Base64 encoded SAML IdP Metadata XML
     * @type {Array<number>}
     * @memberof IdPRequest
     */
    'metadata': Array<number>;
    /**
     * A possibly empty array of additional roles on objects that the user should have.
     * @type {Array<ObjectRoleRequest>}
     * @memberof IdPRequest
     */
    'object_roles': Array<ObjectRoleRequest>;
    /**
     * ID of the Organization that the new user should be added to.
     * @type {string}
     * @memberof IdPRequest
     */
    'org_id': string;
    /**
     * The role that the new user should have on the organization
     * @type {string}
     * @memberof IdPRequest
     */
    'role': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface IdPResponse
 */
export interface IdPResponse {
    /**
     * ID of an existing user with permissions to apply roles to new users within the org.
     * @type {string}
     * @memberof IdPResponse
     */
    'authorizing_user_id': string;
    /**
     * One or more domains that this IdP should be associated to.
     * @type {Array<string>}
     * @memberof IdPResponse
     */
    'domains': Array<string>;
    /**
     * ID used to refere to the IdP in Humanitec
     * @type {string}
     * @memberof IdPResponse
     */
    'id': string;
    /**
     * Base64 encoded SAML IdP Metadata XML
     * @type {Array<number>}
     * @memberof IdPResponse
     */
    'metadata': Array<number>;
    /**
     * A possibly empty array of additional roles on objects that the user should have.
     * @type {Array<ObjectRoleResponse>}
     * @memberof IdPResponse
     */
    'object_roles': Array<ObjectRoleResponse>;
    /**
     * ID of the Organization that the new user should be added to.
     * @type {string}
     * @memberof IdPResponse
     */
    'org_id': string;
    /**
     * The role that the new user should have on the organization
     * @type {string}
     * @memberof IdPResponse
     */
    'role': string;
}
/**
 * IdentityToken holds the Identity providers temporary token along with the provider it is associated to.
 * @export
 * @interface IdentityTokenRequest
 */
export interface IdentityTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenRequest
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenRequest
     */
    'token'?: string;
}
/**
 * IdentityToken holds the Identity providers temporary token along with the provider it is associated to.
 * @export
 * @interface IdentityTokenResponse
 */
export interface IdentityTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenResponse
     */
    'provider': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityTokenResponse
     */
    'token': string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildRequest
 */
export interface ImageBuildRequest {
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'branch'?: string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'commit'?: string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildRequest
     */
    'image'?: string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildRequest
     */
    'tags'?: Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Holds the metadata associated withe a Container Image Build
 * @export
 * @interface ImageBuildResponse
 */
export interface ImageBuildResponse {
    /**
     * The time when the build was added to Humanitec.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'added_at'?: string;
    /**
     * The branch name of the branch the build was built on
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'branch': string;
    /**
     * The commit ID that this build was built from.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'commit': string;
    /**
     * The fully qualified Image URL including registry, repository and tag.
     * @type {string}
     * @memberof ImageBuildResponse
     */
    'image': string;
    /**
     * The tag that the build was built from.
     * @type {Array<string>}
     * @memberof ImageBuildResponse
     */
    'tags': Array<string>;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageRequest
 */
export interface ImageRequest {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageRequest
     */
    'added_at'?: string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildRequest>}
     * @memberof ImageRequest
     */
    'builds'?: Array<ImageBuildRequest>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageRequest
     */
    'id'?: string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageRequest
     */
    'source'?: string;
}
/**
 * DEPRECATED: This type exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Container Images (known simply as Images) can be registered with Humanitec. Continuous Integration (CI) pipelines can then notify Humanitec when a new build of a Container Image becomes available. Humanitec tracks the Image along with metadata about how it was built.
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * The time the first build of this Image was added to the organization
     * @type {string}
     * @memberof ImageResponse
     */
    'added_at': string;
    /**
     * A list of Image Builds ordered by addition date.
     * @type {Array<ImageBuildResponse>}
     * @memberof ImageResponse
     */
    'builds': Array<ImageBuildResponse>;
    /**
     * The ID used to group different builds of the same Image together.
     * @type {string}
     * @memberof ImageResponse
     */
    'id': string;
    /**
     * The Image Source that this Image is added via
     * @type {string}
     * @memberof ImageResponse
     */
    'source': string;
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsRequest
 */
export interface ImagesRegistryCredsRequest {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsRequest
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof ImagesRegistryCredsRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
}
/**
 * ImagesRegistryCreds stores registry credentials details alongside with associated images.
 * @export
 * @interface ImagesRegistryCredsResponse
 */
export interface ImagesRegistryCredsResponse {
    /**
     * List of images associated with the registry.
     * @type {Array<string>}
     * @memberof ImagesRegistryCredsResponse
     */
    'images': Array<string>;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof ImagesRegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof ImagesRegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
}
/**
 * 
 * @export
 * @interface InternalActiveResourceRequest
 */
export interface InternalActiveResourceRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'app_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'def_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'env_id'?: string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'env_type'?: string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'gu_res_id'?: string;
    /**
     * The ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'org_id'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'res_id'?: string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof InternalActiveResourceRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'status'?: string;
    /**
     * The Resource Type of the resource.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'type'?: string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof InternalActiveResourceRequest
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface InternalActiveResourceResponse
 */
export interface InternalActiveResourceResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'app_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'def_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'env_id': string;
    /**
     * The Environment Type of the Environment specified by env_id.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'env_type': string;
    /**
     * Globally unique resource id
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'gu_res_id': string;
    /**
     * The ID of the Organization the Active Resource is associated with.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'org_id': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'res_id': string;
    /**
     * The data that the resource passes into the deployment (\'values\' only).
     * @type {{ [key: string]: any; }}
     * @memberof InternalActiveResourceResponse
     */
    'resource': { [key: string]: any; };
    /**
     * Current resource status: \'pending\', \'active\', or \'deleting\'.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'status': string;
    /**
     * The Resource Type of the resource.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'type': string;
    /**
     * The time the resource was last provisioned as part of a deployment.
     * @type {string}
     * @memberof InternalActiveResourceResponse
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface InternalJSONPatchRequest
 */
export interface InternalJSONPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalJSONPatchRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalJSONPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {InternalValueRequest}
     * @memberof InternalJSONPatchRequest
     */
    'value'?: InternalValueRequest;
}
/**
 * 
 * @export
 * @interface InternalJSONPatchResponse
 */
export interface InternalJSONPatchResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalJSONPatchResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof InternalJSONPatchResponse
     */
    'path': string;
    /**
     * 
     * @type {InternalValueResponse}
     * @memberof InternalJSONPatchResponse
     */
    'value'?: InternalValueResponse;
}
/**
 * 
 * @export
 * @interface InternalValueRequest
 */
export interface InternalValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueRequest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_store_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueRequest
     */
    'secret_version'?: string | null;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueRequest
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InternalValueResponse
 */
export interface InternalValueResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof InternalValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof InternalValueResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_key': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_store_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'secret_version': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof InternalValueResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface InternalValueSetVersionRequest
 */
export interface InternalValueSetVersionRequest {
    /**
     * 
     * @type {Array<InternalJSONPatchRequest>}
     * @memberof InternalValueSetVersionRequest
     */
    'change'?: Array<InternalJSONPatchRequest>;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'result_of'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'source_value_set_version_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {{ [key: string]: InternalValueRequest; }}
     * @memberof InternalValueSetVersionRequest
     */
    'values'?: { [key: string]: InternalValueRequest; };
}
/**
 * 
 * @export
 * @interface InternalValueSetVersionResponse
 */
export interface InternalValueSetVersionResponse {
    /**
     * 
     * @type {Array<InternalJSONPatchResponse>}
     * @memberof InternalValueSetVersionResponse
     */
    'change': Array<InternalJSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'result_of': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof InternalValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: InternalValueResponse; }}
     * @memberof InternalValueSetVersionResponse
     */
    'values': { [key: string]: InternalValueResponse; };
}
/**
 * 
 * @export
 * @interface InternalWorkloadProfileRequest
 */
export interface InternalWorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof InternalWorkloadProfileRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface InternalWorkloadProfileResponse
 */
export interface InternalWorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'id': string;
    /**
     * The latest version of the profile
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'latest': string;
    /**
     * The latest version of the profile schema
     * @type {any}
     * @memberof InternalWorkloadProfileResponse
     */
    'latest_schema': any;
    /**
     * Organization ID
     * @type {string}
     * @memberof InternalWorkloadProfileResponse
     */
    'org_id': string;
}
/**
 * 
 * @export
 * @interface JSONPatchRequest
 */
export interface JSONPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {ValueRequest}
     * @memberof JSONPatchRequest
     */
    'value'?: ValueRequest;
}
/**
 * 
 * @export
 * @interface JSONPatchResponse
 */
export interface JSONPatchResponse {
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof JSONPatchResponse
     */
    'path': string;
    /**
     * 
     * @type {ValueResponse}
     * @memberof JSONPatchResponse
     */
    'value'?: ValueResponse;
}
/**
 * 
 * @export
 * @interface LegacyTokenRequestRequest
 */
export interface LegacyTokenRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestRequest
     */
    'org_id'?: string;
}
/**
 * 
 * @export
 * @interface LegacyTokenRequestResponse
 */
export interface LegacyTokenRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof LegacyTokenRequestResponse
     */
    'org_id': string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestRequest
 */
export interface ManifestRequest {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestRequest
     */
    'data'?: any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestRequest
     */
    'location'?: string;
}
/**
 * Manifest represents a complete or a partial Kubernetes manifest, and a location for its injection.
 * @export
 * @interface ManifestResponse
 */
export interface ManifestResponse {
    /**
     * Manifest data to inject.
     * @type {any}
     * @memberof ManifestResponse
     */
    'data': any;
    /**
     * Location to inject the Manifest at.
     * @type {string}
     * @memberof ManifestResponse
     */
    'location': string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaRequest
 */
export interface MatchingCriteriaRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'id'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRequest
     */
    'res_id'?: string;
}
/**
 * Matching Criteria are a set of rules used to choose which Resource Definition to use to provision a particular Resource Type.  Matching criteria are made up in order of specificity with least specific first:  - Environment Type (`env_type`)  - Application (`app_id`)  - Environment (`env_id`)  - Resource (`res_id`)  When selecting matching criteria, the most specific one is selected. In general, this means of all the Matching Criteria fully matching the context, the Matching Criteria Rule with the most specific element filled is chosen. If there is a tie, the next most specific elements are compared and so on until one is chosen.  **NOTE:**  Humanitec will reject the registration of matching criteria rules that duplicate rules already present for a Resource Type.
 * @export
 * @interface MatchingCriteriaResponse
 */
export interface MatchingCriteriaResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'env_type'?: string;
    /**
     * Matching Criteria ID
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'id': string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaResponse
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleRequest
 */
export interface MatchingCriteriaRuleRequest {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleRequest
     */
    'res_id'?: string;
}
/**
 * MatchingCriteriaRule describes Matching Criteria rules.
 * @export
 * @interface MatchingCriteriaRuleResponse
 */
export interface MatchingCriteriaRuleResponse {
    /**
     * (Optional) The ID of the Application that the Resources should belong to.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'app_id'?: string;
    /**
     * (Optional) The ID of the Environment that the Resources should belong to. If `env_type` is also set, it must match the Type of the Environment for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'env_id'?: string;
    /**
     * (Optional) The Type of the Environment that the Resources should belong to. If `env_id` is also set, it must have an Environment Type that matches this parameter for the Criteria to match.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'env_type'?: string;
    /**
     * (Optional) The ID of the Resource in the Deployment Set. The ID is normally a `.` separated path to the definition in the set, e.g. `modules.my-module.externals.my-database`.
     * @type {string}
     * @memberof MatchingCriteriaRuleResponse
     */
    'res_id'?: string;
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasRequest
 */
export interface ModuleDeltasRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof ModuleDeltasRequest
     */
    'add'?: { [key: string]: ModuleRequest; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasRequest
     */
    'remove'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionRequest>; }}
     * @memberof ModuleDeltasRequest
     */
    'update'?: { [key: string]: Array<UpdateActionRequest>; };
}
/**
 * ModuleDeltas groups the different operations together.
 * @export
 * @interface ModuleDeltasResponse
 */
export interface ModuleDeltasResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof ModuleDeltasResponse
     */
    'add': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleDeltasResponse
     */
    'remove': Array<string>;
    /**
     * 
     * @type {{ [key: string]: Array<UpdateActionResponse>; }}
     * @memberof ModuleDeltasResponse
     */
    'update': { [key: string]: Array<UpdateActionResponse>; };
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleRequest
 */
export interface ModuleRequest {
    [key: string]: ControllerRequest | any;

    /**
     * 
     * @type {DeployConditionRequest}
     * @memberof ModuleRequest
     */
    'deploy'?: DeployConditionRequest;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'externals'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleRequest
     */
    'profile'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleRequest
     */
    'spec'?: { [key: string]: any; };
}
/**
 * Module represents a collection of workload controllers (deployments/statefulsets/etc) for the module
 * @export
 * @interface ModuleResponse
 */
export interface ModuleResponse {
    [key: string]: ControllerResponse | any;

    /**
     * 
     * @type {DeployConditionResponse}
     * @memberof ModuleResponse
     */
    'deploy'?: DeployConditionResponse;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'externals': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModuleResponse
     */
    'profile': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModuleResponse
     */
    'spec': { [key: string]: any; };
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserRequest
 */
export interface NewServiceUserRequest {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'name'?: string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserRequest
     */
    'role'?: string;
}
/**
 * NewServiceUser holds the definition of a new service user.
 * @export
 * @interface NewServiceUserResponse
 */
export interface NewServiceUserResponse {
    /**
     * The email address that should get notifications about this service user. (Optional)
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'email'?: string;
    /**
     * The name that should be shown for this service user.
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'name': string;
    /**
     * The role that the service user should have on the organization it is created in
     * @type {string}
     * @memberof NewServiceUserResponse
     */
    'role': string;
}
/**
 * Node Represents a node of a Resource Dependency Graph
 * @export
 * @interface NodeRequest
 */
export interface NodeRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'driver'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'guresid'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'id'?: string;
    /**
     * Parameters with which the resource should be provisioned
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeRequest
     */
    'resource_schema'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeRequest
     */
    'type'?: string;
}
/**
 * Node Represents a node of a Resource Dependency Graph
 * @export
 * @interface NodeResponse
 */
export interface NodeResponse {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'driver': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'guresid': string;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'id': string;
    /**
     * Parameters with which the resource should be provisioned
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'resource': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof NodeResponse
     */
    'resource_schema': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'target': string;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'type': string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface ObjectRoleRequest
 */
export interface ObjectRoleRequest {
    /**
     * The ID of the object
     * @type {string}
     * @memberof ObjectRoleRequest
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectRoleRequest
     */
    'role'?: string;
}
/**
 * IdP metadata needed by Humanitec to interact with a SAML IdP
 * @export
 * @interface ObjectRoleResponse
 */
export interface ObjectRoleResponse {
    /**
     * The ID of the object
     * @type {string}
     * @memberof ObjectRoleResponse
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectRoleResponse
     */
    'role': string;
}
/**
 * ObjectUserRole holds the mapping of a Role that a User holds for a particular Object.
 * @export
 * @interface ObjectUserRoleRequest
 */
export interface ObjectUserRoleRequest {
    /**
     * The Object the the User holds the Role on
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'object'?: string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'role'?: string;
    /**
     * The User ID that hold the Role on the Object
     * @type {string}
     * @memberof ObjectUserRoleRequest
     */
    'user'?: string;
}
/**
 * ObjectUserRole holds the mapping of a Role that a User holds for a particular Object.
 * @export
 * @interface ObjectUserRoleResponse
 */
export interface ObjectUserRoleResponse {
    /**
     * The Object the the User holds the Role on
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'object': string;
    /**
     * The Role that this User holds on the Object
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'role': string;
    /**
     * The User ID that hold the Role on the Object
     * @type {string}
     * @memberof ObjectUserRoleResponse
     */
    'user': string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'id'?: string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationRequest
     */
    'name'?: string;
}
/**
 * An Organization is the top level object in Humanitec. All other objects belong to an Organization.
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * Timestamp when the Organization was created.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_at': string | null;
    /**
     * User ID that created the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'created_by': string;
    /**
     * Unique ID for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'id': string;
    /**
     * Human friendly name for the Organization.
     * @type {string}
     * @memberof OrganizationResponse
     */
    'name': string;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateRequest
 */
export interface PodStateRequest {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateRequest
     */
    'containerStatuses'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'phase'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'podName'?: string;
    /**
     * 
     * @type {number}
     * @memberof PodStateRequest
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof PodStateRequest
     */
    'status'?: string;
}
/**
 * PodState represents single pod status
 * @export
 * @interface PodStateResponse
 */
export interface PodStateResponse {
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PodStateResponse
     */
    'containerStatuses': Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'phase': string;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'podName': string;
    /**
     * 
     * @type {number}
     * @memberof PodStateResponse
     */
    'revision': number;
    /**
     * 
     * @type {string}
     * @memberof PodStateResponse
     */
    'status': string;
}
/**
 * RegisterIdentityToken holds the Identity providers temporary token along with the provider it is associated to. It also has a required field of `privacy_policy_accepted`.
 * @export
 * @interface RegisterIdentityTokenRequest
 */
export interface RegisterIdentityTokenRequest {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterIdentityTokenRequest
     */
    'privacy_policy_accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'provider'?: string;
    /**
     * (optional) The reference to the source of the signup.
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'signup_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenRequest
     */
    'token'?: string;
}
/**
 * RegisterIdentityToken holds the Identity providers temporary token along with the provider it is associated to. It also has a required field of `privacy_policy_accepted`.
 * @export
 * @interface RegisterIdentityTokenResponse
 */
export interface RegisterIdentityTokenResponse {
    /**
     * 
     * @type {boolean}
     * @memberof RegisterIdentityTokenResponse
     */
    'privacy_policy_accepted': boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'provider': string;
    /**
     * (optional) The reference to the source of the signup.
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'signup_ref': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIdentityTokenResponse
     */
    'token': string;
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsRequest
 */
export interface RegistryCredsRequest {
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryCredsRequest
     */
    'secrets': { [key: string]: ClusterSecretRequest; };
}
/**
 * RegistryCreds represents current registry credentials (either, username- or token-based).
 * @export
 * @interface RegistryCredsResponse
 */
export interface RegistryCredsResponse {
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryCredsResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryCredsResponse
     */
    'secrets': { [key: string]: ClusterSecretResponse; };
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryRequest
 */
export interface RegistryRequest {
    /**
     * 
     * @type {AccountCredsRequest}
     * @memberof RegistryRequest
     */
    'creds'?: AccountCredsRequest;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryRequest
     */
    'enable_ci'?: boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryRequest
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryRequest
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretRequest; }}
     * @memberof RegistryRequest
     */
    'secrets'?: { [key: string]: ClusterSecretRequest; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryRequest
     */
    'type': string;
}
/**
 * Humanitec can be used to manage registry credentials. The Registry object represents how to match credentials to a particular registry.  Humanitec supports all Docker compatible registries as well as the custom authentication formats used by AWS Elastic Container Registry and Google Container Registry. It also supports the injection of a specific secret to be copied from an existing namespace in the cluster.
 * @export
 * @interface RegistryResponse
 */
export interface RegistryResponse {
    /**
     * The timestamp of when this record was created.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_at'?: string | null;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof RegistryResponse
     */
    'created_by'?: string;
    /**
     * Indicates if registry secrets and credentials should be exposed to CI agents.
     * @type {boolean}
     * @memberof RegistryResponse
     */
    'enable_ci': boolean;
    /**
     * Registry ID, unique within the Organization.
     * @type {string}
     * @memberof RegistryResponse
     */
    'id': string;
    /**
     * Registry name, usually in a \"{domain}\" or \"{domain}/{project}\" format.
     * @type {string}
     * @memberof RegistryResponse
     */
    'registry': string;
    /**
     * ClusterSecretsMap stores a list of Kuberenetes secret references for the target deployment clusters.
     * @type {{ [key: string]: ClusterSecretResponse; }}
     * @memberof RegistryResponse
     */
    'secrets'?: { [key: string]: ClusterSecretResponse; };
    /**
     * Registry type, describes the registry authentication method, and defines the schema for the credentials.  Supported values:  - `public`  - `basic`  - `google_gcr`  - `amazon_ecr`  - `secret_ref`
     * @type {string}
     * @memberof RegistryResponse
     */
    'type': string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountRequest
 */
export interface ResourceAccountRequest {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_at'?: string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'created_by'?: string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'id'?: string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountRequest
     */
    'is_used'?: boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'name'?: string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountRequest
     */
    'type'?: string;
}
/**
 * ResourceAccount represents the account being used to access a resource.  Resource Accounts hold credentials that are required to provision and manage resources.
 * @export
 * @interface ResourceAccountResponse
 */
export interface ResourceAccountResponse {
    /**
     * The timestamp of when the account was created.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created the account.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'created_by': string;
    /**
     * Unique identifier for the account (in scope of the organization it belongs to).
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'id': string;
    /**
     * Indicates if this account is being used (referenced) by any resource definition.
     * @type {boolean}
     * @memberof ResourceAccountResponse
     */
    'is_used': boolean;
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'name': string;
    /**
     * The type of the account
     * @type {string}
     * @memberof ResourceAccountResponse
     */
    'type': string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeRequest
 */
export interface ResourceDefinitionChangeRequest {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'app_id'?: string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'env_id'?: string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'from_def'?: string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'res_id'?: string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeRequest
     */
    'to_def'?: string;
}
/**
 * ResourceDefinitionChange describes the effects of a Resource Definition or Matching Criteria update/deletion.
 * @export
 * @interface ResourceDefinitionChangeResponse
 */
export interface ResourceDefinitionChangeResponse {
    /**
     * The ID of the App the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'app_id': string;
    /**
     * The ID of the Environment the resource is associated with.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'env_id': string;
    /**
     * The Resource Definition that this resource was provisioned from.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'from_def': string;
    /**
     * The ID of the resource
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'res_id': string;
    /**
     * The Resource Definition that resource *will be* provisioned from if the change is applied.
     * @type {string}
     * @memberof ResourceDefinitionChangeResponse
     */
    'to_def': string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionRequest
 */
export interface ResourceDefinitionRequest {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaRequest>}
     * @memberof ResourceDefinitionRequest
     */
    'criteria'?: Array<MatchingCriteriaRequest>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof ResourceDefinitionRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'id'?: string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionRequest
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'name'?: string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'org_id'?: string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionRequest
     */
    'type'?: string;
}
/**
 * A Resource Definitions describes how and when a resource should be provisioned. It links a driver (the how) along with a Matching Criteria (the when) to a Resource Type. This allows Humanitec to invoke a particular driver for the required Resource Type in the context of a particular Application and Environment.  The schema for the `driver_inputs` is defined by the `input_schema` property on the DriverDefinition identified by the `driver_type` property.
 * @export
 * @interface ResourceDefinitionResponse
 */
export interface ResourceDefinitionResponse {
    /**
     * The timestamp of when this record has been created.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_at'?: string;
    /**
     * The user who created this record.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'created_by'?: string;
    /**
     * (Optional) The criteria to use when looking for a Resource Definition during the deployment.
     * @type {Array<MatchingCriteriaResponse>}
     * @memberof ResourceDefinitionResponse
     */
    'criteria'?: Array<MatchingCriteriaResponse>;
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_account'?: string;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof ResourceDefinitionResponse
     */
    'driver_inputs'?: ValuesSecretsResponse;
    /**
     * The driver to be used to create the resource.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'driver_type'?: string;
    /**
     * The Resource Definition ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'id': string;
    /**
     * Indicates this definition is a built-in one (provided by Humanitec).
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_default'?: boolean;
    /**
     * Indicates if this record has been marked for deletion. The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @type {boolean}
     * @memberof ResourceDefinitionResponse
     */
    'is_deleted'?: boolean;
    /**
     * The display name.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'name': string;
    /**
     * The Organization ID.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'org_id': string;
    /**
     * The Resource Type.
     * @type {string}
     * @memberof ResourceDefinitionResponse
     */
    'type': string;
}
/**
 * ResourceOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface ResourceOutputsRequest
 */
export interface ResourceOutputsRequest {
    /**
     * The Resource Definitions ID that was used to provision the resource.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'def_id'?: string;
    /**
     * The resource ID.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'id'?: string;
    /**
     * The resource definition manifests (if any). Only available when status is \'active\'.
     * @type {Array<ManifestRequest>}
     * @memberof ResourceOutputsRequest
     */
    'manifests'?: Array<ManifestRequest>;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof ResourceOutputsRequest
     */
    'resource'?: ValuesSecretsRequest;
    /**
     * The resource availability status: pending, active, or deleting.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'status'?: string;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof ResourceOutputsRequest
     */
    'type'?: string;
}
/**
 * ResourceOutputs stores all the necessary information about the provisioned resource.
 * @export
 * @interface ResourceOutputsResponse
 */
export interface ResourceOutputsResponse {
    /**
     * The Resource Definitions ID that was used to provision the resource.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'def_id': string;
    /**
     * The resource ID.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'id': string;
    /**
     * The resource definition manifests (if any). Only available when status is \'active\'.
     * @type {Array<ManifestResponse>}
     * @memberof ResourceOutputsResponse
     */
    'manifests': Array<ManifestResponse>;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof ResourceOutputsResponse
     */
    'resource': ValuesSecretsResponse;
    /**
     * The resource availability status: pending, active, or deleting.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'status': string;
    /**
     * The type of the resource.
     * @type {string}
     * @memberof ResourceOutputsResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequestLegacy is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestLegacyRequest
 */
export interface ResourceProvisionRequestLegacyRequest {
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestLegacyRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * The resource type
     * @type {string}
     * @memberof ResourceProvisionRequestLegacyRequest
     */
    'type': string;
}
/**
 * ResourceProvisionRequestLegacy is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestLegacyResponse
 */
export interface ResourceProvisionRequestLegacyResponse {
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestLegacyResponse
     */
    'resource'?: { [key: string]: any; };
    /**
     * The resource type
     * @type {string}
     * @memberof ResourceProvisionRequestLegacyResponse
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestRequest
 */
export interface ResourceProvisionRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestRequest
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestRequest
     */
    'type': string;
}
/**
 * ResourceProvisionRequest is the payload passed to the resource provisioner
 * @export
 * @interface ResourceProvisionRequestResponse
 */
export interface ResourceProvisionRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestResponse
     */
    'id': string;
    /**
     * (Optional) The input parameters for the resource passed from the deployment set
     * @type {{ [key: string]: any; }}
     * @memberof ResourceProvisionRequestResponse
     */
    'resource'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ResourceProvisionRequestResponse
     */
    'type': string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeRequest
 */
export interface ResourceTypeRequest {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'category'?: string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'name'?: string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeRequest
     */
    'outputs_schema'?: { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeRequest
     */
    'type'?: string;
}
/**
 * Resources Types define the technology that Applications can have dependencies on.  Each Resource Type also defines a set of input parameters (`inputs_schema`), and a set of output data (`outputs_schema`). When provisioning a resource, these are treated as inputs and outputs respectively.
 * @export
 * @interface ResourceTypeResponse
 */
export interface ResourceTypeResponse {
    /**
     * Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'category': string;
    /**
     * A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'name': string;
    /**
     * A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof ResourceTypeResponse
     */
    'outputs_schema': { [key: string]: any; };
    /**
     * Unique resource type identifier (system-wide, across all organizations).
     * @type {string}
     * @memberof ResourceTypeResponse
     */
    'type': string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoRequest
 */
export interface RuntimeInfoRequest {
    /**
     * 
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof RuntimeInfoRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoRequest
     */
    'namespace'?: string;
}
/**
 * RuntimeInfo object returned by the runtime endpoint. Represents a list post statuses grouped by modules and controllers (deployments and stateful sets).
 * @export
 * @interface RuntimeInfoResponse
 */
export interface RuntimeInfoResponse {
    /**
     * 
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof RuntimeInfoResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * 
     * @type {string}
     * @memberof RuntimeInfoResponse
     */
    'namespace': string;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetRequest
 */
export interface SetRequest {
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleRequest; }}
     * @memberof SetRequest
     */
    'modules'?: { [key: string]: ModuleRequest; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetRequest
     */
    'shared'?: { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetRequest
     */
    'version'?: number;
}
/**
 * A Deployment Set (or just \"Set\") defines all of the non-Environment specific configuration for Modules and External Resources. Each of these Modules or External Resources has a unique name.  Deployment Sets are immutable and their ID is a cryptographic hash of their content. This means that a Deployment Set can be globally identified based on its ID. It also means that referencing a Deployment Set by ID will always return the same Deployment Set.  Deployment Sets cannot be created directly, instead they are created by applying a Deployment Delta to an existing Deployment Set.  **Basic Structure**  ```  {    \"id\": <ID of the Deployment Set>,    \"modules\" : {      <ID of Module> : {        \"profile\": <Defines how the optional \"spec\" property is interpreted>        \"spec\": {          <Properties that depend on the \"profile\" property.>        }        \"externals\": {          <External Resource Name> : {            \"type\": <Resource Type>,            \"params\": {              <Properties which parametrize the resource depending on the Resource Type.>            }          }        }      }    }  } ```  For details about how the Humanitec provided profiles work, see (Deployment Set Profiles)[].
 * @export
 * @interface SetResponse
 */
export interface SetResponse {
    /**
     * The ID which is a hash of the content of the Deployment Set.
     * @type {string}
     * @memberof SetResponse
     */
    'id': string;
    /**
     * The Modules that make up the Set
     * @type {{ [key: string]: ModuleResponse; }}
     * @memberof SetResponse
     */
    'modules': { [key: string]: ModuleResponse; };
    /**
     * Resources that are shared across the set
     * @type {{ [key: string]: any; }}
     * @memberof SetResponse
     */
    'shared': { [key: string]: any; };
    /**
     * The version of the Deployment Set Schema to use. (Currently, only 0 is supported, and if omitted, version 0 is assumed.)
     * @type {number}
     * @memberof SetResponse
     */
    'version': number;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionRequest
 */
export interface TokenDefinitionRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionRequest
     */
    'type'?: string;
}
/**
 * Defines the token to be created.
 * @export
 * @interface TokenDefinitionResponse
 */
export interface TokenDefinitionResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDefinitionResponse
     */
    'type': string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoRequest
 */
export interface TokenInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoRequest
     */
    'type'?: string;
}
/**
 * Holds metadata about a token. `expires_at` is excluded if token does not expire.
 * @export
 * @interface TokenInfoResponse
 */
export interface TokenInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfoResponse
     */
    'type': string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'type'?: string;
}
/**
 * Token holds the token and its type.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'type'?: string;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionRequest
 */
export interface UpdateActionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'op'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionRequest
     */
    'path'?: string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionRequest
     */
    'value'?: any;
}
/**
 * A representation of the main object defined in JSON Patch specified in RFC 6902 from the IETF. The main differences are:  * Only `add`, `remove` and `replace` are supported  * `remove` can have have its scope of application applied in its `value`. e.g. `{\"scope\":\"delta\"}
 * @export
 * @interface UpdateActionResponse
 */
export interface UpdateActionResponse {
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'op': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateActionResponse
     */
    'path': string;
    /**
     * 
     * @type {any}
     * @memberof UpdateActionResponse
     */
    'value'?: any;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadRequest
 */
export interface UpdateArtefactVersionPayloadRequest {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadRequest
     */
    'archived': boolean | null;
}
/**
 * UpdateArtefactVersionPayload contains the `archived` field that should be set in the Artefact Version to update.
 * @export
 * @interface UpdateArtefactVersionPayloadResponse
 */
export interface UpdateArtefactVersionPayloadResponse {
    /**
     * The Value of the archived value.
     * @type {boolean}
     * @memberof UpdateArtefactVersionPayloadResponse
     */
    'archived': boolean | null;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestRequest
 */
export interface UpdateDriverRequestRequest {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestRequest
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestRequest
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof UpdateDriverRequestRequest
     */
    'is_public'?: boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestRequest
     */
    'template'?: any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof UpdateDriverRequestRequest
     */
    'url_prefix'?: string;
}
/**
 * UpdateDriverRequest describes the update driver details request.
 * @export
 * @interface UpdateDriverRequestResponse
 */
export interface UpdateDriverRequestResponse {
    /**
     * List of resources accounts types supported by the driver
     * @type {Array<string>}
     * @memberof UpdateDriverRequestResponse
     */
    'account_types': Array<string>;
    /**
     * A JSON Schema specifying the driver-specific input parameters.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateDriverRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * Defines whether this driver is accessible to all Organizations.
     * @type {boolean}
     * @memberof UpdateDriverRequestResponse
     */
    'is_public': boolean;
    /**
     * The prefix where the driver resides or, if the driver is a virtual driver, the reference to an existing driver using the `driver://` schema of the format `driver://{orgId}/{driverId}`. Only members of the organization the driver belongs to can see \'target\'.
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'target': string;
    /**
     * If the driver is a virtual driver, template defines a Go template that converts the driver inputs supplied in the resource definition into the driver inputs for the target driver.
     * @type {any}
     * @memberof UpdateDriverRequestResponse
     */
    'template': any;
    /**
     * The type of resource produced by this driver
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'type': string;
    /**
     * DEPRECATED: The prefix where the driver resides. Use \'target\' instead. Only members of the organization the driver belongs to can see \'url_prefix\'.
     * @type {string}
     * @memberof UpdateDriverRequestResponse
     */
    'url_prefix': string;
}
/**
 * UpdateEnvironmentPayload contains the `DeploymentsLocked` field that should be set in the Environment to update.
 * @export
 * @interface UpdateEnvironmentPayloadRequest
 */
export interface UpdateEnvironmentPayloadRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEnvironmentPayloadRequest
     */
    'deployments_locked'?: boolean | null;
}
/**
 * UpdateEnvironmentPayload contains the `DeploymentsLocked` field that should be set in the Environment to update.
 * @export
 * @interface UpdateEnvironmentPayloadResponse
 */
export interface UpdateEnvironmentPayloadResponse {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEnvironmentPayloadResponse
     */
    'deployments_locked': boolean | null;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestRequest
 */
export interface UpdateResourceAccountRequestRequest {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestRequest
     */
    'name'?: string;
}
/**
 * UpdateResourceAccountRequest describes the request to update the security account details.
 * @export
 * @interface UpdateResourceAccountRequestResponse
 */
export interface UpdateResourceAccountRequestResponse {
    /**
     * Credentials associated with the account.
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceAccountRequestResponse
     */
    'credentials'?: { [key: string]: any; };
    /**
     * Display name.
     * @type {string}
     * @memberof UpdateResourceAccountRequestResponse
     */
    'name': string;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestRequest
 */
export interface UpdateResourceDefinitionRequestRequest {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_account'?: string | null;
    /**
     * 
     * @type {ValuesSecretsRequest}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'driver_inputs'?: ValuesSecretsRequest;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestRequest
     */
    'name'?: string | null;
}
/**
 * UpdateResourceDefinitionRequest describes a ResourceDefinition change request.
 * @export
 * @interface UpdateResourceDefinitionRequestResponse
 */
export interface UpdateResourceDefinitionRequestResponse {
    /**
     * (Optional) Security account required by the driver.
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'driver_account': string | null;
    /**
     * 
     * @type {ValuesSecretsResponse}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'driver_inputs': ValuesSecretsResponse;
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceDefinitionRequestResponse
     */
    'name': string | null;
}
/**
 * 
 * @export
 * @interface UpdateResourceTypeRequestRequest
 */
export interface UpdateResourceTypeRequestRequest {
    /**
     * (Optional) Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'category'?: string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'inputs_schema'?: { [key: string]: any; };
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'name'?: string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestRequest
     */
    'outputs_schema'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateResourceTypeRequestResponse
 */
export interface UpdateResourceTypeRequestResponse {
    /**
     * (Optional) Category name (used to group similar resources on the UI).
     * @type {string}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'category': string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific parameters for the driver (input).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'inputs_schema': { [key: string]: any; };
    /**
     * (Optional) Resource display name
     * @type {string}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'name': string | null;
    /**
     * (Optional) A JSON Schema specifying the type-specific data passed to the deployment (output).
     * @type {{ [key: string]: any; }}
     * @memberof UpdateResourceTypeRequestResponse
     */
    'outputs_schema': { [key: string]: any; };
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteRequest
 */
export interface UserInviteRequest {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'created_at'?: string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'created_by'?: string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'expires_at'?: string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteRequest
     */
    'user_id'?: string;
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestRequest
 */
export interface UserInviteRequestRequest {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestRequest
     */
    'role': string;
}
/**
 * UserInviteRequest describes a new user invitation.
 * @export
 * @interface UserInviteRequestResponse
 */
export interface UserInviteRequestResponse {
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteRequestResponse
     */
    'email': string;
    /**
     * The role that this user would hold.
     * @type {string}
     * @memberof UserInviteRequestResponse
     */
    'role': string;
}
/**
 * UserInvite stores the invitation details.
 * @export
 * @interface UserInviteResponse
 */
export interface UserInviteResponse {
    /**
     * The timestamp this invitation was created.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_at': string;
    /**
     * The ID of the user who created this invitation.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'created_by': string;
    /**
     * The email address of the user from the profile.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'email'?: string;
    /**
     * The timestamp this invitation would expire.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'expires_at': string;
    /**
     * The User ID for this user.
     * @type {string}
     * @memberof UserInviteResponse
     */
    'user_id': string;
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedRequest
 */
export interface UserProfileExtendedRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedRequest
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedRequest
     */
    'properties'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedRequest
     */
    'roles'?: { [key: string]: string; };
}
/**
 * UserProfileExtended holds the profile information of a user including properties only accessible to the user.
 * @export
 * @interface UserProfileExtendedResponse
 */
export interface UserProfileExtendedResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileExtendedResponse
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UserProfileExtendedResponse
     */
    'properties': { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserProfileExtendedResponse
     */
    'roles': { [key: string]: string; };
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileRequest
 */
export interface UserProfileRequest {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileRequest
     */
    'id'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileRequest
     */
    'name'?: string;
}
/**
 * UserProfile holds the profile information of a user
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserProfileResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserProfileResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserProfileResponse
     */
    'id': string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserProfileResponse
     */
    'name': string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleRequest
 */
export interface UserRoleRequest {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleRequest
     */
    'role'?: string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleRequest
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleRequest
     */
    'created_at'?: string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleRequest
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleRequest
     */
    'id'?: string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleRequest
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleRequest
     */
    'name'?: string;
}
/**
 * UserRole holds the mapping of role to user for a particular object.
 * @export
 * @interface UserRoleResponse
 */
export interface UserRoleResponse {
    /**
     * The role that this user holds
     * @type {string}
     * @memberof UserRoleResponse
     */
    'role': string;
    /**
     * The user ID that hold the role
     * @type {string}
     * @memberof UserRoleResponse
     */
    'user'?: string;
    /**
     * The time the user was first registered with Humanitec
     * @type {string}
     * @memberof UserRoleResponse
     */
    'created_at': string;
    /**
     * The email address of the user from the profile
     * @type {string}
     * @memberof UserRoleResponse
     */
    'email'?: string;
    /**
     * The User ID for this user
     * @type {string}
     * @memberof UserRoleResponse
     */
    'id': string;
    /**
     * The status of an invitation (If applicable)
     * @type {string}
     * @memberof UserRoleResponse
     */
    'invite'?: string;
    /**
     * The name the user goes by
     * @type {string}
     * @memberof UserRoleResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadRequest
 */
export interface ValueCreatePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadRequest
     */
    'is_secret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadRequest
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueCreatePayloadResponse
 */
export interface ValueCreatePayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValueCreatePayloadResponse
     */
    'is_secret': boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ValueCreatePayloadResponse
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadRequest
 */
export interface ValueEditPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadRequest
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValueEditPayloadResponse
 */
export interface ValueEditPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueEditPayloadResponse
     */
    'value': string | null;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadRequest
 */
export interface ValuePatchPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadRequest
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface ValuePatchPayloadResponse
 */
export interface ValuePatchPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadResponse
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValuePatchPayloadResponse
     */
    'value': string | null;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueRequest
 */
export interface ValueRequest {
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueRequest
     */
    'description'?: string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueRequest
     */
    'is_secret'?: boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueRequest
     */
    'key'?: string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueRequest
     */
    'value'?: string;
}
/**
 * Shared Values can be used to manage variables and configuration that might vary between environments. They are also the way that secrets can be stored securely.  Shared Values are by default shared across all environments in an application. However, they can be overridden on an Environment by Environment basis.  For example: There might be 2 API keys that are used in an application. One development key used in the development and staging environments and another used for production. The development API key would be set at the Application level. The value would then be overridden at the Environment level for the production Environment.
 * @export
 * @interface ValueResponse
 */
export interface ValueResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'created_at': string;
    /**
     * A Human friendly description of what the Shared Value is.
     * @type {string}
     * @memberof ValueResponse
     */
    'description': string;
    /**
     * Specified that the Shared Value contains a secret.
     * @type {boolean}
     * @memberof ValueResponse
     */
    'is_secret': boolean;
    /**
     * The unique key by which the Shared Value can be referenced. pattern: ^[a-zA-Z0-9._-]+$.
     * @type {string}
     * @memberof ValueResponse
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof ValueResponse
     */
    'updated_at': string;
    /**
     * The value that will be stored. (Will be always empty for secrets.)
     * @type {string}
     * @memberof ValueResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface ValueSetActionPayloadRequest
 */
export interface ValueSetActionPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ValueSetActionPayloadResponse
 */
export interface ValueSetActionPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ValueSetActionPayloadResponse
     */
    'comment': string;
}
/**
 * Value Set Version can be used as a track record of Shared Value changes, restore to a previous Shared Value or purge an accidentally added Shared Value.
 * @export
 * @interface ValueSetVersionRequest
 */
export interface ValueSetVersionRequest {
    /**
     * 
     * @type {Array<JSONPatchRequest>}
     * @memberof ValueSetVersionRequest
     */
    'change'?: Array<JSONPatchRequest>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'result_of'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'source_value_set_version_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionRequest
     */
    'updated_at'?: string;
    /**
     * 
     * @type {{ [key: string]: ValueRequest; }}
     * @memberof ValueSetVersionRequest
     */
    'values'?: { [key: string]: ValueRequest; };
}
/**
 * Value Set Version can be used as a track record of Shared Value changes, restore to a previous Shared Value or purge an accidentally added Shared Value.
 * @export
 * @interface ValueSetVersionResponse
 */
export interface ValueSetVersionResponse {
    /**
     * 
     * @type {Array<JSONPatchResponse>}
     * @memberof ValueSetVersionResponse
     */
    'change': Array<JSONPatchResponse>;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'comment': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'created_by': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'result_of': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'source_value_set_version_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof ValueSetVersionResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {{ [key: string]: ValueResponse; }}
     * @memberof ValueSetVersionResponse
     */
    'values': { [key: string]: ValueResponse; };
}
/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsRequest
 */
export interface ValuesSecretsRequest {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsRequest
     */
    'values'?: { [key: string]: any; };
}
/**
 * ValuesSecrets stores data that should be passed around split by sensitivity.
 * @export
 * @interface ValuesSecretsResponse
 */
export interface ValuesSecretsResponse {
    /**
     * Secrets section of the data set. Sensitive information is stored in the Vault and replaced with the Vault paths when sent outside.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'secrets'?: { [key: string]: any; };
    /**
     * Values section of the data set. Passed around as-is.
     * @type {{ [key: string]: any; }}
     * @memberof ValuesSecretsResponse
     */
    'values'?: { [key: string]: any; };
}
/**
 * Webhook is a special type of a Job, it performs a HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookRequest
 */
export interface WebhookRequest {
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookRequest
     */
    'disabled'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'headers'?: { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookRequest
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookRequest
     */
    'payload'?: { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseRequest>}
     * @memberof WebhookRequest
     */
    'triggers'?: Array<EventBaseRequest>;
    /**
     * Thw webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookRequest
     */
    'url'?: string | null;
}
/**
 * Webhook is a special type of a Job, it performs a HTTPS request to a specified URL with specified headers.
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The timestamp of when this Job was created.
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_at'?: string;
    /**
     * The user who created this Job
     * @type {string}
     * @memberof WebhookResponse
     */
    'created_by'?: string;
    /**
     * Defines whether this job is currently disabled.
     * @type {boolean}
     * @memberof WebhookResponse
     */
    'disabled': boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'headers': { [key: string]: any; };
    /**
     * Job ID, unique within the Organization
     * @type {string}
     * @memberof WebhookResponse
     */
    'id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebhookResponse
     */
    'payload': { [key: string]: any; };
    /**
     * A list of Events by which the Job is triggered
     * @type {Array<EventBaseResponse>}
     * @memberof WebhookResponse
     */
    'triggers': Array<EventBaseResponse>;
    /**
     * Thw webhook\'s URL (without protocol, only HTTPS is supported)
     * @type {string}
     * @memberof WebhookResponse
     */
    'url': string | null;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileRequest
 */
export interface WorkloadProfileRequest {
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileRequest
     */
    'id': string;
}
/**
 * Workload Profiles provide the baseline configuration for Workloads in Applications in Humanitec. Developers can configure various features of a workload profile to suit their needs. Examples of features might be `schedules` used in Kubernetes CronJobs or `ingress` which might be used to expose Pods controlled by a Kubernetes Deployment.  Workloads in Humanitec are implemented as Helm Charts which must implement a specific schema.
 * @export
 * @interface WorkloadProfileResponse
 */
export interface WorkloadProfileResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'created_by': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'id': string;
    /**
     * The latest version of the profile
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'latest': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileResponse
     */
    'org_id': string;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionRequest
 */
export interface WorkloadProfileVersionRequest {
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionRequest
     */
    'features'?: { [key: string]: any; };
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionRequest
     */
    'notes'?: string;
}
/**
 * Each Workload Profile has one or more Versions associated with it. In order to add a version, a Workload Profile must first be created.
 * @export
 * @interface WorkloadProfileVersionResponse
 */
export interface WorkloadProfileVersionResponse {
    /**
     * Creation date
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_at': string;
    /**
     * User created the profile
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'created_by': string;
    /**
     * A map of Features. If referencing built in Humanitec features, the fully qualified feature name must be used: e.g. `humanitec/annotations`.  {  }
     * @type {{ [key: string]: any; }}
     * @memberof WorkloadProfileVersionResponse
     */
    'features': { [key: string]: any; };
    /**
     * Notes
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'notes': string;
    /**
     * Organization ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'org_id': string;
    /**
     * Workload Profile ID
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'profile_id': string;
    /**
     * Version
     * @type {string}
     * @memberof WorkloadProfileVersionResponse
     */
    'version': string;
}

/**
 * AccountTypeApi - axios parameter creator
 * @export
 */
export const AccountTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTypeApi - functional programming interface
 * @export
 */
export const AccountTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountTypeApi - factory interface
 * @export
 */
export const AccountTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: any): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountTypeApi - object-oriented interface
 * @export
 * @class AccountTypeApi
 * @extends {BaseAPI}
 */
export class AccountTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountTypeApi
     */
    public orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return AccountTypeApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActiveResourceApi - axios parameter creator
 * @export
 */
export const ActiveResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActiveResourceApi - functional programming interface
 * @export
 */
export const ActiveResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActiveResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActiveResourceApi - factory interface
 * @export
 */
export const ActiveResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActiveResourceApiFp(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActiveResourceApi - object-oriented interface
 * @export
 * @class ActiveResourceApi
 * @extends {BaseAPI}
 */
export class ActiveResourceApi extends BaseAPI {
    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} type The Resource Type.  
     * @param {string} resId The Resource ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActiveResourceApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ActiveResourceApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationRequest: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationRequest', applicationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(orgId: string, options?: any): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {string} orgId The Organization ID.  
     * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactApi - axios parameter creator
 * @export
 */
export const ArtefactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactApi - functional programming interface
 * @export
 */
export const ArtefactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactApi - factory interface
 * @export
 */
export const ArtefactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactApiFp(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: any): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtefactApi - object-oriented interface
 * @export
 * @class ArtefactApi
 * @extends {BaseAPI}
 */
export class ArtefactApi extends BaseAPI {
    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {string} orgId The organization ID.  
     * @param {string} [type] (Optional) Filter Artefacts by type.  
     * @param {string} [name] (Optional) Filter Artefacts by name.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactApi
     */
    public orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig) {
        return ArtefactApiFp(this.configuration).orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtefactVersionApi - axios parameter creator
 * @export
 */
export const ArtefactVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtefactVersionApi - functional programming interface
 * @export
 */
export const ArtefactVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtefactVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtefactVersionApi - factory interface
 * @export
 */
export const ArtefactVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtefactVersionApiFp(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: any): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtefactVersionApi - object-oriented interface
 * @export
 * @class ArtefactVersionApi
 * @extends {BaseAPI}
 */
export class ArtefactVersionApi extends BaseAPI {
    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {string} orgId The organization ID.  
     * @param {string} [name] (Optional) Filter Artefact Versions by name.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {string} orgId The organization ID.  
     * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
     * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} versionId The Version ID.  
     * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtefactVersionApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig) {
        return ArtefactVersionApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AutomationRuleApi - axios parameter creator
 * @export
 */
export const AutomationRuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutomationRuleApi - functional programming interface
 * @export
 */
export const AutomationRuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationRuleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AutomationRuleApi - factory interface
 * @export
 */
export const AutomationRuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutomationRuleApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomationRuleApi - object-oriented interface
 * @export
 * @class AutomationRuleApi
 * @extends {BaseAPI}
 */
export class AutomationRuleApi extends BaseAPI {
    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationRuleApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return AutomationRuleApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeltaApi - axios parameter creator
 * @export
 */
export const DeltaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeltaApi - functional programming interface
 * @export
 */
export const DeltaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeltaApiAxiosParamCreator(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeltaApi - factory interface
 * @export
 */
export const DeltaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeltaApiFp(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: any): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeltaApi - object-oriented interface
 * @export
 * @class DeltaApi
 * @extends {BaseAPI}
 */
export class DeltaApi extends BaseAPI {
    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Delta to update.  
     * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {boolean} [archived] If true, return archived Deltas.  
     * @param {string} [env] Only return Deltas associated with the specified Environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeltaApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return DeltaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig) {
        return DeploymentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverDefinitionApi - axios parameter creator
 * @export
 */
export const DriverDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverDefinitionApi - functional programming interface
 * @export
 */
export const DriverDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverDefinitionApi - factory interface
 * @export
 */
export const DriverDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverDefinitionApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(orgId: string, options?: any): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverDefinitionApi - object-oriented interface
 * @export
 * @class DriverDefinitionApi
 * @extends {BaseAPI}
 */
export class DriverDefinitionApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resources Driver ID to delete.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverDefinitionApi
     */
    public orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig) {
        return DriverDefinitionApiFp(this.configuration).orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} body The Deployment ID to rebase to.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig) {
        return EnvironmentApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentTypeApi - axios parameter creator
 * @export
 */
export const EnvironmentTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentTypeApi - functional programming interface
 * @export
 */
export const EnvironmentTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvironmentTypeApi - factory interface
 * @export
 */
export const EnvironmentTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentTypeApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(orgId: string, options?: any): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentTypeApi - object-oriented interface
 * @export
 * @class EnvironmentTypeApi
 * @extends {BaseAPI}
 */
export class EnvironmentTypeApi extends BaseAPI {
    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentTypeApi
     */
    public orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return EnvironmentTypeApiFp(this.configuration).orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(orgId: string, options?: any): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).orgsOrgIdEventsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id12bab2e093889169Api - axios parameter creator
 * @export
 */
export const Id12bab2e093889169ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id12bab2e093889169Api - functional programming interface
 * @export
 */
export const Id12bab2e093889169ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id12bab2e093889169ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id12bab2e093889169Api - factory interface
 * @export
 */
export const Id12bab2e093889169ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id12bab2e093889169ApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id12bab2e093889169Api - object-oriented interface
 * @export
 * @class Id12bab2e093889169Api
 * @extends {BaseAPI}
 */
export class Id12bab2e093889169Api extends BaseAPI {
    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id12bab2e093889169Api
     */
    public orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig) {
        return Id12bab2e093889169ApiFp(this.configuration).orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id1410bccc9ddf0fdApi - axios parameter creator
 * @export
 */
export const Id1410bccc9ddf0fdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id1410bccc9ddf0fdApi - functional programming interface
 * @export
 */
export const Id1410bccc9ddf0fdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id1410bccc9ddf0fdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id1410bccc9ddf0fdApi - factory interface
 * @export
 */
export const Id1410bccc9ddf0fdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id1410bccc9ddf0fdApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id1410bccc9ddf0fdApi - object-oriented interface
 * @export
 * @class Id1410bccc9ddf0fdApi
 * @extends {BaseAPI}
 */
export class Id1410bccc9ddf0fdApi extends BaseAPI {
    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resources Driver ID to delete.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id1410bccc9ddf0fdApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return Id1410bccc9ddf0fdApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id15e6d69c476aa3c8Api - axios parameter creator
 * @export
 */
export const Id15e6d69c476aa3c8ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id15e6d69c476aa3c8Api - functional programming interface
 * @export
 */
export const Id15e6d69c476aa3c8ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id15e6d69c476aa3c8ApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id15e6d69c476aa3c8Api - factory interface
 * @export
 */
export const Id15e6d69c476aa3c8ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id15e6d69c476aa3c8ApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id15e6d69c476aa3c8Api - object-oriented interface
 * @export
 * @class Id15e6d69c476aa3c8Api
 * @extends {BaseAPI}
 */
export class Id15e6d69c476aa3c8Api extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id15e6d69c476aa3c8Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return Id15e6d69c476aa3c8ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id1788e5e056d7e975Api - axios parameter creator
 * @export
 */
export const Id1788e5e056d7e975ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id1788e5e056d7e975Api - functional programming interface
 * @export
 */
export const Id1788e5e056d7e975ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id1788e5e056d7e975ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id1788e5e056d7e975Api - factory interface
 * @export
 */
export const Id1788e5e056d7e975ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id1788e5e056d7e975ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id1788e5e056d7e975Api - object-oriented interface
 * @export
 * @class Id1788e5e056d7e975Api
 * @extends {BaseAPI}
 */
export class Id1788e5e056d7e975Api extends BaseAPI {
    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id1788e5e056d7e975Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return Id1788e5e056d7e975ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id188756878370e28cApi - axios parameter creator
 * @export
 */
export const Id188756878370e28cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id188756878370e28cApi - functional programming interface
 * @export
 */
export const Id188756878370e28cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id188756878370e28cApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id188756878370e28cApi - factory interface
 * @export
 */
export const Id188756878370e28cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id188756878370e28cApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id188756878370e28cApi - object-oriented interface
 * @export
 * @class Id188756878370e28cApi
 * @extends {BaseAPI}
 */
export class Id188756878370e28cApi extends BaseAPI {
    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {string} sourceSetId ID of the Deployment Set to diff against.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id188756878370e28cApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig) {
        return Id188756878370e28cApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id18a2ff8a7cb8092Api - axios parameter creator
 * @export
 */
export const Id18a2ff8a7cb8092ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id18a2ff8a7cb8092Api - functional programming interface
 * @export
 */
export const Id18a2ff8a7cb8092ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id18a2ff8a7cb8092ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id18a2ff8a7cb8092Api - factory interface
 * @export
 */
export const Id18a2ff8a7cb8092ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id18a2ff8a7cb8092ApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id18a2ff8a7cb8092Api - object-oriented interface
 * @export
 * @class Id18a2ff8a7cb8092Api
 * @extends {BaseAPI}
 */
export class Id18a2ff8a7cb8092Api extends BaseAPI {
    /**
     * 
     * @summary Creates a new service user.
     * @param {string} orgId The Organization ID.  
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id18a2ff8a7cb8092Api
     */
    public orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return Id18a2ff8a7cb8092ApiFp(this.configuration).orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id19eac471ff71f6c3Api - axios parameter creator
 * @export
 */
export const Id19eac471ff71f6c3ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id19eac471ff71f6c3Api - functional programming interface
 * @export
 */
export const Id19eac471ff71f6c3ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id19eac471ff71f6c3ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id19eac471ff71f6c3Api - factory interface
 * @export
 */
export const Id19eac471ff71f6c3ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id19eac471ff71f6c3ApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id19eac471ff71f6c3Api - object-oriented interface
 * @export
 * @class Id19eac471ff71f6c3Api
 * @extends {BaseAPI}
 */
export class Id19eac471ff71f6c3Api extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id19eac471ff71f6c3Api
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return Id19eac471ff71f6c3ApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id22c6624fe22c6585Api - axios parameter creator
 * @export
 */
export const Id22c6624fe22c6585ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id22c6624fe22c6585Api - functional programming interface
 * @export
 */
export const Id22c6624fe22c6585ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id22c6624fe22c6585ApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id22c6624fe22c6585Api - factory interface
 * @export
 */
export const Id22c6624fe22c6585ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id22c6624fe22c6585ApiFp(configuration)
    return {
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id22c6624fe22c6585Api - object-oriented interface
 * @export
 * @class Id22c6624fe22c6585Api
 * @extends {BaseAPI}
 */
export class Id22c6624fe22c6585Api extends BaseAPI {
    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id22c6624fe22c6585Api
     */
    public orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return Id22c6624fe22c6585ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id285eb1b4df7cecd3Api - axios parameter creator
 * @export
 */
export const Id285eb1b4df7cecd3ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete: async (orgId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id285eb1b4df7cecd3Api - functional programming interface
 * @export
 */
export const Id285eb1b4df7cecd3ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id285eb1b4df7cecd3ApiAxiosParamCreator(configuration)
    return {
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id285eb1b4df7cecd3Api - factory interface
 * @export
 */
export const Id285eb1b4df7cecd3ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id285eb1b4df7cecd3ApiFp(configuration)
    return {
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id285eb1b4df7cecd3Api - object-oriented interface
 * @export
 * @class Id285eb1b4df7cecd3Api
 * @extends {BaseAPI}
 */
export class Id285eb1b4df7cecd3Api extends BaseAPI {
    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id285eb1b4df7cecd3Api
     */
    public orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig) {
        return Id285eb1b4df7cecd3ApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id2eb5ff0a1367081cApi - axios parameter creator
 * @export
 */
export const Id2eb5ff0a1367081cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id2eb5ff0a1367081cApi - functional programming interface
 * @export
 */
export const Id2eb5ff0a1367081cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id2eb5ff0a1367081cApiAxiosParamCreator(configuration)
    return {
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id2eb5ff0a1367081cApi - factory interface
 * @export
 */
export const Id2eb5ff0a1367081cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id2eb5ff0a1367081cApiFp(configuration)
    return {
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id2eb5ff0a1367081cApi - object-oriented interface
 * @export
 * @class Id2eb5ff0a1367081cApi
 * @extends {BaseAPI}
 */
export class Id2eb5ff0a1367081cApi extends BaseAPI {
    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id2eb5ff0a1367081cApi
     */
    public orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return Id2eb5ff0a1367081cApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id2ffc55fb05e58182Api - axios parameter creator
 * @export
 */
export const Id2ffc55fb05e58182ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id2ffc55fb05e58182Api - functional programming interface
 * @export
 */
export const Id2ffc55fb05e58182ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id2ffc55fb05e58182ApiAxiosParamCreator(configuration)
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id2ffc55fb05e58182Api - factory interface
 * @export
 */
export const Id2ffc55fb05e58182ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id2ffc55fb05e58182ApiFp(configuration)
    return {
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id2ffc55fb05e58182Api - object-oriented interface
 * @export
 * @class Id2ffc55fb05e58182Api
 * @extends {BaseAPI}
 */
export class Id2ffc55fb05e58182Api extends BaseAPI {
    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id2ffc55fb05e58182Api
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return Id2ffc55fb05e58182ApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3142fa80948aa9b5Api - axios parameter creator
 * @export
 */
export const Id3142fa80948aa9b5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3142fa80948aa9b5Api - functional programming interface
 * @export
 */
export const Id3142fa80948aa9b5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3142fa80948aa9b5ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3142fa80948aa9b5Api - factory interface
 * @export
 */
export const Id3142fa80948aa9b5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3142fa80948aa9b5ApiFp(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(orgId: string, options?: any): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3142fa80948aa9b5Api - object-oriented interface
 * @export
 * @class Id3142fa80948aa9b5Api
 * @extends {BaseAPI}
 */
export class Id3142fa80948aa9b5Api extends BaseAPI {
    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3142fa80948aa9b5Api
     */
    public orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig) {
        return Id3142fa80948aa9b5ApiFp(this.configuration).orgsOrgIdInvitationsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id317a73fed041c22fApi - axios parameter creator
 * @export
 */
export const Id317a73fed041c22fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id317a73fed041c22fApi - functional programming interface
 * @export
 */
export const Id317a73fed041c22fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id317a73fed041c22fApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id317a73fed041c22fApi - factory interface
 * @export
 */
export const Id317a73fed041c22fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id317a73fed041c22fApiFp(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(orgId: string, options?: any): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id317a73fed041c22fApi - object-oriented interface
 * @export
 * @class Id317a73fed041c22fApi
 * @extends {BaseAPI}
 */
export class Id317a73fed041c22fApi extends BaseAPI {
    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id317a73fed041c22fApi
     */
    public orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig) {
        return Id317a73fed041c22fApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3274560023b15f46Api - axios parameter creator
 * @export
 */
export const Id3274560023b15f46ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3274560023b15f46Api - functional programming interface
 * @export
 */
export const Id3274560023b15f46ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3274560023b15f46ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3274560023b15f46Api - factory interface
 * @export
 */
export const Id3274560023b15f46ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3274560023b15f46ApiFp(configuration)
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3274560023b15f46Api - object-oriented interface
 * @export
 * @class Id3274560023b15f46Api
 * @extends {BaseAPI}
 */
export class Id3274560023b15f46Api extends BaseAPI {
    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3274560023b15f46Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return Id3274560023b15f46ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3686df27e9ea723dApi - axios parameter creator
 * @export
 */
export const Id3686df27e9ea723dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3686df27e9ea723dApi - functional programming interface
 * @export
 */
export const Id3686df27e9ea723dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3686df27e9ea723dApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3686df27e9ea723dApi - factory interface
 * @export
 */
export const Id3686df27e9ea723dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3686df27e9ea723dApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3686df27e9ea723dApi - object-oriented interface
 * @export
 * @class Id3686df27e9ea723dApi
 * @extends {BaseAPI}
 */
export class Id3686df27e9ea723dApi extends BaseAPI {
    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3686df27e9ea723dApi
     */
    public currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return Id3686df27e9ea723dApiFp(this.configuration).currentUserPatch(userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3821908301ec4a35Api - axios parameter creator
 * @export
 */
export const Id3821908301ec4a35ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3821908301ec4a35Api - functional programming interface
 * @export
 */
export const Id3821908301ec4a35ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3821908301ec4a35ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3821908301ec4a35Api - factory interface
 * @export
 */
export const Id3821908301ec4a35ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3821908301ec4a35ApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3821908301ec4a35Api - object-oriented interface
 * @export
 * @class Id3821908301ec4a35Api
 * @extends {BaseAPI}
 */
export class Id3821908301ec4a35Api extends BaseAPI {
    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3821908301ec4a35Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id3821908301ec4a35ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3a2fa8278ffbfb0cApi - axios parameter creator
 * @export
 */
export const Id3a2fa8278ffbfb0cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3a2fa8278ffbfb0cApi - functional programming interface
 * @export
 */
export const Id3a2fa8278ffbfb0cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3a2fa8278ffbfb0cApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3a2fa8278ffbfb0cApi - factory interface
 * @export
 */
export const Id3a2fa8278ffbfb0cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3a2fa8278ffbfb0cApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3a2fa8278ffbfb0cApi - object-oriented interface
 * @export
 * @class Id3a2fa8278ffbfb0cApi
 * @extends {BaseAPI}
 */
export class Id3a2fa8278ffbfb0cApi extends BaseAPI {
    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3a2fa8278ffbfb0cApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return Id3a2fa8278ffbfb0cApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3dd97c9b90f364edApi - axios parameter creator
 * @export
 */
export const Id3dd97c9b90f364edApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3dd97c9b90f364edApi - functional programming interface
 * @export
 */
export const Id3dd97c9b90f364edApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3dd97c9b90f364edApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3dd97c9b90f364edApi - factory interface
 * @export
 */
export const Id3dd97c9b90f364edApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3dd97c9b90f364edApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3dd97c9b90f364edApi - object-oriented interface
 * @export
 * @class Id3dd97c9b90f364edApi
 * @extends {BaseAPI}
 */
export class Id3dd97c9b90f364edApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3dd97c9b90f364edApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return Id3dd97c9b90f364edApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id3e4c54b794c1b6a4Api - axios parameter creator
 * @export
 */
export const Id3e4c54b794c1b6a4ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id3e4c54b794c1b6a4Api - functional programming interface
 * @export
 */
export const Id3e4c54b794c1b6a4ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id3e4c54b794c1b6a4ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id3e4c54b794c1b6a4Api - factory interface
 * @export
 */
export const Id3e4c54b794c1b6a4ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id3e4c54b794c1b6a4ApiFp(configuration)
    return {
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id3e4c54b794c1b6a4Api - object-oriented interface
 * @export
 * @class Id3e4c54b794c1b6a4Api
 * @extends {BaseAPI}
 */
export class Id3e4c54b794c1b6a4Api extends BaseAPI {
    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id3e4c54b794c1b6a4Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return Id3e4c54b794c1b6a4ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4168cd16f10fbf80Api - axios parameter creator
 * @export
 */
export const Id4168cd16f10fbf80ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4168cd16f10fbf80Api - functional programming interface
 * @export
 */
export const Id4168cd16f10fbf80ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4168cd16f10fbf80ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4168cd16f10fbf80Api - factory interface
 * @export
 */
export const Id4168cd16f10fbf80ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4168cd16f10fbf80ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4168cd16f10fbf80Api - object-oriented interface
 * @export
 * @class Id4168cd16f10fbf80Api
 * @extends {BaseAPI}
 */
export class Id4168cd16f10fbf80Api extends BaseAPI {
    /**
     * 
     * @summary List Users with roles in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4168cd16f10fbf80Api
     */
    public orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return Id4168cd16f10fbf80ApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id416f0bca6f852cccApi - axios parameter creator
 * @export
 */
export const Id416f0bca6f852cccApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id416f0bca6f852cccApi - functional programming interface
 * @export
 */
export const Id416f0bca6f852cccApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id416f0bca6f852cccApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id416f0bca6f852cccApi - factory interface
 * @export
 */
export const Id416f0bca6f852cccApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id416f0bca6f852cccApiFp(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(orgId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id416f0bca6f852cccApi - object-oriented interface
 * @export
 * @class Id416f0bca6f852cccApi
 * @extends {BaseAPI}
 */
export class Id416f0bca6f852cccApi extends BaseAPI {
    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id416f0bca6f852cccApi
     */
    public orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig) {
        return Id416f0bca6f852cccApiFp(this.configuration).orgsOrgIdUsersGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id419ccb3e966c7763Api - axios parameter creator
 * @export
 */
export const Id419ccb3e966c7763ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id419ccb3e966c7763Api - functional programming interface
 * @export
 */
export const Id419ccb3e966c7763ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id419ccb3e966c7763ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id419ccb3e966c7763Api - factory interface
 * @export
 */
export const Id419ccb3e966c7763ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id419ccb3e966c7763ApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id419ccb3e966c7763Api - object-oriented interface
 * @export
 * @class Id419ccb3e966c7763Api
 * @extends {BaseAPI}
 */
export class Id419ccb3e966c7763Api extends BaseAPI {
    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id419ccb3e966c7763Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return Id419ccb3e966c7763ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id454d8ec72ac03f4fApi - axios parameter creator
 * @export
 */
export const Id454d8ec72ac03f4fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id454d8ec72ac03f4fApi - functional programming interface
 * @export
 */
export const Id454d8ec72ac03f4fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id454d8ec72ac03f4fApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id454d8ec72ac03f4fApi - factory interface
 * @export
 */
export const Id454d8ec72ac03f4fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id454d8ec72ac03f4fApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id454d8ec72ac03f4fApi - object-oriented interface
 * @export
 * @class Id454d8ec72ac03f4fApi
 * @extends {BaseAPI}
 */
export class Id454d8ec72ac03f4fApi extends BaseAPI {
    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {UserRoleRequest} userRoleRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id454d8ec72ac03f4fApi
     */
    public orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig) {
        return Id454d8ec72ac03f4fApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4583b24d5271efa7Api - axios parameter creator
 * @export
 */
export const Id4583b24d5271efa7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4583b24d5271efa7Api - functional programming interface
 * @export
 */
export const Id4583b24d5271efa7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4583b24d5271efa7ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4583b24d5271efa7Api - factory interface
 * @export
 */
export const Id4583b24d5271efa7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4583b24d5271efa7ApiFp(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4583b24d5271efa7Api - object-oriented interface
 * @export
 * @class Id4583b24d5271efa7Api
 * @extends {BaseAPI}
 */
export class Id4583b24d5271efa7Api extends BaseAPI {
    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4583b24d5271efa7Api
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return Id4583b24d5271efa7ApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id458edde8fb58f308Api - axios parameter creator
 * @export
 */
export const Id458edde8fb58f308ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id458edde8fb58f308Api - functional programming interface
 * @export
 */
export const Id458edde8fb58f308ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id458edde8fb58f308ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id458edde8fb58f308Api - factory interface
 * @export
 */
export const Id458edde8fb58f308ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id458edde8fb58f308ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id458edde8fb58f308Api - object-oriented interface
 * @export
 * @class Id458edde8fb58f308Api
 * @extends {BaseAPI}
 */
export class Id458edde8fb58f308Api extends BaseAPI {
    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id458edde8fb58f308Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id458edde8fb58f308ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4809ac5071cbe936Api - axios parameter creator
 * @export
 */
export const Id4809ac5071cbe936ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4809ac5071cbe936Api - functional programming interface
 * @export
 */
export const Id4809ac5071cbe936ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4809ac5071cbe936ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4809ac5071cbe936Api - factory interface
 * @export
 */
export const Id4809ac5071cbe936ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4809ac5071cbe936ApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4809ac5071cbe936Api - object-oriented interface
 * @export
 * @class Id4809ac5071cbe936Api
 * @extends {BaseAPI}
 */
export class Id4809ac5071cbe936Api extends BaseAPI {
    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {string} version The Version.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4809ac5071cbe936Api
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig) {
        return Id4809ac5071cbe936ApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4949e99ea5ffc379Api - axios parameter creator
 * @export
 */
export const Id4949e99ea5ffc379ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4949e99ea5ffc379Api - functional programming interface
 * @export
 */
export const Id4949e99ea5ffc379ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4949e99ea5ffc379ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4949e99ea5ffc379Api - factory interface
 * @export
 */
export const Id4949e99ea5ffc379ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4949e99ea5ffc379ApiFp(configuration)
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4949e99ea5ffc379Api - object-oriented interface
 * @export
 * @class Id4949e99ea5ffc379Api
 * @extends {BaseAPI}
 */
export class Id4949e99ea5ffc379Api extends BaseAPI {
    /**
     * 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4949e99ea5ffc379Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return Id4949e99ea5ffc379ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id49f0275ef133c098Api - axios parameter creator
 * @export
 */
export const Id49f0275ef133c098ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id49f0275ef133c098Api - functional programming interface
 * @export
 */
export const Id49f0275ef133c098ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id49f0275ef133c098ApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id49f0275ef133c098Api - factory interface
 * @export
 */
export const Id49f0275ef133c098ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id49f0275ef133c098ApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id49f0275ef133c098Api - object-oriented interface
 * @export
 * @class Id49f0275ef133c098Api
 * @extends {BaseAPI}
 */
export class Id49f0275ef133c098Api extends BaseAPI {
    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id49f0275ef133c098Api
     */
    public orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig) {
        return Id49f0275ef133c098ApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4a0527f79ce3a2e7Api - axios parameter creator
 * @export
 */
export const Id4a0527f79ce3a2e7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4a0527f79ce3a2e7Api - functional programming interface
 * @export
 */
export const Id4a0527f79ce3a2e7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4a0527f79ce3a2e7ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4a0527f79ce3a2e7Api - factory interface
 * @export
 */
export const Id4a0527f79ce3a2e7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4a0527f79ce3a2e7ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(orgId: string, options?: any): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4a0527f79ce3a2e7Api - object-oriented interface
 * @export
 * @class Id4a0527f79ce3a2e7Api
 * @extends {BaseAPI}
 */
export class Id4a0527f79ce3a2e7Api extends BaseAPI {
    /**
     * 
     * @summary List Resource Drivers.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4a0527f79ce3a2e7Api
     */
    public orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig) {
        return Id4a0527f79ce3a2e7ApiFp(this.configuration).orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id4ec56221444edf96Api - axios parameter creator
 * @export
 */
export const Id4ec56221444edf96ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id4ec56221444edf96Api - functional programming interface
 * @export
 */
export const Id4ec56221444edf96ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id4ec56221444edf96ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id4ec56221444edf96Api - factory interface
 * @export
 */
export const Id4ec56221444edf96ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id4ec56221444edf96ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id4ec56221444edf96Api - object-oriented interface
 * @export
 * @class Id4ec56221444edf96Api
 * @extends {BaseAPI}
 */
export class Id4ec56221444edf96Api extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id4ec56221444edf96Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id4ec56221444edf96ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id54aa8cf5a4a9a3a1Api - axios parameter creator
 * @export
 */
export const Id54aa8cf5a4a9a3a1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id54aa8cf5a4a9a3a1Api - functional programming interface
 * @export
 */
export const Id54aa8cf5a4a9a3a1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id54aa8cf5a4a9a3a1ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id54aa8cf5a4a9a3a1Api - factory interface
 * @export
 */
export const Id54aa8cf5a4a9a3a1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id54aa8cf5a4a9a3a1ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id54aa8cf5a4a9a3a1Api - object-oriented interface
 * @export
 * @class Id54aa8cf5a4a9a3a1Api
 * @extends {BaseAPI}
 */
export class Id54aa8cf5a4a9a3a1Api extends BaseAPI {
    /**
     * 
     * @summary List Webhooks
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id54aa8cf5a4a9a3a1Api
     */
    public orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return Id54aa8cf5a4a9a3a1ApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id555c96281c1d2504Api - axios parameter creator
 * @export
 */
export const Id555c96281c1d2504ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id555c96281c1d2504Api - functional programming interface
 * @export
 */
export const Id555c96281c1d2504ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id555c96281c1d2504ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id555c96281c1d2504Api - factory interface
 * @export
 */
export const Id555c96281c1d2504ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id555c96281c1d2504ApiFp(configuration)
    return {
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id555c96281c1d2504Api - object-oriented interface
 * @export
 * @class Id555c96281c1d2504Api
 * @extends {BaseAPI}
 */
export class Id555c96281c1d2504Api extends BaseAPI {
    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id555c96281c1d2504Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return Id555c96281c1d2504ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id58622d721631f57cApi - axios parameter creator
 * @export
 */
export const Id58622d721631f57cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id58622d721631f57cApi - functional programming interface
 * @export
 */
export const Id58622d721631f57cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id58622d721631f57cApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id58622d721631f57cApi - factory interface
 * @export
 */
export const Id58622d721631f57cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id58622d721631f57cApiFp(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id58622d721631f57cApi - object-oriented interface
 * @export
 * @class Id58622d721631f57cApi
 * @extends {BaseAPI}
 */
export class Id58622d721631f57cApi extends BaseAPI {
    /**
     * 
     * @summary DEPRECATED
     * @param {string} tokenId The token ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id58622d721631f57cApi
     */
    public tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig) {
        return Id58622d721631f57cApiFp(this.configuration).tokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id599c18437cdcf891Api - axios parameter creator
 * @export
 */
export const Id599c18437cdcf891ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id599c18437cdcf891Api - functional programming interface
 * @export
 */
export const Id599c18437cdcf891ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id599c18437cdcf891ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id599c18437cdcf891Api - factory interface
 * @export
 */
export const Id599c18437cdcf891ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id599c18437cdcf891ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id599c18437cdcf891Api - object-oriented interface
 * @export
 * @class Id599c18437cdcf891Api
 * @extends {BaseAPI}
 */
export class Id599c18437cdcf891Api extends BaseAPI {
    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id599c18437cdcf891Api
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig) {
        return Id599c18437cdcf891ApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id59de344b5fdd324bApi - axios parameter creator
 * @export
 */
export const Id59de344b5fdd324bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id59de344b5fdd324bApi - functional programming interface
 * @export
 */
export const Id59de344b5fdd324bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id59de344b5fdd324bApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id59de344b5fdd324bApi - factory interface
 * @export
 */
export const Id59de344b5fdd324bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id59de344b5fdd324bApiFp(configuration)
    return {
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: any): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id59de344b5fdd324bApi - object-oriented interface
 * @export
 * @class Id59de344b5fdd324bApi
 * @extends {BaseAPI}
 */
export class Id59de344b5fdd324bApi extends BaseAPI {
    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The Workload profile qualified ID.  
     * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id59de344b5fdd324bApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig) {
        return Id59de344b5fdd324bApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id5c591c873982d08dApi - axios parameter creator
 * @export
 */
export const Id5c591c873982d08dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id5c591c873982d08dApi - functional programming interface
 * @export
 */
export const Id5c591c873982d08dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id5c591c873982d08dApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id5c591c873982d08dApi - factory interface
 * @export
 */
export const Id5c591c873982d08dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id5c591c873982d08dApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id5c591c873982d08dApi - object-oriented interface
 * @export
 * @class Id5c591c873982d08dApi
 * @extends {BaseAPI}
 */
export class Id5c591c873982d08dApi extends BaseAPI {
    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id5c591c873982d08dApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return Id5c591c873982d08dApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id629a398140849841Api - axios parameter creator
 * @export
 */
export const Id629a398140849841ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id629a398140849841Api - functional programming interface
 * @export
 */
export const Id629a398140849841ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id629a398140849841ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id629a398140849841Api - factory interface
 * @export
 */
export const Id629a398140849841ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id629a398140849841ApiFp(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id629a398140849841Api - object-oriented interface
 * @export
 * @class Id629a398140849841Api
 * @extends {BaseAPI}
 */
export class Id629a398140849841Api extends BaseAPI {
    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id629a398140849841Api
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return Id629a398140849841ApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id635f872ac72a46b7Api - axios parameter creator
 * @export
 */
export const Id635f872ac72a46b7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id635f872ac72a46b7Api - functional programming interface
 * @export
 */
export const Id635f872ac72a46b7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id635f872ac72a46b7ApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id635f872ac72a46b7Api - factory interface
 * @export
 */
export const Id635f872ac72a46b7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id635f872ac72a46b7ApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: any): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id635f872ac72a46b7Api - object-oriented interface
 * @export
 * @class Id635f872ac72a46b7Api
 * @extends {BaseAPI}
 */
export class Id635f872ac72a46b7Api extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id635f872ac72a46b7Api
     */
    public orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return Id635f872ac72a46b7ApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id6399c8aea9c4da36Api - axios parameter creator
 * @export
 */
export const Id6399c8aea9c4da36ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id6399c8aea9c4da36Api - functional programming interface
 * @export
 */
export const Id6399c8aea9c4da36ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id6399c8aea9c4da36ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id6399c8aea9c4da36Api - factory interface
 * @export
 */
export const Id6399c8aea9c4da36ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id6399c8aea9c4da36ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id6399c8aea9c4da36Api - object-oriented interface
 * @export
 * @class Id6399c8aea9c4da36Api
 * @extends {BaseAPI}
 */
export class Id6399c8aea9c4da36Api extends BaseAPI {
    /**
     * 
     * @summary Get a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id6399c8aea9c4da36Api
     */
    public orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig) {
        return Id6399c8aea9c4da36ApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id6480da2a2cbc873dApi - axios parameter creator
 * @export
 */
export const Id6480da2a2cbc873dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id6480da2a2cbc873dApi - functional programming interface
 * @export
 */
export const Id6480da2a2cbc873dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id6480da2a2cbc873dApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id6480da2a2cbc873dApi - factory interface
 * @export
 */
export const Id6480da2a2cbc873dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id6480da2a2cbc873dApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id6480da2a2cbc873dApi - object-oriented interface
 * @export
 * @class Id6480da2a2cbc873dApi
 * @extends {BaseAPI}
 */
export class Id6480da2a2cbc873dApi extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id6480da2a2cbc873dApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return Id6480da2a2cbc873dApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id64e5e7181118ccd2Api - axios parameter creator
 * @export
 */
export const Id64e5e7181118ccd2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id64e5e7181118ccd2Api - functional programming interface
 * @export
 */
export const Id64e5e7181118ccd2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id64e5e7181118ccd2ApiAxiosParamCreator(configuration)
    return {
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id64e5e7181118ccd2Api - factory interface
 * @export
 */
export const Id64e5e7181118ccd2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id64e5e7181118ccd2ApiFp(configuration)
    return {
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id64e5e7181118ccd2Api - object-oriented interface
 * @export
 * @class Id64e5e7181118ccd2Api
 * @extends {BaseAPI}
 */
export class Id64e5e7181118ccd2Api extends BaseAPI {
    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id64e5e7181118ccd2Api
     */
    public orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return Id64e5e7181118ccd2ApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id67c480e520050c7cApi - axios parameter creator
 * @export
 */
export const Id67c480e520050c7cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id67c480e520050c7cApi - functional programming interface
 * @export
 */
export const Id67c480e520050c7cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id67c480e520050c7cApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id67c480e520050c7cApi - factory interface
 * @export
 */
export const Id67c480e520050c7cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id67c480e520050c7cApiFp(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id67c480e520050c7cApi - object-oriented interface
 * @export
 * @class Id67c480e520050c7cApi
 * @extends {BaseAPI}
 */
export class Id67c480e520050c7cApi extends BaseAPI {
    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id67c480e520050c7cApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return Id67c480e520050c7cApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id69a7b420d845fdb7Api - axios parameter creator
 * @export
 */
export const Id69a7b420d845fdb7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id69a7b420d845fdb7Api - functional programming interface
 * @export
 */
export const Id69a7b420d845fdb7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id69a7b420d845fdb7ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id69a7b420d845fdb7Api - factory interface
 * @export
 */
export const Id69a7b420d845fdb7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id69a7b420d845fdb7ApiFp(configuration)
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id69a7b420d845fdb7Api - object-oriented interface
 * @export
 * @class Id69a7b420d845fdb7Api
 * @extends {BaseAPI}
 */
export class Id69a7b420d845fdb7Api extends BaseAPI {
    /**
     * 
     * @summary Restore a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id69a7b420d845fdb7Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return Id69a7b420d845fdb7ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id6dbdf1d38961e24aApi - axios parameter creator
 * @export
 */
export const Id6dbdf1d38961e24aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id6dbdf1d38961e24aApi - functional programming interface
 * @export
 */
export const Id6dbdf1d38961e24aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id6dbdf1d38961e24aApiAxiosParamCreator(configuration)
    return {
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id6dbdf1d38961e24aApi - factory interface
 * @export
 */
export const Id6dbdf1d38961e24aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id6dbdf1d38961e24aApiFp(configuration)
    return {
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id6dbdf1d38961e24aApi - object-oriented interface
 * @export
 * @class Id6dbdf1d38961e24aApi
 * @extends {BaseAPI}
 */
export class Id6dbdf1d38961e24aApi extends BaseAPI {
    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id6dbdf1d38961e24aApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return Id6dbdf1d38961e24aApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id6f1473952f969428Api - axios parameter creator
 * @export
 */
export const Id6f1473952f969428ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id6f1473952f969428Api - functional programming interface
 * @export
 */
export const Id6f1473952f969428ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id6f1473952f969428ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id6f1473952f969428Api - factory interface
 * @export
 */
export const Id6f1473952f969428ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id6f1473952f969428ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: any): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id6f1473952f969428Api - object-oriented interface
 * @export
 * @class Id6f1473952f969428Api
 * @extends {BaseAPI}
 */
export class Id6f1473952f969428Api extends BaseAPI {
    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id6f1473952f969428Api
     */
    public orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return Id6f1473952f969428ApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id715b52f18d5b240aApi - axios parameter creator
 * @export
 */
export const Id715b52f18d5b240aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id715b52f18d5b240aApi - functional programming interface
 * @export
 */
export const Id715b52f18d5b240aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id715b52f18d5b240aApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id715b52f18d5b240aApi - factory interface
 * @export
 */
export const Id715b52f18d5b240aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id715b52f18d5b240aApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(orgId: string, options?: any): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id715b52f18d5b240aApi - object-oriented interface
 * @export
 * @class Id715b52f18d5b240aApi
 * @extends {BaseAPI}
 */
export class Id715b52f18d5b240aApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {string} orgId The organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id715b52f18d5b240aApi
     */
    public orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig) {
        return Id715b52f18d5b240aApiFp(this.configuration).orgsOrgIdImagesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id71d4188b68b1adaeApi - axios parameter creator
 * @export
 */
export const Id71d4188b68b1adaeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id71d4188b68b1adaeApi - functional programming interface
 * @export
 */
export const Id71d4188b68b1adaeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id71d4188b68b1adaeApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id71d4188b68b1adaeApi - factory interface
 * @export
 */
export const Id71d4188b68b1adaeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id71d4188b68b1adaeApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id71d4188b68b1adaeApi - object-oriented interface
 * @export
 * @class Id71d4188b68b1adaeApi
 * @extends {BaseAPI}
 */
export class Id71d4188b68b1adaeApi extends BaseAPI {
    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id71d4188b68b1adaeApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id71d4188b68b1adaeApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id72ce6ea9bff52efApi - axios parameter creator
 * @export
 */
export const Id72ce6ea9bff52efApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id72ce6ea9bff52efApi - functional programming interface
 * @export
 */
export const Id72ce6ea9bff52efApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id72ce6ea9bff52efApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id72ce6ea9bff52efApi - factory interface
 * @export
 */
export const Id72ce6ea9bff52efApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id72ce6ea9bff52efApiFp(configuration)
    return {
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: any): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id72ce6ea9bff52efApi - object-oriented interface
 * @export
 * @class Id72ce6ea9bff52efApi
 * @extends {BaseAPI}
 */
export class Id72ce6ea9bff52efApi extends BaseAPI {
    /**
     * 
     * @summary List Deltas in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {boolean} [archived] If true, return archived Deltas.  
     * @param {string} [env] Only return Deltas associated with the specified Environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id72ce6ea9bff52efApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig) {
        return Id72ce6ea9bff52efApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id766dc592556a9cdeApi - axios parameter creator
 * @export
 */
export const Id766dc592556a9cdeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id766dc592556a9cdeApi - functional programming interface
 * @export
 */
export const Id766dc592556a9cdeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id766dc592556a9cdeApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id766dc592556a9cdeApi - factory interface
 * @export
 */
export const Id766dc592556a9cdeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id766dc592556a9cdeApiFp(configuration)
    return {
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: any): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id766dc592556a9cdeApi - object-oriented interface
 * @export
 * @class Id766dc592556a9cdeApi
 * @extends {BaseAPI}
 */
export class Id766dc592556a9cdeApi extends BaseAPI {
    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {string} orgId The organization ID.  
     * @param {string} [type] (Optional) Filter Artefacts by type.  
     * @param {string} [name] (Optional) Filter Artefacts by name.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id766dc592556a9cdeApi
     */
    public orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig) {
        return Id766dc592556a9cdeApiFp(this.configuration).orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id7708aeaebb457a7cApi - axios parameter creator
 * @export
 */
export const Id7708aeaebb457a7cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id7708aeaebb457a7cApi - functional programming interface
 * @export
 */
export const Id7708aeaebb457a7cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id7708aeaebb457a7cApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id7708aeaebb457a7cApi - factory interface
 * @export
 */
export const Id7708aeaebb457a7cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id7708aeaebb457a7cApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id7708aeaebb457a7cApi - object-oriented interface
 * @export
 * @class Id7708aeaebb457a7cApi
 * @extends {BaseAPI}
 */
export class Id7708aeaebb457a7cApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id7708aeaebb457a7cApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return Id7708aeaebb457a7cApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id7d0b02819ea91e5eApi - axios parameter creator
 * @export
 */
export const Id7d0b02819ea91e5eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id7d0b02819ea91e5eApi - functional programming interface
 * @export
 */
export const Id7d0b02819ea91e5eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id7d0b02819ea91e5eApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id7d0b02819ea91e5eApi - factory interface
 * @export
 */
export const Id7d0b02819ea91e5eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id7d0b02819ea91e5eApiFp(configuration)
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id7d0b02819ea91e5eApi - object-oriented interface
 * @export
 * @class Id7d0b02819ea91e5eApi
 * @extends {BaseAPI}
 */
export class Id7d0b02819ea91e5eApi extends BaseAPI {
    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id7d0b02819ea91e5eApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig) {
        return Id7d0b02819ea91e5eApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id7eb043c27458169aApi - axios parameter creator
 * @export
 */
export const Id7eb043c27458169aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id7eb043c27458169aApi - functional programming interface
 * @export
 */
export const Id7eb043c27458169aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id7eb043c27458169aApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id7eb043c27458169aApi - factory interface
 * @export
 */
export const Id7eb043c27458169aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id7eb043c27458169aApiFp(configuration)
    return {
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id7eb043c27458169aApi - object-oriented interface
 * @export
 * @class Id7eb043c27458169aApi
 * @extends {BaseAPI}
 */
export class Id7eb043c27458169aApi extends BaseAPI {
    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id7eb043c27458169aApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig) {
        return Id7eb043c27458169aApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id7f5eb45f5b3c4a39Api - axios parameter creator
 * @export
 */
export const Id7f5eb45f5b3c4a39ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id7f5eb45f5b3c4a39Api - functional programming interface
 * @export
 */
export const Id7f5eb45f5b3c4a39ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id7f5eb45f5b3c4a39ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id7f5eb45f5b3c4a39Api - factory interface
 * @export
 */
export const Id7f5eb45f5b3c4a39ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id7f5eb45f5b3c4a39ApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id7f5eb45f5b3c4a39Api - object-oriented interface
 * @export
 * @class Id7f5eb45f5b3c4a39Api
 * @extends {BaseAPI}
 */
export class Id7f5eb45f5b3c4a39Api extends BaseAPI {
    /**
     * 
     * @summary Delete a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id7f5eb45f5b3c4a39Api
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return Id7f5eb45f5b3c4a39ApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id88d4e89419ae0b79Api - axios parameter creator
 * @export
 */
export const Id88d4e89419ae0b79ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id88d4e89419ae0b79Api - functional programming interface
 * @export
 */
export const Id88d4e89419ae0b79ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id88d4e89419ae0b79ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id88d4e89419ae0b79Api - factory interface
 * @export
 */
export const Id88d4e89419ae0b79ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id88d4e89419ae0b79ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id88d4e89419ae0b79Api - object-oriented interface
 * @export
 * @class Id88d4e89419ae0b79Api
 * @extends {BaseAPI}
 */
export class Id88d4e89419ae0b79Api extends BaseAPI {
    /**
     * 
     * @summary Get a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id88d4e89419ae0b79Api
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig) {
        return Id88d4e89419ae0b79ApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id8b11ba4e6e8007a5Api - axios parameter creator
 * @export
 */
export const Id8b11ba4e6e8007a5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id8b11ba4e6e8007a5Api - functional programming interface
 * @export
 */
export const Id8b11ba4e6e8007a5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id8b11ba4e6e8007a5ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id8b11ba4e6e8007a5Api - factory interface
 * @export
 */
export const Id8b11ba4e6e8007a5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id8b11ba4e6e8007a5ApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id8b11ba4e6e8007a5Api - object-oriented interface
 * @export
 * @class Id8b11ba4e6e8007a5Api
 * @extends {BaseAPI}
 */
export class Id8b11ba4e6e8007a5Api extends BaseAPI {
    /**
     * 
     * @summary Delete Active Resources.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} type The Resource Type.  
     * @param {string} resId The Resource ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id8b11ba4e6e8007a5Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig) {
        return Id8b11ba4e6e8007a5ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id8b8113b67a78bc3fApi - axios parameter creator
 * @export
 */
export const Id8b8113b67a78bc3fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id8b8113b67a78bc3fApi - functional programming interface
 * @export
 */
export const Id8b8113b67a78bc3fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id8b8113b67a78bc3fApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id8b8113b67a78bc3fApi - factory interface
 * @export
 */
export const Id8b8113b67a78bc3fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id8b8113b67a78bc3fApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(orgId: string, options?: any): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id8b8113b67a78bc3fApi - object-oriented interface
 * @export
 * @class Id8b8113b67a78bc3fApi
 * @extends {BaseAPI}
 */
export class Id8b8113b67a78bc3fApi extends BaseAPI {
    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id8b8113b67a78bc3fApi
     */
    public orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig) {
        return Id8b8113b67a78bc3fApiFp(this.configuration).orgsOrgIdRegistriesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id8cf8558b295991a6Api - axios parameter creator
 * @export
 */
export const Id8cf8558b295991a6ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id8cf8558b295991a6Api - functional programming interface
 * @export
 */
export const Id8cf8558b295991a6ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id8cf8558b295991a6ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id8cf8558b295991a6Api - factory interface
 * @export
 */
export const Id8cf8558b295991a6ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id8cf8558b295991a6ApiFp(configuration)
    return {
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: any): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id8cf8558b295991a6Api - object-oriented interface
 * @export
 * @class Id8cf8558b295991a6Api
 * @extends {BaseAPI}
 */
export class Id8cf8558b295991a6Api extends BaseAPI {
    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} versionId The Version ID.  
     * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id8cf8558b295991a6Api
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig) {
        return Id8cf8558b295991a6ApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id8d90ebaaab97660dApi - axios parameter creator
 * @export
 */
export const Id8d90ebaaab97660dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id8d90ebaaab97660dApi - functional programming interface
 * @export
 */
export const Id8d90ebaaab97660dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id8d90ebaaab97660dApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id8d90ebaaab97660dApi - factory interface
 * @export
 */
export const Id8d90ebaaab97660dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id8d90ebaaab97660dApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id8d90ebaaab97660dApi - object-oriented interface
 * @export
 * @class Id8d90ebaaab97660dApi
 * @extends {BaseAPI}
 */
export class Id8d90ebaaab97660dApi extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id8d90ebaaab97660dApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id8d90ebaaab97660dApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id909046ec3b701823Api - axios parameter creator
 * @export
 */
export const Id909046ec3b701823ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id909046ec3b701823Api - functional programming interface
 * @export
 */
export const Id909046ec3b701823ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id909046ec3b701823ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id909046ec3b701823Api - factory interface
 * @export
 */
export const Id909046ec3b701823ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id909046ec3b701823ApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id909046ec3b701823Api - object-oriented interface
 * @export
 * @class Id909046ec3b701823Api
 * @extends {BaseAPI}
 */
export class Id909046ec3b701823Api extends BaseAPI {
    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id909046ec3b701823Api
     */
    public orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return Id909046ec3b701823ApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id91a74844aa8343dbApi - axios parameter creator
 * @export
 */
export const Id91a74844aa8343dbApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id91a74844aa8343dbApi - functional programming interface
 * @export
 */
export const Id91a74844aa8343dbApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id91a74844aa8343dbApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id91a74844aa8343dbApi - factory interface
 * @export
 */
export const Id91a74844aa8343dbApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id91a74844aa8343dbApiFp(configuration)
    return {
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id91a74844aa8343dbApi - object-oriented interface
 * @export
 * @class Id91a74844aa8343dbApi
 * @extends {BaseAPI}
 */
export class Id91a74844aa8343dbApi extends BaseAPI {
    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id91a74844aa8343dbApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig) {
        return Id91a74844aa8343dbApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id923c8490bb0decdaApi - axios parameter creator
 * @export
 */
export const Id923c8490bb0decdaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id923c8490bb0decdaApi - functional programming interface
 * @export
 */
export const Id923c8490bb0decdaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id923c8490bb0decdaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id923c8490bb0decdaApi - factory interface
 * @export
 */
export const Id923c8490bb0decdaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id923c8490bb0decdaApiFp(configuration)
    return {
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id923c8490bb0decdaApi - object-oriented interface
 * @export
 * @class Id923c8490bb0decdaApi
 * @extends {BaseAPI}
 */
export class Id923c8490bb0decdaApi extends BaseAPI {
    /**
     * 
     * @summary Update an existing Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Delta to update.  
     * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id923c8490bb0decdaApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig) {
        return Id923c8490bb0decdaApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id93a00866ac06078bApi - axios parameter creator
 * @export
 */
export const Id93a00866ac06078bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id93a00866ac06078bApi - functional programming interface
 * @export
 */
export const Id93a00866ac06078bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id93a00866ac06078bApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id93a00866ac06078bApi - factory interface
 * @export
 */
export const Id93a00866ac06078bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id93a00866ac06078bApiFp(configuration)
    return {
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id93a00866ac06078bApi - object-oriented interface
 * @export
 * @class Id93a00866ac06078bApi
 * @extends {BaseAPI}
 */
export class Id93a00866ac06078bApi extends BaseAPI {
    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id93a00866ac06078bApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return Id93a00866ac06078bApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id949365b7c53ea85fApi - axios parameter creator
 * @export
 */
export const Id949365b7c53ea85fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id949365b7c53ea85fApi - functional programming interface
 * @export
 */
export const Id949365b7c53ea85fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id949365b7c53ea85fApiAxiosParamCreator(configuration)
    return {
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id949365b7c53ea85fApi - factory interface
 * @export
 */
export const Id949365b7c53ea85fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id949365b7c53ea85fApiFp(configuration)
    return {
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(orgId: string, options?: any): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id949365b7c53ea85fApi - object-oriented interface
 * @export
 * @class Id949365b7c53ea85fApi
 * @extends {BaseAPI}
 */
export class Id949365b7c53ea85fApi extends BaseAPI {
    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id949365b7c53ea85fApi
     */
    public orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig) {
        return Id949365b7c53ea85fApiFp(this.configuration).orgsOrgIdAppsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id94b512de88ff6cabApi - axios parameter creator
 * @export
 */
export const Id94b512de88ff6cabApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id94b512de88ff6cabApi - functional programming interface
 * @export
 */
export const Id94b512de88ff6cabApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id94b512de88ff6cabApiAxiosParamCreator(configuration)
    return {
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id94b512de88ff6cabApi - factory interface
 * @export
 */
export const Id94b512de88ff6cabApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id94b512de88ff6cabApiFp(configuration)
    return {
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id94b512de88ff6cabApi - object-oriented interface
 * @export
 * @class Id94b512de88ff6cabApi
 * @extends {BaseAPI}
 */
export class Id94b512de88ff6cabApi extends BaseAPI {
    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} body The Deployment ID to rebase to.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id94b512de88ff6cabApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig) {
        return Id94b512de88ff6cabApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id95feb55aec734ca3Api - axios parameter creator
 * @export
 */
export const Id95feb55aec734ca3ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id95feb55aec734ca3Api - functional programming interface
 * @export
 */
export const Id95feb55aec734ca3ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id95feb55aec734ca3ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id95feb55aec734ca3Api - factory interface
 * @export
 */
export const Id95feb55aec734ca3ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id95feb55aec734ca3ApiFp(configuration)
    return {
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id95feb55aec734ca3Api - object-oriented interface
 * @export
 * @class Id95feb55aec734ca3Api
 * @extends {BaseAPI}
 */
export class Id95feb55aec734ca3Api extends BaseAPI {
    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {string} orgId The Organization ID.  
     * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id95feb55aec734ca3Api
     */
    public orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig) {
        return Id95feb55aec734ca3ApiFp(this.configuration).orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id96262817857608feApi - axios parameter creator
 * @export
 */
export const Id96262817857608feApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id96262817857608feApi - functional programming interface
 * @export
 */
export const Id96262817857608feApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id96262817857608feApiAxiosParamCreator(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id96262817857608feApi - factory interface
 * @export
 */
export const Id96262817857608feApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id96262817857608feApiFp(configuration)
    return {
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id96262817857608feApi - object-oriented interface
 * @export
 * @class Id96262817857608feApi
 * @extends {BaseAPI}
 */
export class Id96262817857608feApi extends BaseAPI {
    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id96262817857608feApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig) {
        return Id96262817857608feApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id96d5dd97b8e37b87Api - axios parameter creator
 * @export
 */
export const Id96d5dd97b8e37b87ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id96d5dd97b8e37b87Api - functional programming interface
 * @export
 */
export const Id96d5dd97b8e37b87ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id96d5dd97b8e37b87ApiAxiosParamCreator(configuration)
    return {
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id96d5dd97b8e37b87Api - factory interface
 * @export
 */
export const Id96d5dd97b8e37b87ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id96d5dd97b8e37b87ApiFp(configuration)
    return {
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id96d5dd97b8e37b87Api - object-oriented interface
 * @export
 * @class Id96d5dd97b8e37b87Api
 * @extends {BaseAPI}
 */
export class Id96d5dd97b8e37b87Api extends BaseAPI {
    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id96d5dd97b8e37b87Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return Id96d5dd97b8e37b87ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id974799a8d2176238Api - axios parameter creator
 * @export
 */
export const Id974799a8d2176238ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id974799a8d2176238Api - functional programming interface
 * @export
 */
export const Id974799a8d2176238ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id974799a8d2176238ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id974799a8d2176238Api - factory interface
 * @export
 */
export const Id974799a8d2176238ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id974799a8d2176238ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: any): AxiosPromise<SetResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id974799a8d2176238Api - object-oriented interface
 * @export
 * @class Id974799a8d2176238Api
 * @extends {BaseAPI}
 */
export class Id974799a8d2176238Api extends BaseAPI {
    /**
     * 
     * @summary Get a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id974799a8d2176238Api
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig) {
        return Id974799a8d2176238ApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id98717a05b6ad0b11Api - axios parameter creator
 * @export
 */
export const Id98717a05b6ad0b11ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id98717a05b6ad0b11Api - functional programming interface
 * @export
 */
export const Id98717a05b6ad0b11ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id98717a05b6ad0b11ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id98717a05b6ad0b11Api - factory interface
 * @export
 */
export const Id98717a05b6ad0b11ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id98717a05b6ad0b11ApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id98717a05b6ad0b11Api - object-oriented interface
 * @export
 * @class Id98717a05b6ad0b11Api
 * @extends {BaseAPI}
 */
export class Id98717a05b6ad0b11Api extends BaseAPI {
    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {string} orgId The organization ID.  
     * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
     * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id98717a05b6ad0b11Api
     */
    public orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig) {
        return Id98717a05b6ad0b11ApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id99b6b9e01f007722Api - axios parameter creator
 * @export
 */
export const Id99b6b9e01f007722ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id99b6b9e01f007722Api - functional programming interface
 * @export
 */
export const Id99b6b9e01f007722ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id99b6b9e01f007722ApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id99b6b9e01f007722Api - factory interface
 * @export
 */
export const Id99b6b9e01f007722ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id99b6b9e01f007722ApiFp(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id99b6b9e01f007722Api - object-oriented interface
 * @export
 * @class Id99b6b9e01f007722Api
 * @extends {BaseAPI}
 */
export class Id99b6b9e01f007722Api extends BaseAPI {
    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id99b6b9e01f007722Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return Id99b6b9e01f007722ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id9c3ddf487957e18fApi - axios parameter creator
 * @export
 */
export const Id9c3ddf487957e18fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id9c3ddf487957e18fApi - functional programming interface
 * @export
 */
export const Id9c3ddf487957e18fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id9c3ddf487957e18fApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id9c3ddf487957e18fApi - factory interface
 * @export
 */
export const Id9c3ddf487957e18fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id9c3ddf487957e18fApiFp(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id9c3ddf487957e18fApi - object-oriented interface
 * @export
 * @class Id9c3ddf487957e18fApi
 * @extends {BaseAPI}
 */
export class Id9c3ddf487957e18fApi extends BaseAPI {
    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id9c3ddf487957e18fApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return Id9c3ddf487957e18fApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id9d6af7bf2193431fApi - axios parameter creator
 * @export
 */
export const Id9d6af7bf2193431fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id9d6af7bf2193431fApi - functional programming interface
 * @export
 */
export const Id9d6af7bf2193431fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id9d6af7bf2193431fApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id9d6af7bf2193431fApi - factory interface
 * @export
 */
export const Id9d6af7bf2193431fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id9d6af7bf2193431fApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id9d6af7bf2193431fApi - object-oriented interface
 * @export
 * @class Id9d6af7bf2193431fApi
 * @extends {BaseAPI}
 */
export class Id9d6af7bf2193431fApi extends BaseAPI {
    /**
     * 
     * @summary Create new Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id9d6af7bf2193431fApi
     */
    public orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig) {
        return Id9d6af7bf2193431fApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Id9dd92f28ae1db94bApi - axios parameter creator
 * @export
 */
export const Id9dd92f28ae1db94bApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Id9dd92f28ae1db94bApi - functional programming interface
 * @export
 */
export const Id9dd92f28ae1db94bApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Id9dd92f28ae1db94bApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Id9dd92f28ae1db94bApi - factory interface
 * @export
 */
export const Id9dd92f28ae1db94bApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Id9dd92f28ae1db94bApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(orgId: string, options?: any): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Id9dd92f28ae1db94bApi - object-oriented interface
 * @export
 * @class Id9dd92f28ae1db94bApi
 * @extends {BaseAPI}
 */
export class Id9dd92f28ae1db94bApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Id9dd92f28ae1db94bApi
     */
    public orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig) {
        return Id9dd92f28ae1db94bApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdA17507305ead668Api - axios parameter creator
 * @export
 */
export const IdA17507305ead668ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdA17507305ead668Api - functional programming interface
 * @export
 */
export const IdA17507305ead668ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdA17507305ead668ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdA17507305ead668Api - factory interface
 * @export
 */
export const IdA17507305ead668ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdA17507305ead668ApiFp(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdA17507305ead668Api - object-oriented interface
 * @export
 * @class IdA17507305ead668Api
 * @extends {BaseAPI}
 */
export class IdA17507305ead668Api extends BaseAPI {
    /**
     * 
     * @summary Update a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdA17507305ead668Api
     */
    public orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig) {
        return IdA17507305ead668ApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdA29139d7b2c28b6aApi - axios parameter creator
 * @export
 */
export const IdA29139d7b2c28b6aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdA29139d7b2c28b6aApi - functional programming interface
 * @export
 */
export const IdA29139d7b2c28b6aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdA29139d7b2c28b6aApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdA29139d7b2c28b6aApi - factory interface
 * @export
 */
export const IdA29139d7b2c28b6aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdA29139d7b2c28b6aApiFp(configuration)
    return {
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdA29139d7b2c28b6aApi - object-oriented interface
 * @export
 * @class IdA29139d7b2c28b6aApi
 * @extends {BaseAPI}
 */
export class IdA29139d7b2c28b6aApi extends BaseAPI {
    /**
     * 
     * @summary Restore a Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdA29139d7b2c28b6aApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return IdA29139d7b2c28b6aApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdA33767d6385d1888Api - axios parameter creator
 * @export
 */
export const IdA33767d6385d1888ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdA33767d6385d1888Api - functional programming interface
 * @export
 */
export const IdA33767d6385d1888ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdA33767d6385d1888ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdA33767d6385d1888Api - factory interface
 * @export
 */
export const IdA33767d6385d1888ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdA33767d6385d1888ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: any): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdA33767d6385d1888Api - object-oriented interface
 * @export
 * @class IdA33767d6385d1888Api
 * @extends {BaseAPI}
 */
export class IdA33767d6385d1888Api extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdA33767d6385d1888Api
     */
    public orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig) {
        return IdA33767d6385d1888ApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdA75e603687977c5Api - axios parameter creator
 * @export
 */
export const IdA75e603687977c5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdA75e603687977c5Api - functional programming interface
 * @export
 */
export const IdA75e603687977c5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdA75e603687977c5ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdA75e603687977c5Api - factory interface
 * @export
 */
export const IdA75e603687977c5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdA75e603687977c5ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(orgId: string, options?: any): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdA75e603687977c5Api - object-oriented interface
 * @export
 * @class IdA75e603687977c5Api
 * @extends {BaseAPI}
 */
export class IdA75e603687977c5Api extends BaseAPI {
    /**
     * 
     * @summary List Events
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdA75e603687977c5Api
     */
    public orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig) {
        return IdA75e603687977c5ApiFp(this.configuration).orgsOrgIdEventsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdA8bef911c67137baApi - axios parameter creator
 * @export
 */
export const IdA8bef911c67137baApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdA8bef911c67137baApi - functional programming interface
 * @export
 */
export const IdA8bef911c67137baApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdA8bef911c67137baApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdA8bef911c67137baApi - factory interface
 * @export
 */
export const IdA8bef911c67137baApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdA8bef911c67137baApiFp(configuration)
    return {
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdA8bef911c67137baApi - object-oriented interface
 * @export
 * @class IdA8bef911c67137baApi
 * @extends {BaseAPI}
 */
export class IdA8bef911c67137baApi extends BaseAPI {
    /**
     * 
     * @summary Loads a registry record details.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdA8bef911c67137baApi
     */
    public orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return IdA8bef911c67137baApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAae5a37db7a07735Api - axios parameter creator
 * @export
 */
export const IdAae5a37db7a07735ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAae5a37db7a07735Api - functional programming interface
 * @export
 */
export const IdAae5a37db7a07735ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAae5a37db7a07735ApiAxiosParamCreator(configuration)
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAae5a37db7a07735Api - factory interface
 * @export
 */
export const IdAae5a37db7a07735ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAae5a37db7a07735ApiFp(configuration)
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAae5a37db7a07735Api - object-oriented interface
 * @export
 * @class IdAae5a37db7a07735Api
 * @extends {BaseAPI}
 */
export class IdAae5a37db7a07735Api extends BaseAPI {
    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAae5a37db7a07735Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return IdAae5a37db7a07735ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAbf24f620aa16e0eApi - axios parameter creator
 * @export
 */
export const IdAbf24f620aa16e0eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAbf24f620aa16e0eApi - functional programming interface
 * @export
 */
export const IdAbf24f620aa16e0eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAbf24f620aa16e0eApiAxiosParamCreator(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAbf24f620aa16e0eApi - factory interface
 * @export
 */
export const IdAbf24f620aa16e0eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAbf24f620aa16e0eApiFp(configuration)
    return {
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAbf24f620aa16e0eApi - object-oriented interface
 * @export
 * @class IdAbf24f620aa16e0eApi
 * @extends {BaseAPI}
 */
export class IdAbf24f620aa16e0eApi extends BaseAPI {
    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAbf24f620aa16e0eApi
     */
    public orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return IdAbf24f620aa16e0eApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAcc5a9be7d0dc366Api - axios parameter creator
 * @export
 */
export const IdAcc5a9be7d0dc366ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAcc5a9be7d0dc366Api - functional programming interface
 * @export
 */
export const IdAcc5a9be7d0dc366ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAcc5a9be7d0dc366ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAcc5a9be7d0dc366Api - factory interface
 * @export
 */
export const IdAcc5a9be7d0dc366ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAcc5a9be7d0dc366ApiFp(configuration)
    return {
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAcc5a9be7d0dc366Api - object-oriented interface
 * @export
 * @class IdAcc5a9be7d0dc366Api
 * @extends {BaseAPI}
 */
export class IdAcc5a9be7d0dc366Api extends BaseAPI {
    /**
     * 
     * @summary Restore a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAcc5a9be7d0dc366Api
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return IdAcc5a9be7d0dc366ApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAd0ea902ca817467Api - axios parameter creator
 * @export
 */
export const IdAd0ea902ca817467ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAd0ea902ca817467Api - functional programming interface
 * @export
 */
export const IdAd0ea902ca817467ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAd0ea902ca817467ApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAd0ea902ca817467Api - factory interface
 * @export
 */
export const IdAd0ea902ca817467ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAd0ea902ca817467ApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAd0ea902ca817467Api - object-oriented interface
 * @export
 * @class IdAd0ea902ca817467Api
 * @extends {BaseAPI}
 */
export class IdAd0ea902ca817467Api extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAd0ea902ca817467Api
     */
    public orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig) {
        return IdAd0ea902ca817467ApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAd506ff9fc647b56Api - axios parameter creator
 * @export
 */
export const IdAd506ff9fc647b56ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationRequest: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationRequest', applicationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAd506ff9fc647b56Api - functional programming interface
 * @export
 */
export const IdAd506ff9fc647b56ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAd506ff9fc647b56ApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAd506ff9fc647b56Api - factory interface
 * @export
 */
export const IdAd506ff9fc647b56ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAd506ff9fc647b56ApiFp(configuration)
    return {
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAd506ff9fc647b56Api - object-oriented interface
 * @export
 * @class IdAd506ff9fc647b56Api
 * @extends {BaseAPI}
 */
export class IdAd506ff9fc647b56Api extends BaseAPI {
    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {string} orgId The Organization ID.  
     * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAd506ff9fc647b56Api
     */
    public orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig) {
        return IdAd506ff9fc647b56ApiFp(this.configuration).orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAddaaed3d337c1ccApi - axios parameter creator
 * @export
 */
export const IdAddaaed3d337c1ccApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAddaaed3d337c1ccApi - functional programming interface
 * @export
 */
export const IdAddaaed3d337c1ccApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAddaaed3d337c1ccApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAddaaed3d337c1ccApi - factory interface
 * @export
 */
export const IdAddaaed3d337c1ccApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAddaaed3d337c1ccApiFp(configuration)
    return {
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAddaaed3d337c1ccApi - object-oriented interface
 * @export
 * @class IdAddaaed3d337c1ccApi
 * @extends {BaseAPI}
 */
export class IdAddaaed3d337c1ccApi extends BaseAPI {
    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAddaaed3d337c1ccApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return IdAddaaed3d337c1ccApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAfbc6846b9b2a628Api - axios parameter creator
 * @export
 */
export const IdAfbc6846b9b2a628ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAfbc6846b9b2a628Api - functional programming interface
 * @export
 */
export const IdAfbc6846b9b2a628ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAfbc6846b9b2a628ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAfbc6846b9b2a628Api - factory interface
 * @export
 */
export const IdAfbc6846b9b2a628ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAfbc6846b9b2a628ApiFp(configuration)
    return {
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAfbc6846b9b2a628Api - object-oriented interface
 * @export
 * @class IdAfbc6846b9b2a628Api
 * @extends {BaseAPI}
 */
export class IdAfbc6846b9b2a628Api extends BaseAPI {
    /**
     * 
     * @summary Change the name of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAfbc6846b9b2a628Api
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return IdAfbc6846b9b2a628ApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdAff079b0c0159d6aApi - axios parameter creator
 * @export
 */
export const IdAff079b0c0159d6aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdAff079b0c0159d6aApi - functional programming interface
 * @export
 */
export const IdAff079b0c0159d6aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdAff079b0c0159d6aApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdAff079b0c0159d6aApi - factory interface
 * @export
 */
export const IdAff079b0c0159d6aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdAff079b0c0159d6aApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(orgId: string, options?: any): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdAff079b0c0159d6aApi - object-oriented interface
 * @export
 * @class IdAff079b0c0159d6aApi
 * @extends {BaseAPI}
 */
export class IdAff079b0c0159d6aApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Types.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdAff079b0c0159d6aApi
     */
    public orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return IdAff079b0c0159d6aApiFp(this.configuration).orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdB24ab2928e87553aApi - axios parameter creator
 * @export
 */
export const IdB24ab2928e87553aApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdB24ab2928e87553aApi - functional programming interface
 * @export
 */
export const IdB24ab2928e87553aApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdB24ab2928e87553aApiAxiosParamCreator(configuration)
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdB24ab2928e87553aApi - factory interface
 * @export
 */
export const IdB24ab2928e87553aApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdB24ab2928e87553aApiFp(configuration)
    return {
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdB24ab2928e87553aApi - object-oriented interface
 * @export
 * @class IdB24ab2928e87553aApi
 * @extends {BaseAPI}
 */
export class IdB24ab2928e87553aApi extends BaseAPI {
    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdB24ab2928e87553aApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig) {
        return IdB24ab2928e87553aApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdB389a3e9c7c22291Api - axios parameter creator
 * @export
 */
export const IdB389a3e9c7c22291ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdB389a3e9c7c22291Api - functional programming interface
 * @export
 */
export const IdB389a3e9c7c22291ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdB389a3e9c7c22291ApiAxiosParamCreator(configuration)
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdB389a3e9c7c22291Api - factory interface
 * @export
 */
export const IdB389a3e9c7c22291ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdB389a3e9c7c22291ApiFp(configuration)
    return {
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdB389a3e9c7c22291Api - object-oriented interface
 * @export
 * @class IdB389a3e9c7c22291Api
 * @extends {BaseAPI}
 */
export class IdB389a3e9c7c22291Api extends BaseAPI {
    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdB389a3e9c7c22291Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig) {
        return IdB389a3e9c7c22291ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdB3e2705703d342e5Api - axios parameter creator
 * @export
 */
export const IdB3e2705703d342e5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdB3e2705703d342e5Api - functional programming interface
 * @export
 */
export const IdB3e2705703d342e5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdB3e2705703d342e5ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdB3e2705703d342e5Api - factory interface
 * @export
 */
export const IdB3e2705703d342e5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdB3e2705703d342e5ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdB3e2705703d342e5Api - object-oriented interface
 * @export
 * @class IdB3e2705703d342e5Api
 * @extends {BaseAPI}
 */
export class IdB3e2705703d342e5Api extends BaseAPI {
    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdB3e2705703d342e5Api
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return IdB3e2705703d342e5ApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdB44fb6d383d8b31eApi - axios parameter creator
 * @export
 */
export const IdB44fb6d383d8b31eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdB44fb6d383d8b31eApi - functional programming interface
 * @export
 */
export const IdB44fb6d383d8b31eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdB44fb6d383d8b31eApiAxiosParamCreator(configuration)
    return {
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdB44fb6d383d8b31eApi - factory interface
 * @export
 */
export const IdB44fb6d383d8b31eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdB44fb6d383d8b31eApiFp(configuration)
    return {
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdB44fb6d383d8b31eApi - object-oriented interface
 * @export
 * @class IdB44fb6d383d8b31eApi
 * @extends {BaseAPI}
 */
export class IdB44fb6d383d8b31eApi extends BaseAPI {
    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdB44fb6d383d8b31eApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return IdB44fb6d383d8b31eApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdB8dbdeb2144c3541Api - axios parameter creator
 * @export
 */
export const IdB8dbdeb2144c3541ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdB8dbdeb2144c3541Api - functional programming interface
 * @export
 */
export const IdB8dbdeb2144c3541ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdB8dbdeb2144c3541ApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdB8dbdeb2144c3541Api - factory interface
 * @export
 */
export const IdB8dbdeb2144c3541ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdB8dbdeb2144c3541ApiFp(configuration)
    return {
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdB8dbdeb2144c3541Api - object-oriented interface
 * @export
 * @class IdB8dbdeb2144c3541Api
 * @extends {BaseAPI}
 */
export class IdB8dbdeb2144c3541Api extends BaseAPI {
    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdB8dbdeb2144c3541Api
     */
    public orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return IdB8dbdeb2144c3541ApiFp(this.configuration).orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdBd8b89c992f6fa98Api - axios parameter creator
 * @export
 */
export const IdBd8b89c992f6fa98ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdBd8b89c992f6fa98Api - functional programming interface
 * @export
 */
export const IdBd8b89c992f6fa98ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdBd8b89c992f6fa98ApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdBd8b89c992f6fa98Api - factory interface
 * @export
 */
export const IdBd8b89c992f6fa98ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdBd8b89c992f6fa98ApiFp(configuration)
    return {
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdBd8b89c992f6fa98Api - object-oriented interface
 * @export
 * @class IdBd8b89c992f6fa98Api
 * @extends {BaseAPI}
 */
export class IdBd8b89c992f6fa98Api extends BaseAPI {
    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdBd8b89c992f6fa98Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig) {
        return IdBd8b89c992f6fa98ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdBf24220c37b9378Api - axios parameter creator
 * @export
 */
export const IdBf24220c37b9378ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdBf24220c37b9378Api - functional programming interface
 * @export
 */
export const IdBf24220c37b9378ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdBf24220c37b9378ApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdBf24220c37b9378Api - factory interface
 * @export
 */
export const IdBf24220c37b9378ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdBf24220c37b9378ApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdBf24220c37b9378Api - object-oriented interface
 * @export
 * @class IdBf24220c37b9378Api
 * @extends {BaseAPI}
 */
export class IdBf24220c37b9378Api extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdBf24220c37b9378Api
     */
    public orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return IdBf24220c37b9378ApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdC3585a7affe88b8fApi - axios parameter creator
 * @export
 */
export const IdC3585a7affe88b8fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdC3585a7affe88b8fApi - functional programming interface
 * @export
 */
export const IdC3585a7affe88b8fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdC3585a7affe88b8fApiAxiosParamCreator(configuration)
    return {
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdC3585a7affe88b8fApi - factory interface
 * @export
 */
export const IdC3585a7affe88b8fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdC3585a7affe88b8fApiFp(configuration)
    return {
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdC3585a7affe88b8fApi - object-oriented interface
 * @export
 * @class IdC3585a7affe88b8fApi
 * @extends {BaseAPI}
 */
export class IdC3585a7affe88b8fApi extends BaseAPI {
    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdC3585a7affe88b8fApi
     */
    public orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return IdC3585a7affe88b8fApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdC6132a0703cd1492Api - axios parameter creator
 * @export
 */
export const IdC6132a0703cd1492ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdC6132a0703cd1492Api - functional programming interface
 * @export
 */
export const IdC6132a0703cd1492ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdC6132a0703cd1492ApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdC6132a0703cd1492Api - factory interface
 * @export
 */
export const IdC6132a0703cd1492ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdC6132a0703cd1492ApiFp(configuration)
    return {
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdC6132a0703cd1492Api - object-oriented interface
 * @export
 * @class IdC6132a0703cd1492Api
 * @extends {BaseAPI}
 */
export class IdC6132a0703cd1492Api extends BaseAPI {
    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdC6132a0703cd1492Api
     */
    public orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return IdC6132a0703cd1492ApiFp(this.configuration).orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdC703b9a3f17895d5Api - axios parameter creator
 * @export
 */
export const IdC703b9a3f17895d5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdC703b9a3f17895d5Api - functional programming interface
 * @export
 */
export const IdC703b9a3f17895d5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdC703b9a3f17895d5ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdC703b9a3f17895d5Api - factory interface
 * @export
 */
export const IdC703b9a3f17895d5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdC703b9a3f17895d5ApiFp(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdC703b9a3f17895d5Api - object-oriented interface
 * @export
 * @class IdC703b9a3f17895d5Api
 * @extends {BaseAPI}
 */
export class IdC703b9a3f17895d5Api extends BaseAPI {
    /**
     * 
     * @summary Update a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdC703b9a3f17895d5Api
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return IdC703b9a3f17895d5ApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdC931cd5bce59ec2cApi - axios parameter creator
 * @export
 */
export const IdC931cd5bce59ec2cApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdC931cd5bce59ec2cApi - functional programming interface
 * @export
 */
export const IdC931cd5bce59ec2cApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdC931cd5bce59ec2cApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdC931cd5bce59ec2cApi - factory interface
 * @export
 */
export const IdC931cd5bce59ec2cApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdC931cd5bce59ec2cApiFp(configuration)
    return {
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdC931cd5bce59ec2cApi - object-oriented interface
 * @export
 * @class IdC931cd5bce59ec2cApi
 * @extends {BaseAPI}
 */
export class IdC931cd5bce59ec2cApi extends BaseAPI {
    /**
     * 
     * @summary Update a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdC931cd5bce59ec2cApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return IdC931cd5bce59ec2cApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdCf3439c40bef5daaApi - axios parameter creator
 * @export
 */
export const IdCf3439c40bef5daaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdCf3439c40bef5daaApi - functional programming interface
 * @export
 */
export const IdCf3439c40bef5daaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdCf3439c40bef5daaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdCf3439c40bef5daaApi - factory interface
 * @export
 */
export const IdCf3439c40bef5daaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdCf3439c40bef5daaApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdCf3439c40bef5daaApi - object-oriented interface
 * @export
 * @class IdCf3439c40bef5daaApi
 * @extends {BaseAPI}
 */
export class IdCf3439c40bef5daaApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdCf3439c40bef5daaApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return IdCf3439c40bef5daaApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdCf934d36c6ece345Api - axios parameter creator
 * @export
 */
export const IdCf934d36c6ece345ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdCf934d36c6ece345Api - functional programming interface
 * @export
 */
export const IdCf934d36c6ece345ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdCf934d36c6ece345ApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdCf934d36c6ece345Api - factory interface
 * @export
 */
export const IdCf934d36c6ece345ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdCf934d36c6ece345ApiFp(configuration)
    return {
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(orgId: string, options?: any): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdCf934d36c6ece345Api - object-oriented interface
 * @export
 * @class IdCf934d36c6ece345Api
 * @extends {BaseAPI}
 */
export class IdCf934d36c6ece345Api extends BaseAPI {
    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdCf934d36c6ece345Api
     */
    public orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return IdCf934d36c6ece345ApiFp(this.configuration).orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdD078104033e8a68eApi - axios parameter creator
 * @export
 */
export const IdD078104033e8a68eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdD078104033e8a68eApi - functional programming interface
 * @export
 */
export const IdD078104033e8a68eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdD078104033e8a68eApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdD078104033e8a68eApi - factory interface
 * @export
 */
export const IdD078104033e8a68eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdD078104033e8a68eApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(orgId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdD078104033e8a68eApi - object-oriented interface
 * @export
 * @class IdD078104033e8a68eApi
 * @extends {BaseAPI}
 */
export class IdD078104033e8a68eApi extends BaseAPI {
    /**
     * 
     * @summary Get the specified Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdD078104033e8a68eApi
     */
    public orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig) {
        return IdD078104033e8a68eApiFp(this.configuration).orgsOrgIdGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdD1246e41218c085dApi - axios parameter creator
 * @export
 */
export const IdD1246e41218c085dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdD1246e41218c085dApi - functional programming interface
 * @export
 */
export const IdD1246e41218c085dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdD1246e41218c085dApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdD1246e41218c085dApi - factory interface
 * @export
 */
export const IdD1246e41218c085dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdD1246e41218c085dApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdD1246e41218c085dApi - object-oriented interface
 * @export
 * @class IdD1246e41218c085dApi
 * @extends {BaseAPI}
 */
export class IdD1246e41218c085dApi extends BaseAPI {
    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {RegistryRequest} registryRequest Record details to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdD1246e41218c085dApi
     */
    public orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return IdD1246e41218c085dApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdD1d607767c2fa523Api - axios parameter creator
 * @export
 */
export const IdD1d607767c2fa523ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdD1d607767c2fa523Api - functional programming interface
 * @export
 */
export const IdD1d607767c2fa523ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdD1d607767c2fa523ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdD1d607767c2fa523Api - factory interface
 * @export
 */
export const IdD1d607767c2fa523ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdD1d607767c2fa523ApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdD1d607767c2fa523Api - object-oriented interface
 * @export
 * @class IdD1d607767c2fa523Api
 * @extends {BaseAPI}
 */
export class IdD1d607767c2fa523Api extends BaseAPI {
    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdD1d607767c2fa523Api
     */
    public orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return IdD1d607767c2fa523ApiFp(this.configuration).orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdD5377a51480dde5eApi - axios parameter creator
 * @export
 */
export const IdD5377a51480dde5eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdD5377a51480dde5eApi - functional programming interface
 * @export
 */
export const IdD5377a51480dde5eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdD5377a51480dde5eApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdD5377a51480dde5eApi - factory interface
 * @export
 */
export const IdD5377a51480dde5eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdD5377a51480dde5eApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdD5377a51480dde5eApi - object-oriented interface
 * @export
 * @class IdD5377a51480dde5eApi
 * @extends {BaseAPI}
 */
export class IdD5377a51480dde5eApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdD5377a51480dde5eApi
     */
    public orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return IdD5377a51480dde5eApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdD6b87166851d1d7fApi - axios parameter creator
 * @export
 */
export const IdD6b87166851d1d7fApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdD6b87166851d1d7fApi - functional programming interface
 * @export
 */
export const IdD6b87166851d1d7fApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdD6b87166851d1d7fApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdD6b87166851d1d7fApi - factory interface
 * @export
 */
export const IdD6b87166851d1d7fApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdD6b87166851d1d7fApiFp(configuration)
    return {
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdD6b87166851d1d7fApi - object-oriented interface
 * @export
 * @class IdD6b87166851d1d7fApi
 * @extends {BaseAPI}
 */
export class IdD6b87166851d1d7fApi extends BaseAPI {
    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdD6b87166851d1d7fApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return IdD6b87166851d1d7fApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdDa2202dfc8b9fef1Api - axios parameter creator
 * @export
 */
export const IdDa2202dfc8b9fef1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdDa2202dfc8b9fef1Api - functional programming interface
 * @export
 */
export const IdDa2202dfc8b9fef1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdDa2202dfc8b9fef1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdDa2202dfc8b9fef1Api - factory interface
 * @export
 */
export const IdDa2202dfc8b9fef1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdDa2202dfc8b9fef1ApiFp(configuration)
    return {
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdDa2202dfc8b9fef1Api - object-oriented interface
 * @export
 * @class IdDa2202dfc8b9fef1Api
 * @extends {BaseAPI}
 */
export class IdDa2202dfc8b9fef1Api extends BaseAPI {
    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdDa2202dfc8b9fef1Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return IdDa2202dfc8b9fef1ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdDca2a04b5dc4903eApi - axios parameter creator
 * @export
 */
export const IdDca2a04b5dc4903eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdDca2a04b5dc4903eApi - functional programming interface
 * @export
 */
export const IdDca2a04b5dc4903eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdDca2a04b5dc4903eApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdDca2a04b5dc4903eApi - factory interface
 * @export
 */
export const IdDca2a04b5dc4903eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdDca2a04b5dc4903eApiFp(configuration)
    return {
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdDca2a04b5dc4903eApi - object-oriented interface
 * @export
 * @class IdDca2a04b5dc4903eApi
 * @extends {BaseAPI}
 */
export class IdDca2a04b5dc4903eApi extends BaseAPI {
    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdDca2a04b5dc4903eApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return IdDca2a04b5dc4903eApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdDcfa034d27b23c6dApi - axios parameter creator
 * @export
 */
export const IdDcfa034d27b23c6dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdDcfa034d27b23c6dApi - functional programming interface
 * @export
 */
export const IdDcfa034d27b23c6dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdDcfa034d27b23c6dApiAxiosParamCreator(configuration)
    return {
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdDcfa034d27b23c6dApi - factory interface
 * @export
 */
export const IdDcfa034d27b23c6dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdDcfa034d27b23c6dApiFp(configuration)
    return {
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: any): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdDcfa034d27b23c6dApi - object-oriented interface
 * @export
 * @class IdDcfa034d27b23c6dApi
 * @extends {BaseAPI}
 */
export class IdDcfa034d27b23c6dApi extends BaseAPI {
    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {string} orgId The Organization ID.  
     * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
     * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdDcfa034d27b23c6dApi
     */
    public orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig) {
        return IdDcfa034d27b23c6dApiFp(this.configuration).orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdDd2a29fa6db45d7Api - axios parameter creator
 * @export
 */
export const IdDd2a29fa6db45d7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost: async (orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'profileId', profileId)
            // verify required parameter 'workloadProfileVersionRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'workloadProfileVersionRequest', workloadProfileVersionRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdDd2a29fa6db45d7Api - functional programming interface
 * @export
 */
export const IdDd2a29fa6db45d7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdDd2a29fa6db45d7ApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdDd2a29fa6db45d7Api - factory interface
 * @export
 */
export const IdDd2a29fa6db45d7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdDd2a29fa6db45d7ApiFp(configuration)
    return {
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: any): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdDd2a29fa6db45d7Api - object-oriented interface
 * @export
 * @class IdDd2a29fa6db45d7Api
 * @extends {BaseAPI}
 */
export class IdDd2a29fa6db45d7Api extends BaseAPI {
    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload Profile ID.  
     * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdDd2a29fa6db45d7Api
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return IdDd2a29fa6db45d7ApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdE64008a9dd7e2425Api - axios parameter creator
 * @export
 */
export const IdE64008a9dd7e2425ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdE64008a9dd7e2425Api - functional programming interface
 * @export
 */
export const IdE64008a9dd7e2425ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdE64008a9dd7e2425ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdE64008a9dd7e2425Api - factory interface
 * @export
 */
export const IdE64008a9dd7e2425ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdE64008a9dd7e2425ApiFp(configuration)
    return {
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdE64008a9dd7e2425Api - object-oriented interface
 * @export
 * @class IdE64008a9dd7e2425Api
 * @extends {BaseAPI}
 */
export class IdE64008a9dd7e2425Api extends BaseAPI {
    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdE64008a9dd7e2425Api
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return IdE64008a9dd7e2425ApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdE8db605b46807ac7Api - axios parameter creator
 * @export
 */
export const IdE8db605b46807ac7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdE8db605b46807ac7Api - functional programming interface
 * @export
 */
export const IdE8db605b46807ac7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdE8db605b46807ac7ApiAxiosParamCreator(configuration)
    return {
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdE8db605b46807ac7Api - factory interface
 * @export
 */
export const IdE8db605b46807ac7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdE8db605b46807ac7ApiFp(configuration)
    return {
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdE8db605b46807ac7Api - object-oriented interface
 * @export
 * @class IdE8db605b46807ac7Api
 * @extends {BaseAPI}
 */
export class IdE8db605b46807ac7Api extends BaseAPI {
    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdE8db605b46807ac7Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return IdE8db605b46807ac7ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdEb53bc5497df7fe6Api - axios parameter creator
 * @export
 */
export const IdEb53bc5497df7fe6ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdEb53bc5497df7fe6Api - functional programming interface
 * @export
 */
export const IdEb53bc5497df7fe6ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdEb53bc5497df7fe6ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdEb53bc5497df7fe6Api - factory interface
 * @export
 */
export const IdEb53bc5497df7fe6ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdEb53bc5497df7fe6ApiFp(configuration)
    return {
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdEb53bc5497df7fe6Api - object-oriented interface
 * @export
 * @class IdEb53bc5497df7fe6Api
 * @extends {BaseAPI}
 */
export class IdEb53bc5497df7fe6Api extends BaseAPI {
    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdEb53bc5497df7fe6Api
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return IdEb53bc5497df7fe6ApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdEd8f9c6328f59c17Api - axios parameter creator
 * @export
 */
export const IdEd8f9c6328f59c17ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdEd8f9c6328f59c17Api - functional programming interface
 * @export
 */
export const IdEd8f9c6328f59c17ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdEd8f9c6328f59c17ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdEd8f9c6328f59c17Api - factory interface
 * @export
 */
export const IdEd8f9c6328f59c17ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdEd8f9c6328f59c17ApiFp(configuration)
    return {
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdEd8f9c6328f59c17Api - object-oriented interface
 * @export
 * @class IdEd8f9c6328f59c17Api
 * @extends {BaseAPI}
 */
export class IdEd8f9c6328f59c17Api extends BaseAPI {
    /**
     * 
     * @summary Update a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdEd8f9c6328f59c17Api
     */
    public orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return IdEd8f9c6328f59c17ApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdEdc8f96dad1b588dApi - axios parameter creator
 * @export
 */
export const IdEdc8f96dad1b588dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-type/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdEdc8f96dad1b588dApi - functional programming interface
 * @export
 */
export const IdEdc8f96dad1b588dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdEdc8f96dad1b588dApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdEdc8f96dad1b588dApi - factory interface
 * @export
 */
export const IdEdc8f96dad1b588dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdEdc8f96dad1b588dApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdEdc8f96dad1b588dApi - object-oriented interface
 * @export
 * @class IdEdc8f96dad1b588dApi
 * @extends {BaseAPI}
 */
export class IdEdc8f96dad1b588dApi extends BaseAPI {
    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envType The Environment Type.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdEdc8f96dad1b588dApi
     */
    public orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig) {
        return IdEdc8f96dad1b588dApiFp(this.configuration).orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdF1da5f18617be2eApi - axios parameter creator
 * @export
 */
export const IdF1da5f18617be2eApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdF1da5f18617be2eApi - functional programming interface
 * @export
 */
export const IdF1da5f18617be2eApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdF1da5f18617be2eApiAxiosParamCreator(configuration)
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdF1da5f18617be2eApi - factory interface
 * @export
 */
export const IdF1da5f18617be2eApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdF1da5f18617be2eApiFp(configuration)
    return {
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdF1da5f18617be2eApi - object-oriented interface
 * @export
 * @class IdF1da5f18617be2eApi
 * @extends {BaseAPI}
 */
export class IdF1da5f18617be2eApi extends BaseAPI {
    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdF1da5f18617be2eApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return IdF1da5f18617be2eApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdF27701fca8b5a3f7Api - axios parameter creator
 * @export
 */
export const IdF27701fca8b5a3f7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdF27701fca8b5a3f7Api - functional programming interface
 * @export
 */
export const IdF27701fca8b5a3f7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdF27701fca8b5a3f7ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdF27701fca8b5a3f7Api - factory interface
 * @export
 */
export const IdF27701fca8b5a3f7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdF27701fca8b5a3f7ApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdF27701fca8b5a3f7Api - object-oriented interface
 * @export
 * @class IdF27701fca8b5a3f7Api
 * @extends {BaseAPI}
 */
export class IdF27701fca8b5a3f7Api extends BaseAPI {
    /**
     * 
     * @summary Creates a new registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {RegistryRequest} registryRequest A new record details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdF27701fca8b5a3f7Api
     */
    public orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return IdF27701fca8b5a3f7ApiFp(this.configuration).orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdF707bd1009c42204Api - axios parameter creator
 * @export
 */
export const IdF707bd1009c42204ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdF707bd1009c42204Api - functional programming interface
 * @export
 */
export const IdF707bd1009c42204ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdF707bd1009c42204ApiAxiosParamCreator(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdF707bd1009c42204Api - factory interface
 * @export
 */
export const IdF707bd1009c42204ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdF707bd1009c42204ApiFp(configuration)
    return {
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdF707bd1009c42204Api - object-oriented interface
 * @export
 * @class IdF707bd1009c42204Api
 * @extends {BaseAPI}
 */
export class IdF707bd1009c42204Api extends BaseAPI {
    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdF707bd1009c42204Api
     */
    public orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig) {
        return IdF707bd1009c42204ApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdF71e166af2cd4b27Api - axios parameter creator
 * @export
 */
export const IdF71e166af2cd4b27ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdF71e166af2cd4b27Api - functional programming interface
 * @export
 */
export const IdF71e166af2cd4b27ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdF71e166af2cd4b27ApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdF71e166af2cd4b27Api - factory interface
 * @export
 */
export const IdF71e166af2cd4b27ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdF71e166af2cd4b27ApiFp(configuration)
    return {
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdF71e166af2cd4b27Api - object-oriented interface
 * @export
 * @class IdF71e166af2cd4b27Api
 * @extends {BaseAPI}
 */
export class IdF71e166af2cd4b27Api extends BaseAPI {
    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdF71e166af2cd4b27Api
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return IdF71e166af2cd4b27ApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdF7cfaeaeae78afbeApi - axios parameter creator
 * @export
 */
export const IdF7cfaeaeae78afbeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdF7cfaeaeae78afbeApi - functional programming interface
 * @export
 */
export const IdF7cfaeaeae78afbeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdF7cfaeaeae78afbeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdF7cfaeaeae78afbeApi - factory interface
 * @export
 */
export const IdF7cfaeaeae78afbeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdF7cfaeaeae78afbeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdF7cfaeaeae78afbeApi - object-oriented interface
 * @export
 * @class IdF7cfaeaeae78afbeApi
 * @extends {BaseAPI}
 */
export class IdF7cfaeaeae78afbeApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdF7cfaeaeae78afbeApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return IdF7cfaeaeae78afbeApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdFa93a87e878046daApi - axios parameter creator
 * @export
 */
export const IdFa93a87e878046daApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdFa93a87e878046daApi - functional programming interface
 * @export
 */
export const IdFa93a87e878046daApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdFa93a87e878046daApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdFa93a87e878046daApi - factory interface
 * @export
 */
export const IdFa93a87e878046daApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdFa93a87e878046daApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdFa93a87e878046daApi - object-oriented interface
 * @export
 * @class IdFa93a87e878046daApi
 * @extends {BaseAPI}
 */
export class IdFa93a87e878046daApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdFa93a87e878046daApi
     */
    public orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return IdFa93a87e878046daApiFp(this.configuration).orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdFb2094f394e500e5Api - axios parameter creator
 * @export
 */
export const IdFb2094f394e500e5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdFb2094f394e500e5Api - functional programming interface
 * @export
 */
export const IdFb2094f394e500e5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdFb2094f394e500e5ApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdFb2094f394e500e5Api - factory interface
 * @export
 */
export const IdFb2094f394e500e5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdFb2094f394e500e5ApiFp(configuration)
    return {
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdFb2094f394e500e5Api - object-oriented interface
 * @export
 * @class IdFb2094f394e500e5Api
 * @extends {BaseAPI}
 */
export class IdFb2094f394e500e5Api extends BaseAPI {
    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {string} orgId The organization ID.  
     * @param {string} [name] (Optional) Filter Artefact Versions by name.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdFb2094f394e500e5Api
     */
    public orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig) {
        return IdFb2094f394e500e5ApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdFd99afedecd0dafdApi - axios parameter creator
 * @export
 */
export const IdFd99afedecd0dafdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdFd99afedecd0dafdApi - functional programming interface
 * @export
 */
export const IdFd99afedecd0dafdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdFd99afedecd0dafdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdFd99afedecd0dafdApi - factory interface
 * @export
 */
export const IdFd99afedecd0dafdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdFd99afedecd0dafdApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdFd99afedecd0dafdApi - object-oriented interface
 * @export
 * @class IdFd99afedecd0dafdApi
 * @extends {BaseAPI}
 */
export class IdFd99afedecd0dafdApi extends BaseAPI {
    /**
     * 
     * @summary Get a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdFd99afedecd0dafdApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return IdFd99afedecd0dafdApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdFe2bf6668207aaf7Api - axios parameter creator
 * @export
 */
export const IdFe2bf6668207aaf7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdFe2bf6668207aaf7Api - functional programming interface
 * @export
 */
export const IdFe2bf6668207aaf7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdFe2bf6668207aaf7ApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdFe2bf6668207aaf7Api - factory interface
 * @export
 */
export const IdFe2bf6668207aaf7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdFe2bf6668207aaf7ApiFp(configuration)
    return {
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdFe2bf6668207aaf7Api - object-oriented interface
 * @export
 * @class IdFe2bf6668207aaf7Api
 * @extends {BaseAPI}
 */
export class IdFe2bf6668207aaf7Api extends BaseAPI {
    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdFe2bf6668207aaf7Api
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return IdFe2bf6668207aaf7ApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdFe88c1c152f34014Api - axios parameter creator
 * @export
 */
export const IdFe88c1c152f34014ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdFe88c1c152f34014Api - functional programming interface
 * @export
 */
export const IdFe88c1c152f34014ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdFe88c1c152f34014ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdFe88c1c152f34014Api - factory interface
 * @export
 */
export const IdFe88c1c152f34014ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdFe88c1c152f34014ApiFp(configuration)
    return {
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdFe88c1c152f34014Api - object-oriented interface
 * @export
 * @class IdFe88c1c152f34014Api
 * @extends {BaseAPI}
 */
export class IdFe88c1c152f34014Api extends BaseAPI {
    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdFe88c1c152f34014Api
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return IdFe88c1c152f34014ApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(orgId: string, options?: any): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: any): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {string} orgId The organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchingCriteriaApi - axios parameter creator
 * @export
 */
export const MatchingCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchingCriteriaApi - functional programming interface
 * @export
 */
export const MatchingCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchingCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchingCriteriaApi - factory interface
 * @export
 */
export const MatchingCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchingCriteriaApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchingCriteriaApi - object-oriented interface
 * @export
 * @class MatchingCriteriaApi
 * @extends {BaseAPI}
 */
export class MatchingCriteriaApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchingCriteriaApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return MatchingCriteriaApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(orgId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).orgsOrgIdGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut: async (orgId: string, appId: string, deltaId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/archived`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/env_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut: async (orgId: string, appId: string, deltaId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'deltaId', deltaId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdNamePut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/name`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch: async (orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'appId', appId)
            // verify required parameter 'deltaId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaId', deltaId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasDeltaIdPatch', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"deltaId"}}`, encodeURIComponent(String(deltaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet: async (orgId: string, appId: string, archived?: boolean, env?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost: async (orgId: string, appId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'appId', appId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdDeltasPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/deltas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet: async (orgId: string, appId: string, envId: string, deployId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'envId', envId)
            // verify required parameter 'deployId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet', 'deployId', deployId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"deployId"}}`, encodeURIComponent(String(deployId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost: async (orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'envId', envId)
            // verify required parameter 'deploymentRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost', 'deploymentRequest', deploymentRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut: async (orgId: string, appId: string, envId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete: async (orgId: string, appId: string, envId: string, type: string, resId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'envId', envId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'type', type)
            // verify required parameter 'resId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete', 'resId', resId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"resId"}}`, encodeURIComponent(String(resId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost: async (orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'envId', envId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesPost', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet: async (orgId: string, appId: string, envId: string, ruleId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet', 'ruleId', ruleId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut: async (orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'envId', envId)
            // verify required parameter 'ruleId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'ruleId', ruleId)
            // verify required parameter 'automationRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut', 'automationRuleRequest', automationRuleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"ruleId"}}`, encodeURIComponent(String(ruleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost: async (orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'appId', appId)
            // verify required parameter 'environmentDefinitionRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsPost', 'environmentDefinitionRequest', environmentDefinitionRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentDefinitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdJobsDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/jobs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdDelete', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet: async (orgId: string, appId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdGet', 'jobId', jobId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost: async (orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'appId', appId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'jobId', jobId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksJobIdPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost: async (orgId: string, appId: string, webhookRequest: WebhookRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'appId', appId)
            // verify required parameter 'webhookRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdWebhooksPost', 'webhookRequest', webhookRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/webhooks`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost: async (orgId: string, applicationRequest: ApplicationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'orgId', orgId)
            // verify required parameter 'applicationRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsPost', 'applicationRequest', applicationRequest)
            const localVarPath = `/orgs/{orgId}/apps`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet: async (orgId: string, name?: string, reference?: string, archived?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost: async (orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'orgId', orgId)
            // verify required parameter 'addArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactVersionsPost', 'addArtefactVersionPayloadRequest', addArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefact-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vcs !== undefined) {
                localVarQueryParameter['vcs'] = vcs;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete: async (orgId: string, artefactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdDelete', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet: async (orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsGet', 'artefactId', artefactId)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch: async (orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'orgId', orgId)
            // verify required parameter 'artefactId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'artefactId', artefactId)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'versionId', versionId)
            // verify required parameter 'updateArtefactVersionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch', 'updateArtefactVersionPayloadRequest', updateArtefactVersionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"artefactId"}}`, encodeURIComponent(String(artefactId)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateArtefactVersionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet: async (orgId: string, type?: string, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdArtefactsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/artefacts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-type/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdDelete', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet: async (orgId: string, envTypeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'orgId', orgId)
            // verify required parameter 'envTypeId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesEnvTypeIdGet', 'envTypeId', envTypeId)
            const localVarPath = `/orgs/{orgId}/env-types/{envTypeId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envTypeId"}}`, encodeURIComponent(String(envTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost: async (orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'orgId', orgId)
            // verify required parameter 'environmentTypeRequest' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypesPost', 'environmentTypeRequest', environmentTypeRequest)
            const localVarPath = `/orgs/{orgId}/env-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEventsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/events`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/images`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost: async (orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageId', imageId)
            // verify required parameter 'imageBuildRequest' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdBuildsPost', 'imageBuildRequest', imageBuildRequest)
            const localVarPath = `/orgs/{orgId}/images/{imageId}/builds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet: async (orgId: string, imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'orgId', orgId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('orgsOrgIdImagesImageIdGet', 'imageId', imageId)
            const localVarPath = `/orgs/{orgId}/images/{imageId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/account-types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdDelete', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet: async (orgId: string, driverId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdGet', 'driverId', driverId)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut: async (orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'orgId', orgId)
            // verify required parameter 'driverId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'driverId', driverId)
            // verify required parameter 'updateDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversDriverIdPut', 'updateDriverRequestRequest', updateDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers/{driverId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"driverId"}}`, encodeURIComponent(String(driverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost: async (orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'orgId', orgId)
            // verify required parameter 'createDriverRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDriversPost', 'createDriverRequestRequest', createDriverRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/drivers`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDriverRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete: async (orgId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost: async (orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'profileId', profileId)
            // verify required parameter 'workloadProfileVersionRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'workloadProfileVersionRequest', workloadProfileVersionRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeltaResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentErrorResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutomationRuleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationRuleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsPost(orgId, applicationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtefactVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtefactResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdArtefactsGet(orgId, type, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEventsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageBuildResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdImagesImageIdGet(orgId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active organizations the user has access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsGet(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.orgsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
         * @summary Delete an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archived Deltas are still accessible but can no longer be updated.
         * @summary Mark a Delta as \"archived\"
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the Environment of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the name of a Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Deployment Delta.  
         * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} deltaId ID of the Delta to update.  
         * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Deltas in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {boolean} [archived] If true, return archived Deltas.  
         * @param {string} [env] Only return Deltas associated with the specified Environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: any): AxiosPromise<Array<DeltaResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Delta
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
         * @summary Delete a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List errors that occurred in a Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<Array<DeploymentErrorResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Deployment in an Application and an Environment.
         * @summary Get a specific Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} deployId The Deployment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
         * @summary List Deployments in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<DeploymentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
         * @summary Start a new Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: any): AxiosPromise<DeploymentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
         * @summary Rebase to a different Deployment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} body The Deployment ID to rebase to.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment in an Application.
         * @summary Get a specific Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned in an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Active Resources.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} type The Resource Type.  
         * @param {string} resId The Resource ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Automation Rules in an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<AutomationRuleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Create a new Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Automation Rule from an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
         * @summary Update an existing Automation Rule for an Environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} ruleId The Automation Rule ID.  
         * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: any): AxiosPromise<AutomationRuleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all of the Environments in the Application.
         * @summary List all Environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<EnvironmentResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
         * @summary Add a new Environment to an Application.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: any): AxiosPromise<EnvironmentResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Application in the specified Organization by ID.
         * @summary Get an existing Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes all Jobs for the Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: any): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: any): AxiosPromise<SetResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Webhooks
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<WebhookResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} jobId The Webhook ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Webhook
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {WebhookRequest} webhookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: any): AxiosPromise<WebhookResponse> {
            return localVarFp.orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Listing or lists of all Applications that exist within a specific Organization.
         * @summary List all Applications in an Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsGet(orgId: string, options?: any): AxiosPromise<Array<ApplicationResponse>> {
            return localVarFp.orgsOrgIdAppsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Application, then adds it to the specified Organization.
         * @summary Add a new Application to an Organization
         * @param {string} orgId The Organization ID.  
         * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: any): AxiosPromise<ApplicationResponse> {
            return localVarFp.orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts Versions.
         * @param {string} orgId The organization ID.  
         * @param {string} [name] (Optional) Filter Artefact Versions by name.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Artefact Version with your organization.
         * @param {string} orgId The organization ID.  
         * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
         * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
         * @summary Delete Artefact and all related Artefact Versions
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefact Versions of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
         * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
         * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: any): AxiosPromise<Array<ArtefactVersionResponse>> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the version of a specified Artefact registered with your organization\".
         * @summary Update Version of an Artefact.
         * @param {string} orgId The organization ID.  
         * @param {string} artefactId The Artefact ID.  
         * @param {string} versionId The Version ID.  
         * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: any): AxiosPromise<ArtefactVersionResponse> {
            return localVarFp.orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
         * @summary List all Artefacts.
         * @param {string} orgId The organization ID.  
         * @param {string} [type] (Optional) Filter Artefacts by type.  
         * @param {string} [name] (Optional) Filter Artefacts by name.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: any): AxiosPromise<Array<ArtefactResponse>> {
            return localVarFp.orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
         * @summary Deletes an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific Environment Type within an Organization.
         * @summary Get an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envTypeId ID of the Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Environment Types in an Organization.
         * @summary List all Environment Types
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesGet(orgId: string, options?: any): AxiosPromise<Array<EnvironmentTypeResponse>> {
            return localVarFp.orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new Environment Type to an Organization.
         * @summary Add a new Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: any): AxiosPromise<EnvironmentTypeResponse> {
            return localVarFp.orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Events
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEventsGet(orgId: string, options?: any): AxiosPromise<Array<EventResponse>> {
            return localVarFp.orgsOrgIdEventsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the specified Organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdGet(orgId: string, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.orgsOrgIdGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
         * @summary List all Container Images
         * @param {string} orgId The organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesGet(orgId: string, options?: any): AxiosPromise<Array<ImageResponse>> {
            return localVarFp.orgsOrgIdImagesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
         * @summary Lists all the Builds of an Image
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: any): AxiosPromise<Array<ImageBuildResponse>> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
         * @summary Add a new Image Build
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
         * @summary Get a specific Image Object
         * @param {string} orgId The organization ID.  
         * @param {string} imageId The Image ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(orgId: string, options?: any): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(orgId: string, options?: any): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Account Types available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: any): AxiosPromise<Array<AccountTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(orgId: string, options?: any): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: any): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Resources Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resources Driver ID to delete.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
         * @summary Get a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {string} driverId The Resource Driver ID.  
         * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Drivers.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversGet(orgId: string, options?: any): AxiosPromise<Array<DriverDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new Resource Driver.
         * @param {string} orgId The Organization ID.  
         * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: any): AxiosPromise<DriverDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(orgId: string, options?: any): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(orgId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(orgId: string, options?: any): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: any): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: any): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).currentUserPatch(userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active organizations the user has access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * @summary Delete an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * @summary Mark a Delta as \"archived\"
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {boolean} body Either &#x60;true&#x60; or &#x60;false&#x60;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId: string, appId: string, deltaId: string, body: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdArchivedPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the Environment of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new Environment ID. (NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdEnvIdPut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the name of a Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Deployment Delta.  
     * @param {string} body The new name.(NOTE: The string must still be JSON encoded.)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId: string, appId: string, deltaId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdNamePut(orgId, appId, deltaId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} deltaId ID of the Delta to update.  
     * @param {Array<DeltaRequest>} deltaRequest An array of Deltas.  The Deltas in the request are combined, meaning the current Delta is updated in turn by each Delta in the request. Once all Deltas have been combined, the resulting Delta is simplified.  * All Modules in the &#x60;modules.add&#x60; property are replaced with the new Delta\&#39;s values. If the value of a Module is &#x60;null&#x60;, and the ID is in the &#x60;modules.remove&#x60; list, it is removed from the &#x60;modules.remove&#x60; list.  * All IDs listed in &#x60;modules.remove&#x60; are combined. Any ID in &#x60;modules.remove&#x60; and also in &#x60;modules.add&#x60; are removed from &#x60;modules.add&#x60;  * The lists of JSON Patches in &#x60;modules.update&#x60; are concatenated or created in &#x60;modules.updates&#x60;.  Simplification involves:  * Applying any entries in &#x60;modules.updates&#x60; that have matching IDs in &#x60;modules.add&#x60; to the &#x60;modules.add&#x60; entry and removing the &#x60;modules.update&#x60; entry.  * Reducing the number of JSON Patches in each &#x60;modules.update&#x60; entry to the smallest set that has the same effect.  **Extension to JSON Patch**  If a JSON Patch entry needs to be removed, without side effects, the &#x60;value&#x60; of the &#x60;remove&#x60; action can be set to &#x60;{\&quot;scope\&quot;: \&quot;delta\&quot;}. This will result in the remove action being used during simplification but be discarded before the Delta is finalized.  If the user making the request is not the user who created the Delta and they are not already on the contributors list, they will be added to the contributors list.  _NOTE: If the &#x60;id&#x60; or &#x60;metadata&#x60; properties are specified, they will be ignored._
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId: string, appId: string, deltaId: string, deltaRequest: Array<DeltaRequest>, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasDeltaIdPatch(orgId, appId, deltaId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Deltas in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {boolean} [archived] If true, return archived Deltas.  
     * @param {string} [env] Only return Deltas associated with the specified Environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasGet(orgId: string, appId: string, archived?: boolean, env?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasGet(orgId, appId, archived, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Delta
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {DeltaRequest} deltaRequest A Deployment Delta to create.  The Deployment Delta will be added with the provided content of &#x60;modules&#x60; and the \&#39;env_id\&#39; and \&#39;name\&#39; properties of the \&#39;metadata\&#39; property.  NOTE: If the &#x60;id&#x60; property is specified, it will be ignored. A new ID will be generated and returned in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdDeltasPost(orgId: string, appId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdDeltasPost(orgId, appId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * @summary Delete a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List errors that occurred in a Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdErrorsGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * @summary Get a specific Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} deployId The Deployment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId: string, appId: string, envId: string, deployId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysDeployIdGet(orgId, appId, envId, deployId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * @summary List Deployments in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * @summary Start a new Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {DeploymentRequest} deploymentRequest The Delta describing the change to the Environment and a comment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId: string, appId: string, envId: string, deploymentRequest: DeploymentRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdDeploysPost(orgId, appId, envId, deploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * @summary Rebase to a different Deployment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} body The Deployment ID to rebase to.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId: string, appId: string, envId: string, body: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdFromDeployIdPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment in an Application.
     * @summary Get a specific Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned in an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Active Resources.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} type The Resource Type.  
     * @param {string} resId The Resource ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId: string, appId: string, envId: string, type: string, resId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdResourcesTypeResIdDelete(orgId, appId, envId, type, resId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Automation Rules in an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Create a new Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId: string, appId: string, envId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesPost(orgId, appId, envId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Automation Rule from an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdDelete(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId: string, appId: string, envId: string, ruleId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdGet(orgId, appId, envId, ruleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * @summary Update an existing Automation Rule for an Environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} ruleId The Automation Rule ID.  
     * @param {AutomationRuleRequest} automationRuleRequest The definition of the Automation Rule.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId: string, appId: string, envId: string, ruleId: string, automationRuleRequest: AutomationRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRulesRuleIdPut(orgId, appId, envId, ruleId, automationRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all of the Environments in the Application.
     * @summary List all Environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * @summary Add a new Environment to an Application.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {EnvironmentDefinitionRequest} environmentDefinitionRequest The ID, Name, Type, and Deployment the Environment will be derived from.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdEnvsPost(orgId: string, appId: string, environmentDefinitionRequest: EnvironmentDefinitionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsPost(orgId, appId, environmentDefinitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * @summary Get an existing Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes all Jobs for the Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdJobsDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdJobsDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {string} sourceSetId ID of the Deployment Set to diff against.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {UserRoleRequest} userRoleRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Webhooks
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdDelete(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId: string, appId: string, jobId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdGet(orgId, appId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} jobId The Webhook ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId: string, appId: string, jobId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksJobIdPost(orgId, appId, jobId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Webhook
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {WebhookRequest} webhookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsAppIdWebhooksPost(orgId: string, appId: string, webhookRequest: WebhookRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsAppIdWebhooksPost(orgId, appId, webhookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * @summary List all Applications in an Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * @summary Add a new Application to an Organization
     * @param {string} orgId The Organization ID.  
     * @param {ApplicationRequest} applicationRequest The request ID and Human-friendly name of the Application.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdAppsPost(orgId: string, applicationRequest: ApplicationRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdAppsPost(orgId, applicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts Versions.
     * @param {string} orgId The organization ID.  
     * @param {string} [name] (Optional) Filter Artefact Versions by name.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by the reference to a Version of the same Artefact. This cannot be used together with &#x60;name&#x60;.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsGet(orgId: string, name?: string, reference?: string, archived?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsGet(orgId, name, reference, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Artefact Version with your organization.
     * @param {string} orgId The organization ID.  
     * @param {AddArtefactVersionPayloadRequest} addArtefactVersionPayloadRequest The data needed to register a new Artefact Version within the organization.  
     * @param {string} [vcs] (Optional) Which version control system the version comes from. Default value is \&quot;git\&quot;. If this parameter is not supplied or its value is \&quot;git\&quot;, the provided ref, if not empty, is checked to ensure that it has one prefix among \&quot;refs/heads/\&quot; or \&quot;refs/tags/\&quot;.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactVersionsPost(orgId: string, addArtefactVersionPayloadRequest: AddArtefactVersionPayloadRequest, vcs?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactVersionsPost(orgId, addArtefactVersionPayloadRequest, vcs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * @summary Delete Artefact and all related Artefact Versions
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdDelete(orgId: string, artefactId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdDelete(orgId, artefactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefact Versions of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} [archived] (Optional) Filter for non-archived Artefact Versions. If no filter is defined all Artefact Versions are returned.  
     * @param {string} [reference] (Optional) Filter Artefact Versions by by name including a version or digest.  
     * @param {string} [limit] (Optional) Limit the number of versions returned by the endpoint.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsGet(orgId: string, artefactId: string, archived?: string, reference?: string, limit?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsGet(orgId, artefactId, archived, reference, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * @summary Update Version of an Artefact.
     * @param {string} orgId The organization ID.  
     * @param {string} artefactId The Artefact ID.  
     * @param {string} versionId The Version ID.  
     * @param {UpdateArtefactVersionPayloadRequest} updateArtefactVersionPayloadRequest The Artefact Version Update Request. Only the field &#x60;archive&#x60; can be updated.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId: string, artefactId: string, versionId: string, updateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsArtefactIdVersionsVersionIdPatch(orgId, artefactId, versionId, updateArtefactVersionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * @summary List all Artefacts.
     * @param {string} orgId The organization ID.  
     * @param {string} [type] (Optional) Filter Artefacts by type.  
     * @param {string} [name] (Optional) Filter Artefacts by name.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdArtefactsGet(orgId: string, type?: string, name?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdArtefactsGet(orgId, type, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envType The Environment Type.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * @summary Deletes an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdDelete(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdDelete(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * @summary Get an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envTypeId ID of the Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesEnvTypeIdGet(orgId: string, envTypeId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesEnvTypeIdGet(orgId, envTypeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all Environment Types in an Organization.
     * @summary List all Environment Types
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * @summary Add a new Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {EnvironmentTypeRequest} environmentTypeRequest New Environment Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEnvTypesPost(orgId: string, environmentTypeRequest: EnvironmentTypeRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEnvTypesPost(orgId, environmentTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Events
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdEventsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdEventsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the specified Organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * @summary List all Container Images
     * @param {string} orgId The organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * @summary Lists all the Builds of an Image
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * @summary Add a new Image Build
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {ImageBuildRequest} imageBuildRequest The metadata associated with the build.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdBuildsPost(orgId: string, imageId: string, imageBuildRequest: ImageBuildRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdBuildsPost(orgId, imageId, imageBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * @summary Get a specific Image Object
     * @param {string} orgId The organization ID.  
     * @param {string} imageId The Image ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdImagesImageIdGet(orgId: string, imageId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdImagesImageIdGet(orgId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {string} orgId The Organization ID.  
     * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {RegistryRequest} registryRequest A new record details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {RegistryRequest} registryRequest Record details to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Account Types available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {string} orgId The Organization ID.  
     * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
     * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Resources Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resources Driver ID to delete.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdDelete(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdDelete(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * @summary Get a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdGet(orgId: string, driverId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdGet(orgId, driverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {string} driverId The Resource Driver ID.  
     * @param {UpdateDriverRequestRequest} updateDriverRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversDriverIdPut(orgId: string, driverId: string, updateDriverRequestRequest: UpdateDriverRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversDriverIdPut(orgId, driverId, updateDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Drivers.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new Resource Driver.
     * @param {string} orgId The Organization ID.  
     * @param {CreateDriverRequestRequest} createDriverRequestRequest Resources Driver details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesDriversPost(orgId: string, createDriverRequestRequest: CreateDriverRequestRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesDriversPost(orgId, createDriverRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Types.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {string} orgId The Organization ID.  
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload Profile ID.  
     * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {string} version The Version.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The Workload profile qualified ID.  
     * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {string} tokenId The token ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).tokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return PublicApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistryApi - axios parameter creator
 * @export
 */
export const RegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost: async (orgId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'orgId', orgId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesPost', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdCredsGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}/creds`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdDelete', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet: async (orgId: string, regId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdGet', 'regId', regId)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch: async (orgId: string, regId: string, registryRequest: RegistryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'orgId', orgId)
            // verify required parameter 'regId' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'regId', regId)
            // verify required parameter 'registryRequest' is not null or undefined
            assertParamExists('orgsOrgIdRegistriesRegIdPatch', 'registryRequest', registryRequest)
            const localVarPath = `/orgs/{orgId}/registries/{regId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"regId"}}`, encodeURIComponent(String(regId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistryApi - functional programming interface
 * @export
 */
export const RegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesPost(orgId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdGet(orgId, regId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistryApi - factory interface
 * @export
 */
export const RegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistryApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists available registries for the organization.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesGet(orgId: string, options?: any): AxiosPromise<Array<RegistryResponse>> {
            return localVarFp.orgsOrgIdRegistriesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {RegistryRequest} registryRequest A new record details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns current account credentials or secret details for the registry.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryCredsResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * _Deletions are currently irreversible._
         * @summary Deletes an existing registry record and all associated credentials and secrets.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Loads a registry record details.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates (patches) an existing registry record.
         * @param {string} orgId Unique (alpha-numerical) organization identifier.  
         * @param {string} regId Unique (alpha-numerical) registry identifier.  
         * @param {RegistryRequest} registryRequest Record details to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: any): AxiosPromise<RegistryResponse> {
            return localVarFp.orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistryApi - object-oriented interface
 * @export
 * @class RegistryApi
 * @extends {BaseAPI}
 */
export class RegistryApi extends BaseAPI {
    /**
     * 
     * @summary Lists available registries for the organization.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesGet(orgId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {RegistryRequest} registryRequest A new record details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesPost(orgId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesPost(orgId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns current account credentials or secret details for the registry.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdCredsGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdCredsGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * _Deletions are currently irreversible._
     * @summary Deletes an existing registry record and all associated credentials and secrets.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdDelete(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdDelete(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Loads a registry record details.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdGet(orgId: string, regId: string, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdGet(orgId, regId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates (patches) an existing registry record.
     * @param {string} orgId Unique (alpha-numerical) organization identifier.  
     * @param {string} regId Unique (alpha-numerical) registry identifier.  
     * @param {RegistryRequest} registryRequest Record details to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistryApi
     */
    public orgsOrgIdRegistriesRegIdPatch(orgId: string, regId: string, registryRequest: RegistryRequest, options?: AxiosRequestConfig) {
        return RegistryApiFp(this.configuration).orgsOrgIdRegistriesRegIdPatch(orgId, regId, registryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceAccountApi - axios parameter creator
 * @export
 */
export const ResourceAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet: async (orgId: string, accId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdGet', 'accId', accId)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch: async (orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'orgId', orgId)
            // verify required parameter 'accId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'accId', accId)
            // verify required parameter 'updateResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsAccIdPatch', 'updateResourceAccountRequestRequest', updateResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts/{accId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"accId"}}`, encodeURIComponent(String(accId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost: async (orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'orgId', orgId)
            // verify required parameter 'createResourceAccountRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesAccountsPost', 'createResourceAccountRequestRequest', createResourceAccountRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/accounts`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceAccountRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceAccountApi - functional programming interface
 * @export
 */
export const ResourceAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceAccountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceAccountApi - factory interface
 * @export
 */
export const ResourceAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Account.
         * @param {string} orgId The Organization ID.  
         * @param {string} accId The Resource Account ID.  
         * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Resource Accounts in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsGet(orgId: string, options?: any): AxiosPromise<Array<ResourceAccountResponse>> {
            return localVarFp.orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Account in the organization.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: any): AxiosPromise<ResourceAccountResponse> {
            return localVarFp.orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceAccountApi - object-oriented interface
 * @export
 * @class ResourceAccountApi
 * @extends {BaseAPI}
 */
export class ResourceAccountApi extends BaseAPI {
    /**
     * 
     * @summary Get a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdGet(orgId: string, accId: string, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdGet(orgId, accId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Account.
     * @param {string} orgId The Organization ID.  
     * @param {string} accId The Resource Account ID.  
     * @param {UpdateResourceAccountRequestRequest} updateResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsAccIdPatch(orgId: string, accId: string, updateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsAccIdPatch(orgId, accId, updateResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Resource Accounts in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsGet(orgId: string, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Account in the organization.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceAccountRequestRequest} createResourceAccountRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceAccountApi
     */
    public orgsOrgIdResourcesAccountsPost(orgId: string, createResourceAccountRequestRequest: CreateResourceAccountRequestRequest, options?: AxiosRequestConfig) {
        return ResourceAccountApiFp(this.configuration).orgsOrgIdResourcesAccountsPost(orgId, createResourceAccountRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceDefinitionApi - axios parameter creator
 * @export
 */
export const ResourceDefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete: async (orgId: string, defId: string, criteriaId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'defId', defId)
            // verify required parameter 'criteriaId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete', 'criteriaId', criteriaId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)))
                .replace(`{${"criteriaId"}}`, encodeURIComponent(String(criteriaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost: async (orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'defId', defId)
            // verify required parameter 'matchingCriteriaRuleRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdCriteriaPost', 'matchingCriteriaRuleRequest', matchingCriteriaRuleRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/criteria`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(matchingCriteriaRuleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete: async (orgId: string, defId: string, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdDelete', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch: async (orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'defId', defId)
            // verify required parameter 'updateResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdPatch', 'updateResourceDefinitionRequestRequest', updateResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet: async (orgId: string, defId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'orgId', orgId)
            // verify required parameter 'defId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsDefIdResourcesGet', 'defId', defId)
            const localVarPath = `/orgs/{orgId}/resources/defs/{defId}/resources`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"defId"}}`, encodeURIComponent(String(defId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet: async (orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (env !== undefined) {
                localVarQueryParameter['env'] = env;
            }

            if (envType !== undefined) {
                localVarQueryParameter['env_type'] = envType;
            }

            if (res !== undefined) {
                localVarQueryParameter['res'] = res;
            }

            if (resType !== undefined) {
                localVarQueryParameter['res_type'] = resType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost: async (orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'orgId', orgId)
            // verify required parameter 'createResourceDefinitionRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdResourcesDefsPost', 'createResourceDefinitionRequestRequest', createResourceDefinitionRequestRequest)
            const localVarPath = `/orgs/{orgId}/resources/defs`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createResourceDefinitionRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceDefinitionApi - functional programming interface
 * @export
 */
export const ResourceDefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceDefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchingCriteriaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveResourceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceDefinitionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceDefinitionApi - factory interface
 * @export
 */
export const ResourceDefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceDefinitionApiFp(configuration)
    return {
        /**
         * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
         * @summary Delete a Matching Criteria from a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {string} criteriaId The Matching Criteria ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
         * @summary Add a new Matching Criteria to a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: any): AxiosPromise<MatchingCriteriaResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
         * @summary Delete a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Active Resources provisioned via a specific Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {string} defId The Resource Definition ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: any): AxiosPromise<Array<ActiveResourceResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
         * @summary List Resource Definitions.
         * @param {string} orgId The Organization ID.  
         * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
         * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
         * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
         * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
         * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: any): AxiosPromise<Array<ResourceDefinitionResponse>> {
            return localVarFp.orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Resource Definition.
         * @param {string} orgId The Organization ID.  
         * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: any): AxiosPromise<ResourceDefinitionResponse> {
            return localVarFp.orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceDefinitionApi - object-oriented interface
 * @export
 * @class ResourceDefinitionApi
 * @extends {BaseAPI}
 */
export class ResourceDefinitionApi extends BaseAPI {
    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * @summary Delete a Matching Criteria from a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {string} criteriaId The Matching Criteria ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, the Matching Criteria is deleted immediately, even if this action affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId: string, defId: string, criteriaId: string, force?: boolean, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaCriteriaIdDelete(orgId, defId, criteriaId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that time was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resources definitions matching the criteria: #1 & #3. Definition #3 will be chosen because it\'s matching criteria is the most specific.
     * @summary Add a new Matching Criteria to a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {MatchingCriteriaRuleRequest} matchingCriteriaRuleRequest Matching Criteria rules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId: string, defId: string, matchingCriteriaRuleRequest: MatchingCriteriaRuleRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdCriteriaPost(orgId, defId, matchingCriteriaRuleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is **marked as** pending deletion and will be deleted (purged) as soon as no existing Active Resources reference it. With the next deployment matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).  The Resource Definition that has been marked for deletion cannot be used to provision new resources.
     * @summary Delete a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {boolean} [force] If set to &#x60;true&#x60;, will mark the Resource Definition for deletion, even if it affects existing Active Resources.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdDelete(orgId: string, defId: string, force?: boolean, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdDelete(orgId, defId, force, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {UpdateResourceDefinitionRequestRequest} updateResourceDefinitionRequestRequest The Resource Definition record details.  The PATCH operation would change the value of the property if it is included in the request payload JSON, and not &#x60;null&#x60;. Missing and &#x60;null&#x60; properties are ignored.  For the map properties, such as UpdateResourceDefinitionRequest.DriverInputs, the merge operation is applied.  Merge rules are as follows:  - If a map property has a value, it is replaced (or added).  - If a map property is set to &#x60;null&#x60;, it is removed.  - If a map property is not included (missing in JSON), it remains unchanged.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdPatch(orgId: string, defId: string, updateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdPatch(orgId, defId, updateResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Active Resources provisioned via a specific Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {string} defId The Resource Definition ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsDefIdResourcesGet(orgId: string, defId: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsDefIdResourcesGet(orgId, defId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank.
     * @summary List Resource Definitions.
     * @param {string} orgId The Organization ID.  
     * @param {string} [app] (Optional) Filter Resource Definitions that may match a specific Application.  
     * @param {string} [env] (Optional) Filter Resource Definitions that may match a specific Environment.  
     * @param {string} [envType] (Optional) Filter Resource Definitions that may match a specific Environment Type.  
     * @param {string} [res] (Optional) Filter Resource Definitions that may match a specific Resource.  
     * @param {string} [resType] (Optional) Filter Resource Definitions that may match a specific Resource Type.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsGet(orgId: string, app?: string, env?: string, envType?: string, res?: string, resType?: string, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsGet(orgId, app, env, envType, res, resType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Resource Definition.
     * @param {string} orgId The Organization ID.  
     * @param {CreateResourceDefinitionRequestRequest} createResourceDefinitionRequestRequest The Resource Definition details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceDefinitionApi
     */
    public orgsOrgIdResourcesDefsPost(orgId: string, createResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest, options?: AxiosRequestConfig) {
        return ResourceDefinitionApiFp(this.configuration).orgsOrgIdResourcesDefsPost(orgId, createResourceDefinitionRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceTypeApi - axios parameter creator
 * @export
 */
export const ResourceTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdResourcesTypesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/resources/types`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceTypeApi - functional programming interface
 * @export
 */
export const ResourceTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceTypeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdResourcesTypesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceTypeApi - factory interface
 * @export
 */
export const ResourceTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceTypeApiFp(configuration)
    return {
        /**
         * 
         * @summary List Resource Types.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdResourcesTypesGet(orgId: string, options?: any): AxiosPromise<Array<ResourceTypeResponse>> {
            return localVarFp.orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceTypeApi - object-oriented interface
 * @export
 * @class ResourceTypeApi
 * @extends {BaseAPI}
 */
export class ResourceTypeApi extends BaseAPI {
    /**
     * 
     * @summary List Resource Types.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceTypeApi
     */
    public orgsOrgIdResourcesTypesGet(orgId: string, options?: AxiosRequestConfig) {
        return ResourceTypeApiFp(this.configuration).orgsOrgIdResourcesTypesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuntimeInfoApi - axios parameter creator
 * @export
 */
export const RuntimeInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut: async (orgId: string, appId: string, envId: string, body: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'envId', envId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut', 'body', body)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch: async (orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'envId', envId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch', 'requestBody', requestBody)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet: async (orgId: string, appId: string, id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdRuntimeGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/runtime`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuntimeInfoApi - functional programming interface
 * @export
 */
export const RuntimeInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuntimeInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuntimeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentRuntimeInfoResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuntimeInfoApi - factory interface
 * @export
 */
export const RuntimeInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuntimeInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Runtime information about the environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<RuntimeInfoResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
         * @summary Pause / Resume an environment.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set number of replicas for an environment\'s modules.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Runtime information about specific environments.
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: any): AxiosPromise<Array<EnvironmentRuntimeInfoResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RuntimeInfoApi - object-oriented interface
 * @export
 * @class RuntimeInfoApi
 * @extends {BaseAPI}
 */
export class RuntimeInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Runtime information about the environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas.  On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused.  When an environment is paused, it is not possible to:  ```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * @summary Pause / Resume an environment.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {boolean} body If the value is &#x60;true&#x60; the request is to pause an environment, if it is &#x60;false&#x60; is to resume an environment.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId: string, appId: string, envId: string, body: boolean, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimePausedPut(orgId, appId, envId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set number of replicas for an environment\'s modules.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {{ [key: string]: number; }} requestBody map of replicas by modules.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId: string, appId: string, envId: string, requestBody: { [key: string]: number; }, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdRuntimeReplicasPatch(orgId, appId, envId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Runtime information about specific environments.
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [id] Filter environments by ID (required). Up to 5 ids can be supplied per request.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuntimeInfoApi
     */
    public orgsOrgIdAppsAppIdRuntimeGet(orgId: string, appId: string, id?: string, options?: AxiosRequestConfig) {
        return RuntimeInfoApiFp(this.configuration).orgsOrgIdAppsAppIdRuntimeGet(orgId, appId, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SetApi - axios parameter creator
 * @export
 */
export const SetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet: async (orgId: string, appId: string, setId: string, sourceSetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'setId', setId)
            // verify required parameter 'sourceSetId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet', 'sourceSetId', sourceSetId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)))
                .replace(`{${"sourceSetId"}}`, encodeURIComponent(String(sourceSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet: async (orgId: string, appId: string, setId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdGet', 'setId', setId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost: async (orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'appId', appId)
            // verify required parameter 'setId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'setId', setId)
            // verify required parameter 'deltaRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdSetsSetIdPost', 'deltaRequest', deltaRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/sets/{setId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"setId"}}`, encodeURIComponent(String(setId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deltaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SetApi - functional programming interface
 * @export
 */
export const SetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeltaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SetApi - factory interface
 * @export
 */
export const SetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SetApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the difference between 2 Deployment Sets
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {string} sourceSetId ID of the Deployment Set to diff against.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: any): AxiosPromise<SetResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Apply a Deployment Delta to a Deployment Set
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} setId ID of the Deployment Set.  
         * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: any): AxiosPromise<DeltaResponse> {
            return localVarFp.orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SetApi - object-oriented interface
 * @export
 * @class SetApi
 * @extends {BaseAPI}
 */
export class SetApi extends BaseAPI {
    /**
     * 
     * @summary Get the difference between 2 Deployment Sets
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {string} sourceSetId ID of the Deployment Set to diff against.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId: string, appId: string, setId: string, sourceSetId: string, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdDiffSourceSetIdGet(orgId, appId, setId, sourceSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdGet(orgId: string, appId: string, setId: string, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdGet(orgId, appId, setId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Apply a Deployment Delta to a Deployment Set
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} setId ID of the Deployment Set.  
     * @param {DeltaRequest} deltaRequest The Delta to apply to the Set.  NOTE: The &#x60;id&#x60; parameter is ignored if provided. The request body should be the full Delta.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SetApi
     */
    public orgsOrgIdAppsAppIdSetsSetIdPost(orgId: string, appId: string, setId: string, deltaRequest: DeltaRequest, options?: AxiosRequestConfig) {
        return SetApiFp(this.configuration).orgsOrgIdAppsAppIdSetsSetIdPost(orgId, appId, setId, deltaRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserInviteApi - axios parameter creator
 * @export
 */
export const UserInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInviteApi - functional programming interface
 * @export
 */
export const UserInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserInviteApi - factory interface
 * @export
 */
export const UserInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInviteApiFp(configuration)
    return {
        /**
         * 
         * @summary List the invites issued for the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsGet(orgId: string, options?: any): AxiosPromise<Array<UserInviteResponse>> {
            return localVarFp.orgsOrgIdInvitationsGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserInviteApi - object-oriented interface
 * @export
 * @class UserInviteApi
 * @extends {BaseAPI}
 */
export class UserInviteApi extends BaseAPI {
    /**
     * 
     * @summary List the invites issued for the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInviteApi
     */
    public orgsOrgIdInvitationsGet(orgId: string, options?: AxiosRequestConfig) {
        return UserInviteApiFp(this.configuration).orgsOrgIdInvitationsGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserProfileApi - axios parameter creator
 * @export
 */
export const UserProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch: async (userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('currentUserPatch', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost: async (orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'orgId', orgId)
            // verify required parameter 'userProfileExtendedRequest' is not null or undefined
            assertParamExists('orgsOrgIdUsersPost', 'userProfileExtendedRequest', userProfileExtendedRequest)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileExtendedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete: async (tokenId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokensTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserProfileApi - functional programming interface
 * @export
 */
export const UserProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserPatch(userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileExtendedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensTokenIdDelete(tokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserProfileApi - factory interface
 * @export
 */
export const UserProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the extended profile of the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGet(options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the extended profile of the current user.
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.currentUserPatch(userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service user.
         * @param {string} orgId The Organization ID.  
         * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: any): AxiosPromise<UserProfileExtendedResponse> {
            return localVarFp.orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {string} tokenId The token ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensTokenIdDelete(tokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.tokensTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DEPRECATED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserProfileApi - object-oriented interface
 * @export
 * @class UserProfileApi
 * @extends {BaseAPI}
 */
export class UserProfileApi extends BaseAPI {
    /**
     * 
     * @summary Gets the extended profile of the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the extended profile of the current user.
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public currentUserPatch(userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).currentUserPatch(userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service user.
     * @param {string} orgId The Organization ID.  
     * @param {UserProfileExtendedRequest} userProfileExtendedRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public orgsOrgIdUsersPost(orgId: string, userProfileExtendedRequest: UserProfileExtendedRequest, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).orgsOrgIdUsersPost(orgId, userProfileExtendedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {string} tokenId The token ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public tokensTokenIdDelete(tokenId: string, options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).tokensTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary DEPRECATED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserProfileApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return UserProfileApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRoleApi - axios parameter creator
 * @export
 */
export const UserRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost: async (orgId: string, appId: string, userRoleRequest: UserRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'appId', appId)
            // verify required parameter 'userRoleRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersPost', 'userRoleRequest', userRoleRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet: async (orgId: string, appId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'appId', appId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet: async (orgId: string, envType: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'orgId', orgId)
            // verify required parameter 'envType' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'envType', envType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('orgsOrgIdEnvTypeEnvTypeUsersUserIdGet', 'userId', userId)
            const localVarPath = `/orgs/{orgId}/env-type/{envType}/users/{userId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"envType"}}`, encodeURIComponent(String(envType)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost: async (orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'orgId', orgId)
            // verify required parameter 'userInviteRequestRequest' is not null or undefined
            assertParamExists('orgsOrgIdInvitationsPost', 'userInviteRequestRequest', userInviteRequestRequest)
            const localVarPath = `/orgs/{orgId}/invitations`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInviteRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdUsersGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/users`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRoleApi - functional programming interface
 * @export
 */
export const UserRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRoleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdUsersGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRoleApi - factory interface
 * @export
 */
export const UserRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRoleApiFp(configuration)
    return {
        /**
         * 
         * @summary List Users with roles in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a User to an Application with a Role
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {UserRoleRequest} userRoleRequest The user ID and the role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the role of a User on an Environment Type
         * @param {string} orgId The Organization ID.  
         * @param {string} envType The Environment Type.  
         * @param {string} userId The User ID  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: any): AxiosPromise<UserRoleResponse> {
            return localVarFp.orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a user to an Organization with a specified role.
         * @param {string} orgId The Organization ID.  
         * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users with roles in an Organization
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdUsersGet(orgId: string, options?: any): AxiosPromise<Array<UserRoleResponse>> {
            return localVarFp.orgsOrgIdUsersGet(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserRoleApi - object-oriented interface
 * @export
 * @class UserRoleApi
 * @extends {BaseAPI}
 */
export class UserRoleApi extends BaseAPI {
    /**
     * 
     * @summary List Users with roles in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a User to an Application with a Role
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {UserRoleRequest} userRoleRequest The user ID and the role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersPost(orgId: string, appId: string, userRoleRequest: UserRoleRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersPost(orgId, appId, userRoleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdAppsAppIdUsersUserIdGet(orgId: string, appId: string, userId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdAppsAppIdUsersUserIdGet(orgId, appId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the role of a User on an Environment Type
     * @param {string} orgId The Organization ID.  
     * @param {string} envType The Environment Type.  
     * @param {string} userId The User ID  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId: string, envType: string, userId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdEnvTypeEnvTypeUsersUserIdGet(orgId, envType, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a user to an Organization with a specified role.
     * @param {string} orgId The Organization ID.  
     * @param {UserInviteRequestRequest} userInviteRequestRequest The email and the desired role  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdInvitationsPost(orgId: string, userInviteRequestRequest: UserInviteRequestRequest, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdInvitationsPost(orgId, userInviteRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users with roles in an Organization
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRoleApi
     */
    public orgsOrgIdUsersGet(orgId: string, options?: AxiosRequestConfig) {
        return UserRoleApiFp(this.configuration).orgsOrgIdUsersGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueApi - axios parameter creator
 * @export
 */
export const ValueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet: async (orgId: string, appId: string, envId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete: async (orgId: string, appId: string, envId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch: async (orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut: async (orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'envId', envId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost: async (orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'envId', envId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesDelete', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet: async (orgId: string, appId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete: async (orgId: string, appId: string, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyDelete', 'key', key)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch: async (orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'key', key)
            // verify required parameter 'valuePatchPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPatch', 'valuePatchPayloadRequest', valuePatchPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valuePatchPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut: async (orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'appId', appId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'key', key)
            // verify required parameter 'valueEditPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesKeyPut', 'valueEditPayloadRequest', valueEditPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueEditPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost: async (orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'appId', appId)
            // verify required parameter 'valueCreatePayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValuesPost', 'valueCreatePayloadRequest', valueCreatePayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/values`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueCreatePayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueApi - functional programming interface
 * @export
 */
export const ValueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueApiAxiosParamCreator(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueApi - factory interface
 * @export
 */
export const ValueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueApiFp(configuration)
    return {
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
         * @summary List Shared Values in an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Environment
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
         * @summary Delete all Shared Value for an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
         * @summary List Shared Values in an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: any): AxiosPromise<Array<ValueResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(axios, basePath));
        },
        /**
         * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
         * @summary Delete Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
         * @summary Update Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} key The key to update.  
         * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
         * @summary Create a Shared Value for an Application
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: any): AxiosPromise<ValueResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValueApi - object-oriented interface
 * @export
 * @class ValueApi
 * @extends {BaseAPI}
 */
export class ValueApi extends BaseAPI {
    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * @summary List Shared Values in an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId: string, appId: string, envId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(orgId, appId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId: string, appId: string, envId: string, key: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(orgId, appId, envId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId: string, appId: string, envId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(orgId, appId, envId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId: string, appId: string, envId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(orgId, appId, envId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Environment
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId: string, appId: string, envId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(orgId, appId, envId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * @summary Delete all Shared Value for an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesDelete(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesDelete(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * @summary List Shared Values in an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesGet(orgId: string, appId: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesGet(orgId, appId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * @summary Delete Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyDelete(orgId: string, appId: string, key: string, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyDelete(orgId, appId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValuePatchPayloadRequest} valuePatchPayloadRequest At least &#x60;value&#x60; or &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPatch(orgId: string, appId: string, key: string, valuePatchPayloadRequest: ValuePatchPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPatch(orgId, appId, key, valuePatchPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * @summary Update Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} key The key to update.  
     * @param {ValueEditPayloadRequest} valueEditPayloadRequest Both &#x60;value&#x60; and &#x60;description&#x60; must be supplied. All other fields will be ignored.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesKeyPut(orgId: string, appId: string, key: string, valueEditPayloadRequest: ValueEditPayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesKeyPut(orgId, appId, key, valueEditPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * @summary Create a Shared Value for an Application
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {ValueCreatePayloadRequest} valueCreatePayloadRequest Definition of the new Shared Value.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueApi
     */
    public orgsOrgIdAppsAppIdValuesPost(orgId: string, appId: string, valueCreatePayloadRequest: ValueCreatePayloadRequest, options?: AxiosRequestConfig) {
        return ValueApiFp(this.configuration).orgsOrgIdAppsAppIdValuesPost(orgId, appId, valueCreatePayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValueSetVersionApi - axios parameter creator
 * @export
 */
export const ValueSetVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet: async (orgId: string, appId: string, envId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet', 'envId', envId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'envId', envId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet: async (orgId: string, appId: string, keyChanged?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsGet', 'appId', appId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyChanged !== undefined) {
                localVarQueryParameter['key_changed'] = keyChanged;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet: async (orgId: string, appId: string, valueSetVersionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet', 'valueSetVersionId', valueSetVersionId)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost: async (orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'key', key)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost: async (orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'orgId', orgId)
            // verify required parameter 'appId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'appId', appId)
            // verify required parameter 'valueSetVersionId' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetVersionId', valueSetVersionId)
            // verify required parameter 'valueSetActionPayloadRequest' is not null or undefined
            assertParamExists('orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost', 'valueSetActionPayloadRequest', valueSetActionPayloadRequest)
            const localVarPath = `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"appId"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(valueSetVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(valueSetActionPayloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValueSetVersionApi - functional programming interface
 * @export
 */
export const ValueSetVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValueSetVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValueSetVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueSetVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValueSetVersionApi - factory interface
 * @export
 */
export const ValueSetVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValueSetVersionApiFp(configuration)
    return {
        /**
         * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
         * @summary List Value Set Versions in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an Environment of an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} envId The Environment ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A new Value Set Version is created on every modification of a Value inside the app.
         * @summary List Value Set Versions in the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: any): AxiosPromise<Array<ValueSetVersionResponse>> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Value Set Version from the App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purge the value of a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be purged.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a specific key Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {string} key Key of the value to be restored.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a Value Set Version in an App
         * @param {string} orgId The Organization ID.  
         * @param {string} appId The Application ID.  
         * @param {string} valueSetVersionId The ValueSetVersion ID.  
         * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: any): AxiosPromise<ValueSetVersionResponse> {
            return localVarFp.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValueSetVersionApi - object-oriented interface
 * @export
 * @class ValueSetVersionApi
 * @extends {BaseAPI}
 */
export class ValueSetVersionApi extends BaseAPI {
    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * @summary List Value Set Versions in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId: string, appId: string, envId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(orgId, appId, envId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, envId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(orgId, appId, envId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, envId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, envId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an Environment of an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} envId The Environment ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, envId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, envId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * @summary List Value Set Versions in the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} [keyChanged] (Optional) Return only value set version where the specified key changed  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsGet(orgId: string, appId: string, keyChanged?: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsGet(orgId, appId, keyChanged, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Value Set Version from the App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId: string, appId: string, valueSetVersionId: string, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(orgId, appId, valueSetVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purge the value of a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be purged.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a specific key Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {string} key Key of the value to be restored.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId: string, appId: string, valueSetVersionId: string, key: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(orgId, appId, valueSetVersionId, key, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a Value Set Version in an App
     * @param {string} orgId The Organization ID.  
     * @param {string} appId The Application ID.  
     * @param {string} valueSetVersionId The ValueSetVersion ID.  
     * @param {ValueSetActionPayloadRequest} valueSetActionPayloadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValueSetVersionApi
     */
    public orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId: string, appId: string, valueSetVersionId: string, valueSetActionPayloadRequest: ValueSetActionPayloadRequest, options?: AxiosRequestConfig) {
        return ValueSetVersionApiFp(this.configuration).orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(orgId, appId, valueSetVersionId, valueSetActionPayloadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkloadProfileApi - axios parameter creator
 * @export
 */
export const WorkloadProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet: async (orgId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesGet', 'orgId', orgId)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost: async (orgId: string, workloadProfileRequest: WorkloadProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'orgId', orgId)
            // verify required parameter 'workloadProfileRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesPost', 'workloadProfileRequest', workloadProfileRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete: async (orgId: string, profileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost: async (orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'profileId', profileId)
            // verify required parameter 'workloadProfileVersionRequest' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsPost', 'workloadProfileVersionRequest', workloadProfileVersionRequest)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workloadProfileVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete: async (orgId: string, profileId: string, version: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'orgId', orgId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'profileId', profileId)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete', 'version', version)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileId}/versions/{version}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet: async (orgId: string, profileQid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet: async (orgId: string, profileQid: string, version?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'orgId', orgId)
            // verify required parameter 'profileQid' is not null or undefined
            assertParamExists('orgsOrgIdWorkloadProfilesProfileQidVersionsGet', 'profileQid', profileQid)
            const localVarPath = `/orgs/{orgId}/workload-profiles/{profileQid}/versions`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"profileQid"}}`, encodeURIComponent(String(profileQid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkloadProfileApi - functional programming interface
 * @export
 */
export const WorkloadProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkloadProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesGet(orgId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkloadProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkloadProfileVersionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkloadProfileApi - factory interface
 * @export
 */
export const WorkloadProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkloadProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary List workload profiles available to the organization.
         * @param {string} orgId The Organization ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesGet(orgId: string, options?: any): AxiosPromise<Array<WorkloadProfileResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
         * @summary Delete a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
         * @summary Add new Version of the Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload Profile ID.  
         * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: any): AxiosPromise<WorkloadProfileVersionResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Workload Profile Version
         * @param {string} orgId The Organization ID.  
         * @param {string} profileId The Workload profile ID.  
         * @param {string} version The Version.  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: any): AxiosPromise<void> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Workload Profile
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: any): AxiosPromise<WorkloadProfileResponse> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List versions of the given workload profile with optional constraint.
         * @param {string} orgId The Organization ID.  
         * @param {string} profileQid The Workload profile qualified ID.  
         * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: any): AxiosPromise<Array<WorkloadProfileVersionResponse>> {
            return localVarFp.orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkloadProfileApi - object-oriented interface
 * @export
 * @class WorkloadProfileApi
 * @extends {BaseAPI}
 */
export class WorkloadProfileApi extends BaseAPI {
    /**
     * 
     * @summary List workload profiles available to the organization.
     * @param {string} orgId The Organization ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesGet(orgId: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesGet(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {WorkloadProfileRequest} workloadProfileRequest Workload profile details.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesPost(orgId: string, workloadProfileRequest: WorkloadProfileRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesPost(orgId, workloadProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * @summary Delete a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdDelete(orgId: string, profileId: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdDelete(orgId, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Workload Profile Version from the uploaded Helm chart. The version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes two parts:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  2. `metadata` with `application/json` content type which defines the version\'s metadata.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"metadata\"  Content-Type: application/json; charset=UTF-8  {    \"features\": {       \"humanitec/service\": {},       \"humanitec/volumes\": {},       \"custom\": {\"schema\": {}}    },    \"notes\": \"Notes related to this version of the profile\"  }  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary  **NOTE:**  A Workload Profile must be created before a version can be added to it.
     * @summary Add new Version of the Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload Profile ID.  
     * @param {WorkloadProfileVersionRequest} workloadProfileVersionRequest Workload profile version metadata.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId: string, profileId: string, workloadProfileVersionRequest: WorkloadProfileVersionRequest, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsPost(orgId, profileId, workloadProfileVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Workload Profile Version
     * @param {string} orgId The Organization ID.  
     * @param {string} profileId The Workload profile ID.  
     * @param {string} version The Version.  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId: string, profileId: string, version: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileIdVersionsVersionDelete(orgId, profileId, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Workload Profile
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The fully qualified Workload ID. (If not a profile from the current org, must be prefixed with &#x60;{orgId}.&#x60; e.g. &#x60;humanitec.default-cronjob&#x60;)  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidGet(orgId: string, profileQid: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidGet(orgId, profileQid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List versions of the given workload profile with optional constraint.
     * @param {string} orgId The Organization ID.  
     * @param {string} profileQid The Workload profile qualified ID.  
     * @param {string} [version] Optional query parameter, defines version constraint pattern (https://github.com/Masterminds/semver#checking-version-constraints).  
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkloadProfileApi
     */
    public orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId: string, profileQid: string, version?: string, options?: AxiosRequestConfig) {
        return WorkloadProfileApiFp(this.configuration).orgsOrgIdWorkloadProfilesProfileQidVersionsGet(orgId, profileQid, version, options).then((request) => request(this.axios, this.basePath));
    }
}


