/* tslint:disable */
/* eslint-disable */
/**
 * Humanitec API
 * # Introduction The *Humanitec API* allows you to automate and integrate Humanitec into your developer and operational workflows. The API is a REST based API. It is based around a set of concepts:  * Core * External Resources * Sets and Deltas  ## Authentication  Almost all requests made to the Humanitec API require Authentication. See our [Developer Docs on API Authentication](https://developer.humanitec.com/platform-orchestrator/reference/api-references/#authentication) for instructions.  ## Content Types The Humanitec API, unless explicitly specified, only accepts content types of `application/json` and will always return valid `application/json` or an empty response.  ## Response Codes ### Success Any response code in the `2xx` range should be regarded as success.  | **Code** | **Meaning**                         | |----------|-------------------------------------| | `200`    | Success                             | | `201`    | Success, a new resource was created | | `204`    | Success, but no content in response |  _Note: We plan to simplify the interface by replacing 201 with 200 status codes._  ### Failure Any response code in the `4xx` range should be regarded as an error that can be rectified by the client. `5xx` error codes indicate errors that cannot be corrected by the client.  | **Code** | **Meaning**                                                                                                           | |----------|-----------------------------------------------------------------------------------------------------------------------| | `400`    | General error. (Body will contain details)                                                                            | | `401`    | Attempt to access protected resource without `Authorization` Header.                                                  | | `403`    | The `Bearer` or `JWT` does not grant access to the requested resource.                                                | | `404`    | Resource not found.                                                                                                   | | `405`    | Method not allowed                                                                                                    | | `409`    | Conflict. Usually indicated a resource with that ID already exists.                                                   | | `422`    | Unprocessable Entity. The body was not valid JSON, was empty or contained an object different from what was expected. | | `429`    | Too many requests - request rate limit has been reached.                                                              | | `500`    | Internal Error. If it occurs repeatedly, contact support.                                                             | 
 *
 * The version of the OpenAPI document: 0.28.4
 * Contact: support@humanitec.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  AccountTypeResponse,
  ActiveResourceResponse,
  ActiveResourceTargetDefinitionRequest,
  Agent,
  AgentCreateBody,
  AgentPatchBody,
  ApplicationCreationRequest,
  ApplicationPatchPayload,
  ApplicationResponse,
  ArchiveDefinitionVersionRequest,
  ArtefactResponse,
  ArtefactVersion,
  AuditLogEntry,
  AutomationRuleRequest,
  AutomationRuleResponse,
  Batch,
  CheckResourceAccountData,
  ClusterConnectionCheckRequest,
  ClusterConnectionCheckResult,
  ConflictingResourcesErrorResponse,
  ConvertScoreToSetBody,
  CreateArtefactVersion,
  CreateDelta200Response,
  CreateDriverRequestRequest,
  CreateResourceAccountRequestRequest,
  CreateResourceDefinitionRequestRequest,
  CreateSecretStorePayloadRequest,
  DeltaRequest,
  DeltaResponse,
  DependencyGraphResponse,
  DeploymentErrorResponse,
  DeploymentRequest,
  DeploymentResponse,
  DriverDefinitionResponse,
  EnvironmentBaseUpdateRequest,
  EnvironmentDefinitionRequest,
  EnvironmentResponse,
  EnvironmentRuntimeInfoResponse,
  EnvironmentTypeRequest,
  EnvironmentTypeResponse,
  ErrorInfoResponse,
  ErrorResponse,
  EventResponse,
  GetSet200Response,
  Group,
  GroupRequest,
  GroupWithRole,
  HumanitecErrorResponse,
  HumanitecPublicKey,
  ImageBuildRequest,
  ImageBuildResponse,
  ImageResponse,
  Key,
  KeyCreateBody,
  MatchingCriteriaResponse,
  MatchingCriteriaRuleRequest,
  NewServiceUserRequest,
  NodeBodyResponse,
  OrganizationResponse,
  OutputEntryResponse,
  PatchResourceDefinitionRequestRequest,
  Pipeline,
  PipelineApprovalRequest,
  PipelineCriteria,
  PipelineCriteriaCreateBody,
  PipelineJob,
  PipelineJobPartial,
  PipelineRun,
  PipelineRunCreateBody,
  PipelineRunCreateByTriggerCriteriaBody,
  PipelineStepLog,
  PipelineVersion,
  PlainDeltaResponse,
  PublicKey,
  RegistryCredsResponse,
  RegistryRequest,
  RegistryResponse,
  ResourceAccountResponse,
  ResourceClassRequest,
  ResourceClassResponse,
  ResourceDefinitionChangeResponse,
  ResourceDefinitionResponse,
  ResourceDefinitionVersion,
  ResourceInputsResponse,
  ResourceProvisionRequestRequest,
  ResourceTypeResponse,
  RoleRequest,
  RuntimeInfoResponseV1,
  RuntimeInfoResponseV2,
  SecretStoreResponse,
  SetResponse,
  SubjectTypeEnum,
  TokenDefinitionRequest,
  TokenInfoResponse,
  TokenResponse,
  UpdateArtefactVersionPayloadRequest,
  UpdateDriverRequestRequest,
  UpdateEnvironmentTypePayloadRequest,
  UpdateResourceAccountRequestRequest,
  UpdateResourceClassRequest,
  UpdateResourceDefinitionRequestRequest,
  UpdateSecretStorePayloadRequest,
  UserInviteRequestRequest,
  UserInviteResponse,
  UserProfileExtendedRequest,
  UserProfileExtendedResponse,
  UserProfileResponse,
  UserRoleRequest,
  UserRoleResponse,
  ValueCreatePayloadRequest,
  ValueEditPayloadRequest,
  ValuePatchPayloadRequest,
  ValueResponse,
  ValueSetActionPayloadRequest,
  ValueSetVersionResponse,
  WebhookRequest,
  WebhookResponse,
  WebhookUpdateResponse,
  WorkloadArtefactVersionDeploymentSet,
  WorkloadProfileChartVersionResponse,
  WorkloadProfileFeatureResponse,
  WorkloadProfileRequest,
  WorkloadProfileResponse,
  WorkloadProfileUpdateRequest,
  WorkloadProfileVersionResponse,
} from '../models/index.js';
import {
    AccountTypeResponseFromJSON,
    AccountTypeResponseToJSON,
    ActiveResourceResponseFromJSON,
    ActiveResourceResponseToJSON,
    ActiveResourceTargetDefinitionRequestFromJSON,
    ActiveResourceTargetDefinitionRequestToJSON,
    AgentFromJSON,
    AgentToJSON,
    AgentCreateBodyFromJSON,
    AgentCreateBodyToJSON,
    AgentPatchBodyFromJSON,
    AgentPatchBodyToJSON,
    ApplicationCreationRequestFromJSON,
    ApplicationCreationRequestToJSON,
    ApplicationPatchPayloadFromJSON,
    ApplicationPatchPayloadToJSON,
    ApplicationResponseFromJSON,
    ApplicationResponseToJSON,
    ArchiveDefinitionVersionRequestFromJSON,
    ArchiveDefinitionVersionRequestToJSON,
    ArtefactResponseFromJSON,
    ArtefactResponseToJSON,
    ArtefactVersionFromJSON,
    ArtefactVersionToJSON,
    AuditLogEntryFromJSON,
    AuditLogEntryToJSON,
    AutomationRuleRequestFromJSON,
    AutomationRuleRequestToJSON,
    AutomationRuleResponseFromJSON,
    AutomationRuleResponseToJSON,
    BatchFromJSON,
    BatchToJSON,
    CheckResourceAccountDataFromJSON,
    CheckResourceAccountDataToJSON,
    ClusterConnectionCheckRequestFromJSON,
    ClusterConnectionCheckRequestToJSON,
    ClusterConnectionCheckResultFromJSON,
    ClusterConnectionCheckResultToJSON,
    ConflictingResourcesErrorResponseFromJSON,
    ConflictingResourcesErrorResponseToJSON,
    ConvertScoreToSetBodyFromJSON,
    ConvertScoreToSetBodyToJSON,
    CreateArtefactVersionFromJSON,
    CreateArtefactVersionToJSON,
    CreateDelta200ResponseFromJSON,
    CreateDelta200ResponseToJSON,
    CreateDriverRequestRequestFromJSON,
    CreateDriverRequestRequestToJSON,
    CreateResourceAccountRequestRequestFromJSON,
    CreateResourceAccountRequestRequestToJSON,
    CreateResourceDefinitionRequestRequestFromJSON,
    CreateResourceDefinitionRequestRequestToJSON,
    CreateSecretStorePayloadRequestFromJSON,
    CreateSecretStorePayloadRequestToJSON,
    DeltaRequestFromJSON,
    DeltaRequestToJSON,
    DeltaResponseFromJSON,
    DeltaResponseToJSON,
    DependencyGraphResponseFromJSON,
    DependencyGraphResponseToJSON,
    DeploymentErrorResponseFromJSON,
    DeploymentErrorResponseToJSON,
    DeploymentRequestFromJSON,
    DeploymentRequestToJSON,
    DeploymentResponseFromJSON,
    DeploymentResponseToJSON,
    DriverDefinitionResponseFromJSON,
    DriverDefinitionResponseToJSON,
    EnvironmentBaseUpdateRequestFromJSON,
    EnvironmentBaseUpdateRequestToJSON,
    EnvironmentDefinitionRequestFromJSON,
    EnvironmentDefinitionRequestToJSON,
    EnvironmentResponseFromJSON,
    EnvironmentResponseToJSON,
    EnvironmentRuntimeInfoResponseFromJSON,
    EnvironmentRuntimeInfoResponseToJSON,
    EnvironmentTypeRequestFromJSON,
    EnvironmentTypeRequestToJSON,
    EnvironmentTypeResponseFromJSON,
    EnvironmentTypeResponseToJSON,
    ErrorInfoResponseFromJSON,
    ErrorInfoResponseToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    EventResponseFromJSON,
    EventResponseToJSON,
    GetSet200ResponseFromJSON,
    GetSet200ResponseToJSON,
    GroupFromJSON,
    GroupToJSON,
    GroupRequestFromJSON,
    GroupRequestToJSON,
    GroupWithRoleFromJSON,
    GroupWithRoleToJSON,
    HumanitecErrorResponseFromJSON,
    HumanitecErrorResponseToJSON,
    HumanitecPublicKeyFromJSON,
    HumanitecPublicKeyToJSON,
    ImageBuildRequestFromJSON,
    ImageBuildRequestToJSON,
    ImageBuildResponseFromJSON,
    ImageBuildResponseToJSON,
    ImageResponseFromJSON,
    ImageResponseToJSON,
    KeyFromJSON,
    KeyToJSON,
    KeyCreateBodyFromJSON,
    KeyCreateBodyToJSON,
    MatchingCriteriaResponseFromJSON,
    MatchingCriteriaResponseToJSON,
    MatchingCriteriaRuleRequestFromJSON,
    MatchingCriteriaRuleRequestToJSON,
    NewServiceUserRequestFromJSON,
    NewServiceUserRequestToJSON,
    NodeBodyResponseFromJSON,
    NodeBodyResponseToJSON,
    OrganizationResponseFromJSON,
    OrganizationResponseToJSON,
    OutputEntryResponseFromJSON,
    OutputEntryResponseToJSON,
    PatchResourceDefinitionRequestRequestFromJSON,
    PatchResourceDefinitionRequestRequestToJSON,
    PipelineFromJSON,
    PipelineToJSON,
    PipelineApprovalRequestFromJSON,
    PipelineApprovalRequestToJSON,
    PipelineCriteriaFromJSON,
    PipelineCriteriaToJSON,
    PipelineCriteriaCreateBodyFromJSON,
    PipelineCriteriaCreateBodyToJSON,
    PipelineJobFromJSON,
    PipelineJobToJSON,
    PipelineJobPartialFromJSON,
    PipelineJobPartialToJSON,
    PipelineRunFromJSON,
    PipelineRunToJSON,
    PipelineRunCreateBodyFromJSON,
    PipelineRunCreateBodyToJSON,
    PipelineRunCreateByTriggerCriteriaBodyFromJSON,
    PipelineRunCreateByTriggerCriteriaBodyToJSON,
    PipelineStepLogFromJSON,
    PipelineStepLogToJSON,
    PipelineVersionFromJSON,
    PipelineVersionToJSON,
    PlainDeltaResponseFromJSON,
    PlainDeltaResponseToJSON,
    PublicKeyFromJSON,
    PublicKeyToJSON,
    RegistryCredsResponseFromJSON,
    RegistryCredsResponseToJSON,
    RegistryRequestFromJSON,
    RegistryRequestToJSON,
    RegistryResponseFromJSON,
    RegistryResponseToJSON,
    ResourceAccountResponseFromJSON,
    ResourceAccountResponseToJSON,
    ResourceClassRequestFromJSON,
    ResourceClassRequestToJSON,
    ResourceClassResponseFromJSON,
    ResourceClassResponseToJSON,
    ResourceDefinitionChangeResponseFromJSON,
    ResourceDefinitionChangeResponseToJSON,
    ResourceDefinitionResponseFromJSON,
    ResourceDefinitionResponseToJSON,
    ResourceDefinitionVersionFromJSON,
    ResourceDefinitionVersionToJSON,
    ResourceInputsResponseFromJSON,
    ResourceInputsResponseToJSON,
    ResourceProvisionRequestRequestFromJSON,
    ResourceProvisionRequestRequestToJSON,
    ResourceTypeResponseFromJSON,
    ResourceTypeResponseToJSON,
    RoleRequestFromJSON,
    RoleRequestToJSON,
    RuntimeInfoResponseV1FromJSON,
    RuntimeInfoResponseV1ToJSON,
    RuntimeInfoResponseV2FromJSON,
    RuntimeInfoResponseV2ToJSON,
    SecretStoreResponseFromJSON,
    SecretStoreResponseToJSON,
    SetResponseFromJSON,
    SetResponseToJSON,
    SubjectTypeEnumFromJSON,
    SubjectTypeEnumToJSON,
    TokenDefinitionRequestFromJSON,
    TokenDefinitionRequestToJSON,
    TokenInfoResponseFromJSON,
    TokenInfoResponseToJSON,
    TokenResponseFromJSON,
    TokenResponseToJSON,
    UpdateArtefactVersionPayloadRequestFromJSON,
    UpdateArtefactVersionPayloadRequestToJSON,
    UpdateDriverRequestRequestFromJSON,
    UpdateDriverRequestRequestToJSON,
    UpdateEnvironmentTypePayloadRequestFromJSON,
    UpdateEnvironmentTypePayloadRequestToJSON,
    UpdateResourceAccountRequestRequestFromJSON,
    UpdateResourceAccountRequestRequestToJSON,
    UpdateResourceClassRequestFromJSON,
    UpdateResourceClassRequestToJSON,
    UpdateResourceDefinitionRequestRequestFromJSON,
    UpdateResourceDefinitionRequestRequestToJSON,
    UpdateSecretStorePayloadRequestFromJSON,
    UpdateSecretStorePayloadRequestToJSON,
    UserInviteRequestRequestFromJSON,
    UserInviteRequestRequestToJSON,
    UserInviteResponseFromJSON,
    UserInviteResponseToJSON,
    UserProfileExtendedRequestFromJSON,
    UserProfileExtendedRequestToJSON,
    UserProfileExtendedResponseFromJSON,
    UserProfileExtendedResponseToJSON,
    UserProfileResponseFromJSON,
    UserProfileResponseToJSON,
    UserRoleRequestFromJSON,
    UserRoleRequestToJSON,
    UserRoleResponseFromJSON,
    UserRoleResponseToJSON,
    ValueCreatePayloadRequestFromJSON,
    ValueCreatePayloadRequestToJSON,
    ValueEditPayloadRequestFromJSON,
    ValueEditPayloadRequestToJSON,
    ValuePatchPayloadRequestFromJSON,
    ValuePatchPayloadRequestToJSON,
    ValueResponseFromJSON,
    ValueResponseToJSON,
    ValueSetActionPayloadRequestFromJSON,
    ValueSetActionPayloadRequestToJSON,
    ValueSetVersionResponseFromJSON,
    ValueSetVersionResponseToJSON,
    WebhookRequestFromJSON,
    WebhookRequestToJSON,
    WebhookResponseFromJSON,
    WebhookResponseToJSON,
    WebhookUpdateResponseFromJSON,
    WebhookUpdateResponseToJSON,
    WorkloadArtefactVersionDeploymentSetFromJSON,
    WorkloadArtefactVersionDeploymentSetToJSON,
    WorkloadProfileChartVersionResponseFromJSON,
    WorkloadProfileChartVersionResponseToJSON,
    WorkloadProfileFeatureResponseFromJSON,
    WorkloadProfileFeatureResponseToJSON,
    WorkloadProfileRequestFromJSON,
    WorkloadProfileRequestToJSON,
    WorkloadProfileResponseFromJSON,
    WorkloadProfileResponseToJSON,
    WorkloadProfileUpdateRequestFromJSON,
    WorkloadProfileUpdateRequestToJSON,
    WorkloadProfileVersionResponseFromJSON,
    WorkloadProfileVersionResponseToJSON,
} from '../models/index.js';

export interface ApprovePipelineApprovalRequestRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    jobId: string;
    approvalId: string;
}

export interface ArchiveDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
    body: boolean;
}

export interface ArchiveResourceDefinitionVersionRequest {
    orgId: string;
    defId: string;
    defVersionId: string;
    ArchiveDefinitionVersionRequest: ArchiveDefinitionVersionRequest;
}

export interface CancelPipelineRunRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    If_Match?: string;
}

export interface ChangeEnvOfDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
    body: string;
}

export interface ChangeNameOfDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
    body: string;
}

export interface CheckClusterConnectivityRequest {
    orgId: string;
    ClusterConnectionCheckRequest: ClusterConnectionCheckRequest;
}

export interface CheckResourceAccountRequest {
    orgId: string;
    accId: string;
}

export interface ConvertScoreToSetRequest {
    orgId: string;
    ConvertScoreToSetBody: ConvertScoreToSetBody;
}

export interface CreateAgentRequest {
    orgId: string;
    AgentCreateBody: AgentCreateBody;
}

export interface CreateApplicationRequest {
    orgId: string;
    ApplicationCreationRequest: ApplicationCreationRequest;
}

export interface CreateArtefactVersionRequest {
    orgId: string;
    CreateArtefactVersion: CreateArtefactVersion;
    vcs?: string;
    dry_run?: boolean;
    Accept?: string;
}

export interface CreateAutomationRuleRequest {
    orgId: string;
    appId: string;
    envId: string;
    AutomationRuleRequest: AutomationRuleRequest;
}

export interface CreateDeltaRequest {
    orgId: string;
    appId: string;
    DeltaRequest: DeltaRequest;
}

export interface CreateDependencyGraphRequest {
    orgId: string;
    appId: string;
    envId: string;
    ResourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>;
}

export interface CreateDeploymentRequest {
    orgId: string;
    appId: string;
    envId: string;
    DeploymentRequest: DeploymentRequest;
}

export interface CreateDeprecatedImageBuildRequest {
    orgId: string;
    imageId: string;
    ImageBuildRequest: ImageBuildRequest;
}

export interface CreateEnvironmentRequest {
    orgId: string;
    appId: string;
    EnvironmentDefinitionRequest: EnvironmentDefinitionRequest;
}

export interface CreateEnvironmentTypeRequest {
    orgId: string;
    EnvironmentTypeRequest: EnvironmentTypeRequest;
}

export interface CreateGroupRequest {
    orgId: string;
    GroupRequest: GroupRequest;
}

export interface CreateInviteInOrgRequest {
    orgId: string;
    UserInviteRequestRequest: UserInviteRequestRequest;
}

export interface CreateKeyRequest {
    orgId: string;
    agentId: string;
    KeyCreateBody: KeyCreateBody;
}

export interface CreatePipelineRequest {
    orgId: string;
    appId: string;
    body: object;
    dry_run?: boolean;
}

export interface CreatePipelineCriteriaRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    PipelineCriteriaCreateBody: PipelineCriteriaCreateBody;
}

export interface CreatePipelineRunRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    PipelineRunCreateBody: PipelineRunCreateBody;
    Idempotency_Key?: string;
    dry_run?: boolean;
}

export interface CreatePipelineRunByTriggerCriteriaRequest {
    orgId: string;
    appId: string;
    PipelineRunCreateByTriggerCriteriaBody: PipelineRunCreateByTriggerCriteriaBody;
    Idempotency_Key?: string;
    dry_run?: boolean;
}

export interface CreatePublicKeyRequest {
    orgId: string;
    body: string;
}

export interface CreateResourceAccountRequest {
    orgId: string;
    CreateResourceAccountRequestRequest: CreateResourceAccountRequestRequest;
    dry_run?: boolean;
    check_credential?: boolean;
}

export interface CreateResourceClassRequest {
    orgId: string;
    typeId: string;
    ResourceClassRequest: ResourceClassRequest;
}

export interface CreateResourceDefinitionRequest {
    orgId: string;
    CreateResourceDefinitionRequestRequest: CreateResourceDefinitionRequestRequest;
}

export interface CreateResourceDefinitionCriteriaRequest {
    orgId: string;
    defId: string;
    MatchingCriteriaRuleRequest: MatchingCriteriaRuleRequest;
}

export interface CreateResourceDriverRequest {
    orgId: string;
    CreateDriverRequestRequest: CreateDriverRequestRequest;
}

export interface CreateServiceUserInOrgRequest {
    orgId: string;
    NewServiceUserRequest: NewServiceUserRequest;
}

export interface CreateUserRoleInAppRequest {
    orgId: string;
    appId: string;
    UserRoleRequest: UserRoleRequest;
}

export interface CreateUserRoleInEnvTypeRequest {
    orgId: string;
    envType: string;
    UserRoleRequest: UserRoleRequest;
}

export interface CreateUserTokenRequest {
    userId: string;
    TokenDefinitionRequest: TokenDefinitionRequest;
}

export interface CreateWorkloadProfileRequest {
    orgId: string;
    WorkloadProfileRequest: WorkloadProfileRequest;
}

export interface CreateWorkloadProfileChartVersionRequest {
    orgId: string;
    file?: Blob;
}

export interface DeleteActiveResourceRequest {
    orgId: string;
    appId: string;
    envId: string;
    type: string;
    resId: string;
    detach?: boolean;
}

export interface DeleteAgentRequest {
    orgId: string;
    agentId: string;
}

export interface DeleteApplicationRequest {
    orgId: string;
    appId: string;
}

export interface DeleteArtefactRequest {
    orgId: string;
    artefactId: string;
}

export interface DeleteAutomationRuleRequest {
    orgId: string;
    appId: string;
    envId: string;
    ruleId: string;
}

export interface DeleteEnvironmentRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface DeleteEnvironmentTypeRequest {
    orgId: string;
    envTypeId: string;
}

export interface DeleteKeyInAgentRequest {
    orgId: string;
    agentId: string;
    fingerprint: string;
}

export interface DeletePipelineRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    If_Match?: string;
}

export interface DeletePipelineCriteriaRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    criteriaId: string;
}

export interface DeletePipelineRunRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    If_Match?: string;
}

export interface DeletePublicKeyRequest {
    orgId: string;
    keyId: string;
}

export interface DeleteResourceAccountRequest {
    orgId: string;
    accId: string;
}

export interface DeleteResourceClassRequest {
    orgId: string;
    typeId: string;
    classId: string;
}

export interface DeleteResourceDefinitionRequest {
    orgId: string;
    defId: string;
    force?: boolean;
}

export interface DeleteResourceDefinitionCriteriaRequest {
    orgId: string;
    defId: string;
    criteriaId: string;
    force?: boolean;
}

export interface DeleteResourceDriverRequest {
    orgId: string;
    driverId: string;
}

export interface DeleteUserRoleInAppRequest {
    orgId: string;
    appId: string;
    userId: string;
}

export interface DeleteUserRoleInEnvTypeRequest {
    orgId: string;
    envType: string;
    userId: string;
}

export interface DeleteUserRoleInOrgRequest {
    orgId: string;
    userId: string;
}

export interface DeleteUserTokenRequest {
    userId: string;
    tokenId: string;
}

export interface DeleteWorkloadProfileRequest {
    orgId: string;
    profileQid: string;
}

export interface DenyPipelineApprovalRequestRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    jobId: string;
    approvalId: string;
}

export interface GetApplicationRequest {
    orgId: string;
    appId: string;
}

export interface GetArtefactVersionRequest {
    orgId: string;
    artefactVersionId: string;
}

export interface GetAutomationRuleRequest {
    orgId: string;
    appId: string;
    envId: string;
    ruleId: string;
}

export interface GetBatchRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    batchType: string;
}

export interface GetDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
}

export interface GetDependencyGraphRequest {
    orgId: string;
    appId: string;
    envId: string;
    graphId: string;
}

export interface GetDeploymentRequest {
    orgId: string;
    appId: string;
    envId: string;
    deployId: string;
}

export interface GetDeprecatedImageRequest {
    orgId: string;
    imageId: string;
}

export interface GetDiffRequest {
    orgId: string;
    appId: string;
    setId: string;
    sourceSetId: string;
}

export interface GetEnvironmentRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface GetEnvironmentTypeRequest {
    orgId: string;
    envTypeId: string;
}

export interface GetLatestPipelineDefinitionSchemaRequest {
    orgId: string;
}

export interface GetLatestWorkloadProfileVersionRequest {
    orgId: string;
    profileQid: string;
}

export interface GetOrganizationRequest {
    orgId: string;
}

export interface GetPipelineRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    version?: string;
}

export interface GetPipelineApprovalRequestRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    jobId: string;
    approvalId: string;
}

export interface GetPipelineCriteriaRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    criteriaId: string;
}

export interface GetPipelineDefinitionRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    version?: string;
    Accept?: string;
}

export interface GetPipelineJobRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    jobId: string;
}

export interface GetPipelineRunRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
}

export interface GetPublicKeyRequest {
    orgId: string;
    keyId: string;
}

export interface GetResourceAccountRequest {
    orgId: string;
    accId: string;
}

export interface GetResourceClassRequest {
    orgId: string;
    typeId: string;
    classId: string;
}

export interface GetResourceDefinitionRequest {
    orgId: string;
    defId: string;
    deleted?: boolean;
}

export interface GetResourceDefinitionVersionRequest {
    orgId: string;
    defId: string;
    defVersionId: string;
}

export interface GetResourceDriverRequest {
    orgId: string;
    driverId: string;
}

export interface GetRuntimeRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface GetSetRequest {
    orgId: string;
    appId: string;
    setId: string;
    diff?: string;
}

export interface GetSetResourceInputsRequest {
    orgId: string;
    appId: string;
    setId: string;
}

export interface GetUserRoleInAppRequest {
    orgId: string;
    appId: string;
    userId: string;
}

export interface GetUserRoleInEnvTypeRequest {
    orgId: string;
    envType: string;
    userId: string;
}

export interface GetUserRoleInOrgRequest {
    orgId: string;
    userId: string;
}

export interface GetUserTokenRequest {
    userId: string;
    tokenId: string;
}

export interface GetWorkloadArtefactVersionDeploymentSetRequest {
    orgId: string;
    artefactVersionId: string;
    Accept?: string;
}

export interface GetWorkloadArtefactVersionSpecRequest {
    orgId: string;
    artefactVersionId: string;
    Accept?: string;
}

export interface GetWorkloadProfileRequest {
    orgId: string;
    profileQid: string;
}

export interface ListActiveResourceByDefinitionRequest {
    orgId: string;
    defId: string;
}

export interface ListActiveResourcesRequest {
    orgId: string;
    appId: string;
    envId: string;
    scheduled_deletion?: boolean;
}

export interface ListAgentsRequest {
    orgId: string;
    fingerprint?: string;
}

export interface ListApplicationsRequest {
    orgId: string;
}

export interface ListArtefactVersionsRequest {
    orgId: string;
    artefactId: string;
    archived?: boolean;
    reference?: string;
    limit?: number;
}

export interface ListArtefactVersionsInOrgRequest {
    orgId: string;
    name?: string;
    reference?: string;
    archived?: boolean;
    type?: string;
}

export interface ListArtefactsRequest {
    orgId: string;
    type?: string;
    name?: string;
}

export interface ListAuditLogEntriesRequest {
    orgId: string;
    per_page?: number;
    page?: string;
    from?: Date;
    to?: Date;
}

export interface ListAutomationRulesRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface ListDeltasRequest {
    orgId: string;
    appId: string;
    archived?: boolean;
    env?: string;
}

export interface ListDeploymentErrorsRequest {
    orgId: string;
    appId: string;
    envId: string;
    deployId: string;
}

export interface ListDeploymentsRequest {
    orgId: string;
    appId: string;
    envId: string;
    pipelineRunId?: string;
}

export interface ListDeprecatedImageBuildsRequest {
    orgId: string;
    imageId: string;
}

export interface ListDeprecatedImagesRequest {
    orgId: string;
}

export interface ListEnvironmentTypesRequest {
    orgId: string;
}

export interface ListEnvironmentsRequest {
    orgId: string;
    appId: string;
}

export interface ListGroupUsersRequest {
    orgId: string;
    groupId: string;
}

export interface ListHumanitecPublicKeysRequest {
    orgId: string;
    active?: boolean;
}

export interface ListInvitesInOrgRequest {
    orgId: string;
}

export interface ListKeysInAgentRequest {
    orgId: string;
    agentId: string;
}

export interface ListPipelineApprovalRequestsRequest {
    orgId: string;
    appId: string;
    per_page?: number;
    page?: string;
    pipeline?: Array<string>;
    run?: Array<string>;
    status?: string;
}

export interface ListPipelineCriteriaInAppRequest {
    orgId: string;
    appId: string;
    pipeline?: string;
    match?: { [key: string]: string; };
    per_page?: number;
    page?: string;
}

export interface ListPipelineJobsRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    status?: Array<string>;
    per_page?: number;
    page?: string;
}

export interface ListPipelineRunsRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    env?: string;
    status?: Array<string>;
    completed?: boolean;
    created_after?: Date;
    created_before?: Date;
    per_page?: number;
    page?: string;
}

export interface ListPipelineRunsByOrgRequest {
    orgId: string;
    app?: Array<string>;
    pipeline?: Array<string>;
    env?: string;
    status?: Array<string>;
    completed?: boolean;
    created_after?: Date;
    created_before?: Date;
    per_page?: number;
    page?: string;
}

export interface ListPipelineStepLogsRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    jobId: string;
    stepIndex: number;
    page?: string;
}

export interface ListPipelineVersionsRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    per_page?: number;
    page?: string;
}

export interface ListPipelinesRequest {
    orgId: string;
    appId: string;
    per_page?: number;
    page?: string;
    trigger?: string;
    metadata?: { [key: string]: string; };
}

export interface ListPipelinesInOrgRequest {
    orgId: string;
    app?: Array<string>;
    per_page?: number;
    page?: string;
    trigger?: string;
    metadata?: { [key: string]: string; };
}

export interface ListPublicKeysRequest {
    orgId: string;
    fingerprint?: string;
}

export interface ListResourceAccountTypesRequest {
    orgId: string;
}

export interface ListResourceAccountsRequest {
    orgId: string;
}

export interface ListResourceClassesRequest {
    orgId: string;
}

export interface ListResourceDefinitionVersionsRequest {
    orgId: string;
    defId: string;
    deleted?: boolean;
    per_page?: number;
    page?: string;
}

export interface ListResourceDefinitionsRequest {
    orgId: string;
    app?: string;
    env?: string;
    env_type?: string;
    res?: string;
    res_type?: string;
    _class?: string;
    deleted?: boolean;
}

export interface ListResourceDriversRequest {
    orgId: string;
}

export interface ListResourceTypesRequest {
    orgId: string;
}

export interface ListRuntimeRequest {
    orgId: string;
    appId: string;
    id?: Array<string>;
}

export interface ListSetsRequest {
    orgId: string;
    appId: string;
}

export interface ListUserGroupsInOrgRequest {
    orgId: string;
    userId: string;
}

export interface ListUserRolesInAppRequest {
    orgId: string;
    appId: string;
    type?: SubjectTypeEnum;
}

export interface ListUserRolesInEnvTypeRequest {
    orgId: string;
    envType: string;
    type?: SubjectTypeEnum;
}

export interface ListUserRolesInOrgRequest {
    orgId: string;
    type?: SubjectTypeEnum;
}

export interface ListUserTokensRequest {
    userId: string;
}

export interface ListWorkloadProfileChartVersionsRequest {
    orgId: string;
    per_page?: number;
    page?: string;
    id?: string;
    version?: string;
}

export interface ListWorkloadProfileFeaturesRequest {
    orgId: string;
}

export interface ListWorkloadProfileVersionsRequest {
    orgId: string;
    profileQid: string;
    per_page?: number;
    page?: string;
}

export interface ListWorkloadProfilesRequest {
    orgId: string;
    deprecated?: boolean;
    per_page?: number;
    page?: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdLogsGetRequest {
    orgId: string;
    appId: string;
    envId: string;
    workload_id?: string;
    container_id?: string;
    deployment_id?: string;
    timestamp_from?: string;
    timestamp_to?: string;
    limit?: string;
    asc?: boolean;
    invert?: boolean;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest {
    orgId: string;
    appId: string;
    envId: string;
    key_changed?: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest {
    orgId: string;
    appId: string;
    envId: string;
    valueSetVersionId: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    orgId: string;
    appId: string;
    envId: string;
    valueSetVersionId: string;
    key: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    orgId: string;
    appId: string;
    envId: string;
    valueSetVersionId: string;
    key: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    orgId: string;
    appId: string;
    envId: string;
    valueSetVersionId: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest {
    orgId: string;
    appId: string;
    envId: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest {
    orgId: string;
    appId: string;
    envId: string;
    key: string;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest {
    orgId: string;
    appId: string;
    envId: string;
    key: string;
    ValuePatchPayloadRequest: ValuePatchPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest {
    orgId: string;
    appId: string;
    envId: string;
    key: string;
    ValueEditPayloadRequest: ValueEditPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest {
    orgId: string;
    appId: string;
    envId: string;
    ValueCreatePayloadRequest: ValueCreatePayloadRequest;
}

export interface OrgsOrgIdAppsAppIdJobsDeleteRequest {
    orgId: string;
    appId: string;
}

export interface OrgsOrgIdAppsAppIdValueSetVersionsGetRequest {
    orgId: string;
    appId: string;
    key_changed?: string;
}

export interface OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest {
    orgId: string;
    appId: string;
    valueSetVersionId: string;
}

export interface OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest {
    orgId: string;
    appId: string;
    valueSetVersionId: string;
    key: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest {
    orgId: string;
    appId: string;
    valueSetVersionId: string;
    key: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest {
    orgId: string;
    appId: string;
    valueSetVersionId: string;
    ValueSetActionPayloadRequest: ValueSetActionPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdValuesDeleteRequest {
    orgId: string;
    appId: string;
}

export interface OrgsOrgIdAppsAppIdValuesGetRequest {
    orgId: string;
    appId: string;
}

export interface OrgsOrgIdAppsAppIdValuesKeyDeleteRequest {
    orgId: string;
    appId: string;
    key: string;
}

export interface OrgsOrgIdAppsAppIdValuesKeyPatchRequest {
    orgId: string;
    appId: string;
    key: string;
    ValuePatchPayloadRequest: ValuePatchPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdValuesKeyPutRequest {
    orgId: string;
    appId: string;
    key: string;
    ValueEditPayloadRequest: ValueEditPayloadRequest;
}

export interface OrgsOrgIdAppsAppIdValuesPostRequest {
    orgId: string;
    appId: string;
    ValueCreatePayloadRequest: ValueCreatePayloadRequest;
}

export interface OrgsOrgIdAppsAppIdWebhooksGetRequest {
    orgId: string;
    appId: string;
}

export interface OrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest {
    orgId: string;
    appId: string;
    jobId: string;
}

export interface OrgsOrgIdAppsAppIdWebhooksJobIdGetRequest {
    orgId: string;
    appId: string;
    jobId: string;
}

export interface OrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest {
    orgId: string;
    appId: string;
    jobId: string;
    WebhookRequest: WebhookRequest;
}

export interface OrgsOrgIdAppsAppIdWebhooksPostRequest {
    orgId: string;
    appId: string;
    WebhookRequest: WebhookRequest;
}

export interface OrgsOrgIdEventsGetRequest {
    orgId: string;
}

export interface OrgsOrgIdRegistriesGetRequest {
    orgId: string;
}

export interface OrgsOrgIdRegistriesPostRequest {
    orgId: string;
    RegistryRequest: RegistryRequest;
}

export interface OrgsOrgIdRegistriesRegIdCredsGetRequest {
    orgId: string;
    regId: string;
}

export interface OrgsOrgIdRegistriesRegIdDeleteRequest {
    orgId: string;
    regId: string;
}

export interface OrgsOrgIdRegistriesRegIdGetRequest {
    orgId: string;
    regId: string;
}

export interface OrgsOrgIdRegistriesRegIdPatchRequest {
    orgId: string;
    regId: string;
    RegistryRequest: RegistryRequest;
}

export interface OrgsOrgIdSecretstoresGetRequest {
    orgId: string;
}

export interface OrgsOrgIdSecretstoresPostRequest {
    orgId: string;
    CreateSecretStorePayloadRequest: CreateSecretStorePayloadRequest;
}

export interface OrgsOrgIdSecretstoresStoreIdDeleteRequest {
    orgId: string;
    storeId: string;
}

export interface OrgsOrgIdSecretstoresStoreIdGetRequest {
    orgId: string;
    storeId: string;
}

export interface OrgsOrgIdSecretstoresStoreIdPatchRequest {
    orgId: string;
    storeId: string;
    UpdateSecretStorePayloadRequest: UpdateSecretStorePayloadRequest;
}

export interface PatchAgentRequest {
    orgId: string;
    agentId: string;
    AgentPatchBody: AgentPatchBody;
}

export interface PatchApplicationRequest {
    orgId: string;
    appId: string;
    ApplicationPatchPayload: ApplicationPatchPayload;
}

export interface PatchArtefactVersionRequest {
    orgId: string;
    artefactId: string;
    versionId: string;
    UpdateArtefactVersionPayloadRequest: UpdateArtefactVersionPayloadRequest;
}

export interface PatchDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
    DeltaRequest: Array<DeltaRequest>;
}

export interface PatchReplicasRequest {
    orgId: string;
    appId: string;
    envId: string;
    request_body: { [key: string]: number; };
}

export interface PatchResourceAccountRequest {
    orgId: string;
    accId: string;
    UpdateResourceAccountRequestRequest: UpdateResourceAccountRequestRequest;
    dry_run?: boolean;
    check_credential?: boolean;
}

export interface PatchResourceDefinitionRequest {
    orgId: string;
    defId: string;
    PatchResourceDefinitionRequestRequest: PatchResourceDefinitionRequestRequest;
}

export interface PinActiveResourceRequest {
    orgId: string;
    appId: string;
    envId: string;
    type: string;
    resId: string;
    ActiveResourceTargetDefinitionRequest: ActiveResourceTargetDefinitionRequest;
}

export interface PromoteResourceDefinitionVersionRequest {
    orgId: string;
    defId: string;
    defVersionId: string;
}

export interface PutDeltaRequest {
    orgId: string;
    appId: string;
    deltaId: string;
    DeltaRequest: DeltaRequest;
}

export interface QueryResourceGraphRequest {
    orgId: string;
    appId: string;
    envId: string;
    ResourceProvisionRequestRequest: Array<ResourceProvisionRequestRequest>;
}

export interface RebaseEnvironmentRequest {
    orgId: string;
    appId: string;
    envId: string;
    body: string;
}

export interface RestartPipelineRunRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    runId: string;
    Idempotency_Key?: string;
}

export interface UpdateAutomationRuleRequest {
    orgId: string;
    appId: string;
    envId: string;
    ruleId: string;
    AutomationRuleRequest: AutomationRuleRequest;
}

export interface UpdateCurrentUserRequest {
    UserProfileExtendedRequest: UserProfileExtendedRequest;
}

export interface UpdateEnvironmentRequest {
    orgId: string;
    appId: string;
    envId: string;
    EnvironmentBaseUpdateRequest?: EnvironmentBaseUpdateRequest;
}

export interface UpdateEnvironmentTypeRequest {
    orgId: string;
    envTypeId: string;
    UpdateEnvironmentTypePayloadRequest: UpdateEnvironmentTypePayloadRequest;
}

export interface UpdatePausedRequest {
    orgId: string;
    appId: string;
    envId: string;
    body: boolean;
}

export interface UpdatePipelineRequest {
    orgId: string;
    appId: string;
    pipelineId: string;
    body: object;
    If_Match?: string;
    dry_run?: boolean;
}

export interface UpdateResourceClassOperationRequest {
    orgId: string;
    typeId: string;
    classId: string;
    UpdateResourceClassRequest: UpdateResourceClassRequest;
}

export interface UpdateResourceDefinitionRequest {
    orgId: string;
    defId: string;
    UpdateResourceDefinitionRequestRequest: UpdateResourceDefinitionRequestRequest;
}

export interface UpdateResourceDefinitionCriteriaRequest {
    orgId: string;
    defId: string;
    MatchingCriteriaRuleRequest: Array<MatchingCriteriaRuleRequest>;
}

export interface UpdateResourceDriverRequest {
    orgId: string;
    driverId: string;
    UpdateDriverRequestRequest: UpdateDriverRequestRequest;
}

export interface UpdateSetRequest {
    orgId: string;
    appId: string;
    setId: string;
    DeltaRequest: DeltaRequest;
}

export interface UpdateUserRoleInAppRequest {
    orgId: string;
    appId: string;
    userId: string;
    RoleRequest: RoleRequest;
}

export interface UpdateUserRoleInEnvTypeRequest {
    orgId: string;
    envType: string;
    userId: string;
    RoleRequest: RoleRequest;
}

export interface UpdateUserRoleInOrgRequest {
    orgId: string;
    userId: string;
    RoleRequest: RoleRequest;
}

export interface UpdateWorkloadProfileRequest {
    orgId: string;
    profileQid: string;
    WorkloadProfileUpdateRequest: WorkloadProfileUpdateRequest;
}

/**
 * 
 */
export class PublicApi extends runtime.BaseAPI {

    /**
     * Approve the approval requested.
     * Approve the approval request
     */
    async approvePipelineApprovalRequestRaw(requestParameters: ApprovePipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineApprovalRequest>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        if (requestParameters['approvalId'] == null) {
            throw new runtime.RequiredError(
                'approvalId',
                'Required parameter "approvalId" was null or undefined when calling approvePipelineApprovalRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/approve`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))).replace(`{${"approvalId"}}`, encodeURIComponent(String(requestParameters['approvalId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineApprovalRequestFromJSON(jsonValue));
    }

    /**
     * Approve the approval requested.
     * Approve the approval request
     */
    async approvePipelineApprovalRequest(requestParameters: ApprovePipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineApprovalRequest> {
        const response = await this.approvePipelineApprovalRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * Mark a Delta as \"archived\"
     */
    async archiveDeltaRaw(requestParameters: ArchiveDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling archiveDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling archiveDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling archiveDelta().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling archiveDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/archived`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Archived Deltas are still accessible but can no longer be updated.
     * Mark a Delta as \"archived\"
     */
    async archiveDelta(requestParameters: ArchiveDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.archiveDeltaRaw(requestParameters, initOverrides);
    }

    /**
     * Mark/unmark the Resource Definition Version as archived.
     */
    async archiveResourceDefinitionVersionRaw(requestParameters: ArchiveResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling archiveResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling archiveResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defVersionId'] == null) {
            throw new runtime.RequiredError(
                'defVersionId',
                'Required parameter "defVersionId" was null or undefined when calling archiveResourceDefinitionVersion().'
            );
        }

        if (requestParameters['ArchiveDefinitionVersionRequest'] == null) {
            throw new runtime.RequiredError(
                'ArchiveDefinitionVersionRequest',
                'Required parameter "ArchiveDefinitionVersionRequest" was null or undefined when calling archiveResourceDefinitionVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/versions/{defVersionId}/actions/archive`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))).replace(`{${"defVersionId"}}`, encodeURIComponent(String(requestParameters['defVersionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ArchiveDefinitionVersionRequestToJSON(requestParameters['ArchiveDefinitionVersionRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Mark/unmark the Resource Definition Version as archived.
     */
    async archiveResourceDefinitionVersion(requestParameters: ArchiveResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.archiveResourceDefinitionVersionRaw(requestParameters, initOverrides);
    }

    /**
     * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
     * Cancel a Run within an Pipeline.
     */
    async cancelPipelineRunRaw(requestParameters: CancelPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling cancelPipelineRun().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling cancelPipelineRun().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling cancelPipelineRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling cancelPipelineRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['If_Match'] != null) {
            headerParameters['If-Match'] = String(requestParameters['If_Match']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/cancel`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Attempts to cancel the specified Run. If the Run is in a queued state, this cancellation will be applied immediately. If the Run is executing, the cancellation will be stored and will be resolved by the next Job or Step that supports in-flight cancellation. Runs that are in any other state, are not cancellable. 
     * Cancel a Run within an Pipeline.
     */
    async cancelPipelineRun(requestParameters: CancelPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cancelPipelineRunRaw(requestParameters, initOverrides);
    }

    /**
     * Change the Environment of a Delta
     */
    async changeEnvOfDeltaRaw(requestParameters: ChangeEnvOfDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling changeEnvOfDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling changeEnvOfDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling changeEnvOfDelta().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling changeEnvOfDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/env_id`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the Environment of a Delta
     */
    async changeEnvOfDelta(requestParameters: ChangeEnvOfDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeEnvOfDeltaRaw(requestParameters, initOverrides);
    }

    /**
     * Change the name of a Delta
     */
    async changeNameOfDeltaRaw(requestParameters: ChangeNameOfDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling changeNameOfDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling changeNameOfDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling changeNameOfDelta().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling changeNameOfDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}/metadata/name`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change the name of a Delta
     */
    async changeNameOfDelta(requestParameters: ChangeNameOfDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.changeNameOfDeltaRaw(requestParameters, initOverrides);
    }

    /**
     * Provision and check the cluster connectivity in an environment
     */
    async checkClusterConnectivityRaw(requestParameters: CheckClusterConnectivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ClusterConnectionCheckResult>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling checkClusterConnectivity().'
            );
        }

        if (requestParameters['ClusterConnectionCheckRequest'] == null) {
            throw new runtime.RequiredError(
                'ClusterConnectionCheckRequest',
                'Required parameter "ClusterConnectionCheckRequest" was null or undefined when calling checkClusterConnectivity().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/runtime/actions/check-connectivity`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ClusterConnectionCheckRequestToJSON(requestParameters['ClusterConnectionCheckRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ClusterConnectionCheckResultFromJSON(jsonValue));
    }

    /**
     * Provision and check the cluster connectivity in an environment
     */
    async checkClusterConnectivity(requestParameters: CheckClusterConnectivityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ClusterConnectionCheckResult> {
        const response = await this.checkClusterConnectivityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check the validity of a Resource Account and return any problems that may cause it to not work as expected.
     * Check the credentials of an existing Resource Account
     */
    async checkResourceAccountRaw(requestParameters: CheckResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckResourceAccountData>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling checkResourceAccount().'
            );
        }

        if (requestParameters['accId'] == null) {
            throw new runtime.RequiredError(
                'accId',
                'Required parameter "accId" was null or undefined when calling checkResourceAccount().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts/{accId}/actions/check`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"accId"}}`, encodeURIComponent(String(requestParameters['accId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckResourceAccountDataFromJSON(jsonValue));
    }

    /**
     * Check the validity of a Resource Account and return any problems that may cause it to not work as expected.
     * Check the credentials of an existing Resource Account
     */
    async checkResourceAccount(requestParameters: CheckResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckResourceAccountData> {
        const response = await this.checkResourceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Convert a Score specification, optional overrides, and extensions into the contents for a deployment set.
     */
    async convertScoreToSetRaw(requestParameters: ConvertScoreToSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadArtefactVersionDeploymentSet>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling convertScoreToSet().'
            );
        }

        if (requestParameters['ConvertScoreToSetBody'] == null) {
            throw new runtime.RequiredError(
                'ConvertScoreToSetBody',
                'Required parameter "ConvertScoreToSetBody" was null or undefined when calling convertScoreToSet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions/convert-score`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConvertScoreToSetBodyToJSON(requestParameters['ConvertScoreToSetBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadArtefactVersionDeploymentSetFromJSON(jsonValue));
    }

    /**
     * Convert a Score specification, optional overrides, and extensions into the contents for a deployment set.
     */
    async convertScoreToSet(requestParameters: ConvertScoreToSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadArtefactVersionDeploymentSet> {
        const response = await this.convertScoreToSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new Agent under an Organization.
     */
    async createAgentRaw(requestParameters: CreateAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Agent>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createAgent().'
            );
        }

        if (requestParameters['AgentCreateBody'] == null) {
            throw new runtime.RequiredError(
                'AgentCreateBody',
                'Required parameter "AgentCreateBody" was null or undefined when calling createAgent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/agents`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AgentCreateBodyToJSON(requestParameters['AgentCreateBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AgentFromJSON(jsonValue));
    }

    /**
     * Register a new Agent under an Organization.
     */
    async createAgent(requestParameters: CreateAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Agent> {
        const response = await this.createAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * Add a new Application to an Organization
     */
    async createApplicationRaw(requestParameters: CreateApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createApplication().'
            );
        }

        if (requestParameters['ApplicationCreationRequest'] == null) {
            throw new runtime.RequiredError(
                'ApplicationCreationRequest',
                'Required parameter "ApplicationCreationRequest" was null or undefined when calling createApplication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApplicationCreationRequestToJSON(requestParameters['ApplicationCreationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new Application, then adds it to the specified Organization.
     * Add a new Application to an Organization
     */
    async createApplication(requestParameters: CreateApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationResponse> {
        const response = await this.createApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new Artefact Version with your organization.
     */
    async createArtefactVersionRaw(requestParameters: CreateArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ArtefactVersion>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createArtefactVersion().'
            );
        }

        if (requestParameters['CreateArtefactVersion'] == null) {
            throw new runtime.RequiredError(
                'CreateArtefactVersion',
                'Required parameter "CreateArtefactVersion" was null or undefined when calling createArtefactVersion().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['vcs'] != null) {
            queryParameters['vcs'] = requestParameters['vcs'];
        }

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['Accept'] != null) {
            headerParameters['Accept'] = String(requestParameters['Accept']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateArtefactVersionToJSON(requestParameters['CreateArtefactVersion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactVersionFromJSON(jsonValue));
    }

    /**
     * Register a new Artefact Version with your organization.
     */
    async createArtefactVersion(requestParameters: CreateArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ArtefactVersion | null | undefined > {
        const response = await this.createArtefactVersionRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * Create a new Automation Rule for an Environment.
     */
    async createAutomationRuleRaw(requestParameters: CreateAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutomationRuleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createAutomationRule().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createAutomationRule().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling createAutomationRule().'
            );
        }

        if (requestParameters['AutomationRuleRequest'] == null) {
            throw new runtime.RequiredError(
                'AutomationRuleRequest',
                'Required parameter "AutomationRuleRequest" was null or undefined when calling createAutomationRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationRuleRequestToJSON(requestParameters['AutomationRuleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationRuleResponseFromJSON(jsonValue));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * Create a new Automation Rule for an Environment.
     */
    async createAutomationRule(requestParameters: CreateAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutomationRuleResponse> {
        const response = await this.createAutomationRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Delta
     */
    async createDeltaRaw(requestParameters: CreateDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateDelta200Response>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createDelta().'
            );
        }

        if (requestParameters['DeltaRequest'] == null) {
            throw new runtime.RequiredError(
                'DeltaRequest',
                'Required parameter "DeltaRequest" was null or undefined when calling createDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeltaRequestToJSON(requestParameters['DeltaRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateDelta200ResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Delta
     */
    async createDelta(requestParameters: CreateDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateDelta200Response> {
        const response = await this.createDeltaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a Dependency Graph which is composed by the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     */
    async createDependencyGraphRaw(requestParameters: CreateDependencyGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DependencyGraphResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createDependencyGraph().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createDependencyGraph().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling createDependencyGraph().'
            );
        }

        if (requestParameters['ResourceProvisionRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'ResourceProvisionRequestRequest',
                'Required parameter "ResourceProvisionRequestRequest" was null or undefined when calling createDependencyGraph().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graphs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['ResourceProvisionRequestRequest']!.map(ResourceProvisionRequestRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DependencyGraphResponseFromJSON(jsonValue));
    }

    /**
     * Create a Dependency Graph which is composed by the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     */
    async createDependencyGraph(requestParameters: CreateDependencyGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DependencyGraphResponse> {
        const response = await this.createDependencyGraphRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * Start a new Deployment.
     */
    async createDeploymentRaw(requestParameters: CreateDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeploymentResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createDeployment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createDeployment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling createDeployment().'
            );
        }

        if (requestParameters['DeploymentRequest'] == null) {
            throw new runtime.RequiredError(
                'DeploymentRequest',
                'Required parameter "DeploymentRequest" was null or undefined when calling createDeployment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeploymentRequestToJSON(requestParameters['DeploymentRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentResponseFromJSON(jsonValue));
    }

    /**
     * At Humanitec, Deployments are defined as changes to the state of the Environment. The state can be changed by defining a set of desired changes to the current state via a Deployment Delta or by resetting the current state after a previous Deployment. (See Environment Rebase.) Both types of changes can be combined into a single Deployment during which the Delta is applied to the Rebased state.  When specifying a Delta, a Delta ID must be used. That Delta must have been committed to the Delta store prior to the Deployment.  A Set ID can also be defined in the deployment to force the state of the environment to a particular state. This will be ignored if the Delta is specified.  **NOTE:**  Directly setting a `set_id` in a deployment is not recommended as it will not record history of where the set came from. If the intention is to replicate an existing environment, use the environment rebasing approach described above.
     * Start a new Deployment.
     */
    async createDeployment(requestParameters: CreateDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeploymentResponse> {
        const response = await this.createDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * Add a new Image Build
     */
    async createDeprecatedImageBuildRaw(requestParameters: CreateDeprecatedImageBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createDeprecatedImageBuild().'
            );
        }

        if (requestParameters['imageId'] == null) {
            throw new runtime.RequiredError(
                'imageId',
                'Required parameter "imageId" was null or undefined when calling createDeprecatedImageBuild().'
            );
        }

        if (requestParameters['ImageBuildRequest'] == null) {
            throw new runtime.RequiredError(
                'ImageBuildRequest',
                'Required parameter "ImageBuildRequest" was null or undefined when calling createDeprecatedImageBuild().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/images/{imageId}/builds`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"imageId"}}`, encodeURIComponent(String(requestParameters['imageId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImageBuildRequestToJSON(requestParameters['ImageBuildRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  This endpoint is used by Continuous Integration (CI) pipelines to notify Humanitec that a new Image Build is available.  If there is no Image with ID `imageId`, it will be automatically created.
     * Add a new Image Build
     */
    async createDeprecatedImageBuild(requestParameters: CreateDeprecatedImageBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createDeprecatedImageBuildRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * Add a new Environment to an Application.
     */
    async createEnvironmentRaw(requestParameters: CreateEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createEnvironment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createEnvironment().'
            );
        }

        if (requestParameters['EnvironmentDefinitionRequest'] == null) {
            throw new runtime.RequiredError(
                'EnvironmentDefinitionRequest',
                'Required parameter "EnvironmentDefinitionRequest" was null or undefined when calling createEnvironment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EnvironmentDefinitionRequestToJSON(requestParameters['EnvironmentDefinitionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new Environment of the specified Type and associates it with the Application specified by `appId`.  The Environment is also initialized to the **current or past state of Deployment in another Environment**. This ensures that every Environment is derived from a previously known state. This means it is not possible to create a new Environment for an Application until at least one Deployment has occurred. (The Deployment does not have to be successful.)  The Type of the Environment must be already defined in the Organization.
     * Add a new Environment to an Application.
     */
    async createEnvironment(requestParameters: CreateEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentResponse> {
        const response = await this.createEnvironmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a new Environment Type to an Organization.
     * Add a new Environment Type
     */
    async createEnvironmentTypeRaw(requestParameters: CreateEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentTypeResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createEnvironmentType().'
            );
        }

        if (requestParameters['EnvironmentTypeRequest'] == null) {
            throw new runtime.RequiredError(
                'EnvironmentTypeRequest',
                'Required parameter "EnvironmentTypeRequest" was null or undefined when calling createEnvironmentType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/env-types`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EnvironmentTypeRequestToJSON(requestParameters['EnvironmentTypeRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentTypeResponseFromJSON(jsonValue));
    }

    /**
     * Adds a new Environment Type to an Organization.
     * Add a new Environment Type
     */
    async createEnvironmentType(requestParameters: CreateEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentTypeResponse> {
        const response = await this.createEnvironmentTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a group in an organization
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupWithRole>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createGroup().'
            );
        }

        if (requestParameters['GroupRequest'] == null) {
            throw new runtime.RequiredError(
                'GroupRequest',
                'Required parameter "GroupRequest" was null or undefined when calling createGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/groups`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GroupRequestToJSON(requestParameters['GroupRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupWithRoleFromJSON(jsonValue));
    }

    /**
     * Create a group in an organization
     */
    async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupWithRole> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Invites a user to an Organization with a specified role.
     */
    async createInviteInOrgRaw(requestParameters: CreateInviteInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRoleResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createInviteInOrg().'
            );
        }

        if (requestParameters['UserInviteRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'UserInviteRequestRequest',
                'Required parameter "UserInviteRequestRequest" was null or undefined when calling createInviteInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/invitations`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserInviteRequestRequestToJSON(requestParameters['UserInviteRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRoleResponseFromJSON));
    }

    /**
     * Invites a user to an Organization with a specified role.
     */
    async createInviteInOrg(requestParameters: CreateInviteInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRoleResponse>> {
        const response = await this.createInviteInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new Key under an Agent in an Organization.
     */
    async createKeyRaw(requestParameters: CreateKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Key>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createKey().'
            );
        }

        if (requestParameters['agentId'] == null) {
            throw new runtime.RequiredError(
                'agentId',
                'Required parameter "agentId" was null or undefined when calling createKey().'
            );
        }

        if (requestParameters['KeyCreateBody'] == null) {
            throw new runtime.RequiredError(
                'KeyCreateBody',
                'Required parameter "KeyCreateBody" was null or undefined when calling createKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/agents/{agentId}/keys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters['agentId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeyCreateBodyToJSON(requestParameters['KeyCreateBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeyFromJSON(jsonValue));
    }

    /**
     * Register a new Key under an Agent in an Organization.
     */
    async createKey(requestParameters: CreateKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Key> {
        const response = await this.createKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a Pipeline within an Application.
     */
    async createPipelineRaw(requestParameters: CreatePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Pipeline>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createPipeline().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createPipeline().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createPipeline().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-yaml';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineFromJSON(jsonValue));
    }

    /**
     * Create a Pipeline within an Application.
     */
    async createPipeline(requestParameters: CreatePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Pipeline | null | undefined > {
        const response = await this.createPipelineRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 201:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
     * Create a new trigger matching criteria for this Pipeline.
     */
    async createPipelineCriteriaRaw(requestParameters: CreatePipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineCriteria>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createPipelineCriteria().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createPipelineCriteria().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling createPipelineCriteria().'
            );
        }

        if (requestParameters['PipelineCriteriaCreateBody'] == null) {
            throw new runtime.RequiredError(
                'PipelineCriteriaCreateBody',
                'Required parameter "PipelineCriteriaCreateBody" was null or undefined when calling createPipelineCriteria().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PipelineCriteriaCreateBodyToJSON(requestParameters['PipelineCriteriaCreateBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineCriteriaFromJSON(jsonValue));
    }

    /**
     * Create a new trigger matching criteria for this Pipeline. This must not conflict with an existing criteria for the same trigger on this or any other Pipeline that applies to this Application. 
     * Create a new trigger matching criteria for this Pipeline.
     */
    async createPipelineCriteria(requestParameters: CreatePipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineCriteria> {
        const response = await this.createPipelineCriteriaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a run within a pipeline.
     */
    async createPipelineRunRaw(requestParameters: CreatePipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineRun>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createPipelineRun().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createPipelineRun().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling createPipelineRun().'
            );
        }

        if (requestParameters['PipelineRunCreateBody'] == null) {
            throw new runtime.RequiredError(
                'PipelineRunCreateBody',
                'Required parameter "PipelineRunCreateBody" was null or undefined when calling createPipelineRun().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['Idempotency_Key'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['Idempotency_Key']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PipelineRunCreateBodyToJSON(requestParameters['PipelineRunCreateBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineRunFromJSON(jsonValue));
    }

    /**
     * Create a run within a pipeline.
     */
    async createPipelineRun(requestParameters: CreatePipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineRun | null | undefined > {
        const response = await this.createPipelineRunRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 201:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
     */
    async createPipelineRunByTriggerCriteriaRaw(requestParameters: CreatePipelineRunByTriggerCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineRun>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createPipelineRunByTriggerCriteria().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createPipelineRunByTriggerCriteria().'
            );
        }

        if (requestParameters['PipelineRunCreateByTriggerCriteriaBody'] == null) {
            throw new runtime.RequiredError(
                'PipelineRunCreateByTriggerCriteriaBody',
                'Required parameter "PipelineRunCreateByTriggerCriteriaBody" was null or undefined when calling createPipelineRunByTriggerCriteria().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['Idempotency_Key'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['Idempotency_Key']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipeline-runs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PipelineRunCreateByTriggerCriteriaBodyToJSON(requestParameters['PipelineRunCreateByTriggerCriteriaBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineRunFromJSON(jsonValue));
    }

    /**
     * Create a Pipeline Run in the appropriate Pipeline based on the trigger and inputs.
     */
    async createPipelineRunByTriggerCriteria(requestParameters: CreatePipelineRunByTriggerCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineRun | null | undefined > {
        const response = await this.createPipelineRunByTriggerCriteriaRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 201:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Associate a new RSA public key to an organization.
     */
    async createPublicKeyRaw(requestParameters: CreatePublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicKey>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createPublicKey().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling createPublicKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/keys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicKeyFromJSON(jsonValue));
    }

    /**
     * Associate a new RSA public key to an organization.
     */
    async createPublicKey(requestParameters: CreatePublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicKey> {
        const response = await this.createPublicKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Resource Account in the organization.
     */
    async createResourceAccountRaw(requestParameters: CreateResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceAccountResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createResourceAccount().'
            );
        }

        if (requestParameters['CreateResourceAccountRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'CreateResourceAccountRequestRequest',
                'Required parameter "CreateResourceAccountRequestRequest" was null or undefined when calling createResourceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        if (requestParameters['check_credential'] != null) {
            queryParameters['check_credential'] = requestParameters['check_credential'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateResourceAccountRequestRequestToJSON(requestParameters['CreateResourceAccountRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceAccountResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Resource Account in the organization.
     */
    async createResourceAccount(requestParameters: CreateResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceAccountResponse | null | undefined > {
        const response = await this.createResourceAccountRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Creates a new resources class.
     */
    async createResourceClassRaw(requestParameters: CreateResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceClassResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createResourceClass().'
            );
        }

        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling createResourceClass().'
            );
        }

        if (requestParameters['ResourceClassRequest'] == null) {
            throw new runtime.RequiredError(
                'ResourceClassRequest',
                'Required parameter "ResourceClassRequest" was null or undefined when calling createResourceClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/types/{typeId}/classes`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"typeId"}}`, encodeURIComponent(String(requestParameters['typeId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ResourceClassRequestToJSON(requestParameters['ResourceClassRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceClassResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new resources class.
     */
    async createResourceClass(requestParameters: CreateResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceClassResponse> {
        const response = await this.createResourceClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Resource Definition.
     */
    async createResourceDefinitionRaw(requestParameters: CreateResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createResourceDefinition().'
            );
        }

        if (requestParameters['CreateResourceDefinitionRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'CreateResourceDefinitionRequestRequest',
                'Required parameter "CreateResourceDefinitionRequestRequest" was null or undefined when calling createResourceDefinition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateResourceDefinitionRequestRequestToJSON(requestParameters['CreateResourceDefinitionRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Resource Definition.
     */
    async createResourceDefinition(requestParameters: CreateResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceDefinitionResponse> {
        const response = await this.createResourceDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * Add a new Matching Criteria to a Resource Definition.
     */
    async createResourceDefinitionCriteriaRaw(requestParameters: CreateResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MatchingCriteriaResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling createResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['MatchingCriteriaRuleRequest'] == null) {
            throw new runtime.RequiredError(
                'MatchingCriteriaRuleRequest',
                'Required parameter "MatchingCriteriaRuleRequest" was null or undefined when calling createResourceDefinitionCriteria().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/criteria`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MatchingCriteriaRuleRequestToJSON(requestParameters['MatchingCriteriaRuleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MatchingCriteriaResponseFromJSON(jsonValue));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * Add a new Matching Criteria to a Resource Definition.
     */
    async createResourceDefinitionCriteria(requestParameters: CreateResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MatchingCriteriaResponse> {
        const response = await this.createResourceDefinitionCriteriaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new Resource Driver.
     */
    async createResourceDriverRaw(requestParameters: CreateResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DriverDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createResourceDriver().'
            );
        }

        if (requestParameters['CreateDriverRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'CreateDriverRequestRequest',
                'Required parameter "CreateDriverRequestRequest" was null or undefined when calling createResourceDriver().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/drivers`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateDriverRequestRequestToJSON(requestParameters['CreateDriverRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DriverDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Register a new Resource Driver.
     */
    async createResourceDriver(requestParameters: CreateResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DriverDefinitionResponse> {
        const response = await this.createResourceDriverRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new service user.
     */
    async createServiceUserInOrgRaw(requestParameters: CreateServiceUserInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfileResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createServiceUserInOrg().'
            );
        }

        if (requestParameters['NewServiceUserRequest'] == null) {
            throw new runtime.RequiredError(
                'NewServiceUserRequest',
                'Required parameter "NewServiceUserRequest" was null or undefined when calling createServiceUserInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewServiceUserRequestToJSON(requestParameters['NewServiceUserRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new service user.
     */
    async createServiceUserInOrg(requestParameters: CreateServiceUserInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfileResponse> {
        const response = await this.createServiceUserInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a User or a Group to an Application with a Role
     */
    async createUserRoleInAppRaw(requestParameters: CreateUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createUserRoleInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling createUserRoleInApp().'
            );
        }

        if (requestParameters['UserRoleRequest'] == null) {
            throw new runtime.RequiredError(
                'UserRoleRequest',
                'Required parameter "UserRoleRequest" was null or undefined when calling createUserRoleInApp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserRoleRequestToJSON(requestParameters['UserRoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Adds a User or a Group to an Application with a Role
     */
    async createUserRoleInApp(requestParameters: CreateUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.createUserRoleInAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds a User to an Environment Type with a Role
     */
    async createUserRoleInEnvTypeRaw(requestParameters: CreateUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createUserRoleInEnvType().'
            );
        }

        if (requestParameters['envType'] == null) {
            throw new runtime.RequiredError(
                'envType',
                'Required parameter "envType" was null or undefined when calling createUserRoleInEnvType().'
            );
        }

        if (requestParameters['UserRoleRequest'] == null) {
            throw new runtime.RequiredError(
                'UserRoleRequest',
                'Required parameter "UserRoleRequest" was null or undefined when calling createUserRoleInEnvType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envType}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envType"}}`, encodeURIComponent(String(requestParameters['envType']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserRoleRequestToJSON(requestParameters['UserRoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Adds a User to an Environment Type with a Role
     */
    async createUserRoleInEnvType(requestParameters: CreateUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.createUserRoleInEnvTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This is only supported for users of type `service`.
     * Creates a new static token for a user.
     */
    async createUserTokenRaw(requestParameters: CreateUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling createUserToken().'
            );
        }

        if (requestParameters['TokenDefinitionRequest'] == null) {
            throw new runtime.RequiredError(
                'TokenDefinitionRequest',
                'Required parameter "TokenDefinitionRequest" was null or undefined when calling createUserToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/users/{userId}/tokens`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenDefinitionRequestToJSON(requestParameters['TokenDefinitionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseFromJSON(jsonValue));
    }

    /**
     * This is only supported for users of type `service`.
     * Creates a new static token for a user.
     */
    async createUserToken(requestParameters: CreateUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenResponse> {
        const response = await this.createUserTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create new Workload Profile
     */
    async createWorkloadProfileRaw(requestParameters: CreateWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadProfileResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createWorkloadProfile().'
            );
        }

        if (requestParameters['WorkloadProfileRequest'] == null) {
            throw new runtime.RequiredError(
                'WorkloadProfileRequest',
                'Required parameter "WorkloadProfileRequest" was null or undefined when calling createWorkloadProfile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WorkloadProfileRequestToJSON(requestParameters['WorkloadProfileRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadProfileResponseFromJSON(jsonValue));
    }

    /**
     * Create new Workload Profile
     */
    async createWorkloadProfile(requestParameters: CreateWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadProfileResponse> {
        const response = await this.createWorkloadProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
     * Add new Workload Profile Chart Version
     */
    async createWorkloadProfileChartVersionRaw(requestParameters: CreateWorkloadProfileChartVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadProfileChartVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling createWorkloadProfileChartVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profile-chart-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadProfileChartVersionResponseFromJSON(jsonValue));
    }

    /**
     * Creates a Workload Profile Chart Version from the uploaded Helm chart. The name and version is retrieved from the chart\'s metadata (Charts.yaml file).  The request has content type `multipart/form-data` and the request body includes one part:  1. `file` with `application/x-gzip` content type which is an archive containing a Helm chart.  Request body example:   Content-Type: multipart/form-data; boundary=----boundary  ----boundary  Content-Disposition: form-data; name=\"file\"; filename=\"my-workload-1.0.1.tgz\"  Content-Type: application/x-gzip  [TGZ_DATA]  ----boundary
     * Add new Workload Profile Chart Version
     */
    async createWorkloadProfileChartVersion(requestParameters: CreateWorkloadProfileChartVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadProfileChartVersionResponse> {
        const response = await this.createWorkloadProfileChartVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Active Resource.
     */
    async deleteActiveResourceRaw(requestParameters: DeleteActiveResourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteActiveResource().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deleteActiveResource().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling deleteActiveResource().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling deleteActiveResource().'
            );
        }

        if (requestParameters['resId'] == null) {
            throw new runtime.RequiredError(
                'resId',
                'Required parameter "resId" was null or undefined when calling deleteActiveResource().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['detach'] != null) {
            queryParameters['detach'] = requestParameters['detach'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))).replace(`{${"resId"}}`, encodeURIComponent(String(requestParameters['resId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Active Resource.
     */
    async deleteActiveResource(requestParameters: DeleteActiveResourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteActiveResourceRaw(requestParameters, initOverrides);
    }

    /**
     * Delete an Agent (and its keys) stored under an Organization.
     */
    async deleteAgentRaw(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteAgent().'
            );
        }

        if (requestParameters['agentId'] == null) {
            throw new runtime.RequiredError(
                'agentId',
                'Required parameter "agentId" was null or undefined when calling deleteAgent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/agents/{agentId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters['agentId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an Agent (and its keys) stored under an Organization.
     */
    async deleteAgent(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAgentRaw(requestParameters, initOverrides);
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * Delete an Application
     */
    async deleteApplicationRaw(requestParameters: DeleteApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteApplication().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deleteApplication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deleting an Application will also delete everything associated with it. This includes Environments, Deployment history on those Environments, and any shared values and secrets associated.  _Deletions are currently irreversible._
     * Delete an Application
     */
    async deleteApplication(requestParameters: DeleteApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteApplicationRaw(requestParameters, initOverrides);
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * Delete Artefact and all related Artefact Versions
     */
    async deleteArtefactRaw(requestParameters: DeleteArtefactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteArtefact().'
            );
        }

        if (requestParameters['artefactId'] == null) {
            throw new runtime.RequiredError(
                'artefactId',
                'Required parameter "artefactId" was null or undefined when calling deleteArtefact().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/artefacts/{artefactId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters['artefactId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The specified Artefact and its Artefact Versions will be permanently deleted. Only Administrators can delete an Artefact.
     * Delete Artefact and all related Artefact Versions
     */
    async deleteArtefact(requestParameters: DeleteArtefactRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteArtefactRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Automation Rule from an Environment.
     */
    async deleteAutomationRuleRaw(requestParameters: DeleteAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteAutomationRule().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deleteAutomationRule().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling deleteAutomationRule().'
            );
        }

        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling deleteAutomationRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"ruleId"}}`, encodeURIComponent(String(requestParameters['ruleId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Automation Rule from an Environment.
     */
    async deleteAutomationRule(requestParameters: DeleteAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAutomationRuleRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * Delete a specific Environment.
     */
    async deleteEnvironmentRaw(requestParameters: DeleteEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteEnvironment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deleteEnvironment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling deleteEnvironment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a specific Environment in an Application.  Deleting an Environment will also delete the Deployment history of the Environment.  _Deletions are currently irreversible._
     * Delete a specific Environment.
     */
    async deleteEnvironment(requestParameters: DeleteEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteEnvironmentRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * Deletes an Environment Type
     */
    async deleteEnvironmentTypeRaw(requestParameters: DeleteEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentTypeResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteEnvironmentType().'
            );
        }

        if (requestParameters['envTypeId'] == null) {
            throw new runtime.RequiredError(
                'envTypeId',
                'Required parameter "envTypeId" was null or undefined when calling deleteEnvironmentType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envTypeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envTypeId"}}`, encodeURIComponent(String(requestParameters['envTypeId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentTypeResponseFromJSON(jsonValue));
    }

    /**
     * Deletes a specific Environment Type from an Organization. If there are Environments with this Type in the Organization, the operation will fail.
     * Deletes an Environment Type
     */
    async deleteEnvironmentType(requestParameters: DeleteEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentTypeResponse> {
        const response = await this.deleteEnvironmentTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a key registered under a Agent.
     */
    async deleteKeyInAgentRaw(requestParameters: DeleteKeyInAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteKeyInAgent().'
            );
        }

        if (requestParameters['agentId'] == null) {
            throw new runtime.RequiredError(
                'agentId',
                'Required parameter "agentId" was null or undefined when calling deleteKeyInAgent().'
            );
        }

        if (requestParameters['fingerprint'] == null) {
            throw new runtime.RequiredError(
                'fingerprint',
                'Required parameter "fingerprint" was null or undefined when calling deleteKeyInAgent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/agents/{agentId}/keys/{fingerprint}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters['agentId']))).replace(`{${"fingerprint"}}`, encodeURIComponent(String(requestParameters['fingerprint']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a key registered under a Agent.
     */
    async deleteKeyInAgent(requestParameters: DeleteKeyInAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteKeyInAgentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a pipeline within an application.
     */
    async deletePipelineRaw(requestParameters: DeletePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deletePipeline().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deletePipeline().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling deletePipeline().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['If_Match'] != null) {
            headerParameters['If-Match'] = String(requestParameters['If_Match']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a pipeline within an application.
     */
    async deletePipeline(requestParameters: DeletePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePipelineRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the Pipeline Criteria with the given id.
     */
    async deletePipelineCriteriaRaw(requestParameters: DeletePipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deletePipelineCriteria().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deletePipelineCriteria().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling deletePipelineCriteria().'
            );
        }

        if (requestParameters['criteriaId'] == null) {
            throw new runtime.RequiredError(
                'criteriaId',
                'Required parameter "criteriaId" was null or undefined when calling deletePipelineCriteria().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"criteriaId"}}`, encodeURIComponent(String(requestParameters['criteriaId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the Pipeline Criteria with the given id.
     */
    async deletePipelineCriteria(requestParameters: DeletePipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePipelineCriteriaRaw(requestParameters, initOverrides);
    }

    /**
     * Deleting a completed Run within a Pipeline.
     */
    async deletePipelineRunRaw(requestParameters: DeletePipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deletePipelineRun().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deletePipelineRun().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling deletePipelineRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling deletePipelineRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['If_Match'] != null) {
            headerParameters['If-Match'] = String(requestParameters['If_Match']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deleting a completed Run within a Pipeline.
     */
    async deletePipelineRun(requestParameters: DeletePipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePipelineRunRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a public key associated to an organization.
     */
    async deletePublicKeyRaw(requestParameters: DeletePublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deletePublicKey().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling deletePublicKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/keys/{keyId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a public key associated to an organization.
     */
    async deletePublicKey(requestParameters: DeletePublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePublicKeyRaw(requestParameters, initOverrides);
    }

    /**
     * A Resource Account can be deleted if it is not referenced or referenced only by deleted Resource Definitions. Resource Definition Versions which reference the deleted Resource Account cannot be used in deployments. 
     * Delete an unused Resource Account.
     */
    async deleteResourceAccountRaw(requestParameters: DeleteResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteResourceAccount().'
            );
        }

        if (requestParameters['accId'] == null) {
            throw new runtime.RequiredError(
                'accId',
                'Required parameter "accId" was null or undefined when calling deleteResourceAccount().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts/{accId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"accId"}}`, encodeURIComponent(String(requestParameters['accId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * A Resource Account can be deleted if it is not referenced or referenced only by deleted Resource Definitions. Resource Definition Versions which reference the deleted Resource Account cannot be used in deployments. 
     * Delete an unused Resource Account.
     */
    async deleteResourceAccount(requestParameters: DeleteResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteResourceAccountRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a resource class.
     */
    async deleteResourceClassRaw(requestParameters: DeleteResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteResourceClass().'
            );
        }

        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling deleteResourceClass().'
            );
        }

        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling deleteResourceClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/types/{typeId}/classes/{classId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"typeId"}}`, encodeURIComponent(String(requestParameters['typeId']))).replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a resource class.
     */
    async deleteResourceClass(requestParameters: DeleteResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteResourceClassRaw(requestParameters, initOverrides);
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is deleted immediately even if there are Active Resources linked to it.   The Resource Definition that has been marked for deletion cannot be used to provision new resources.  With the next deployment, matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).
     * Delete a Resource Definition.
     */
    async deleteResourceDefinitionRaw(requestParameters: DeleteResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteResourceDefinition().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling deleteResourceDefinition().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * If there **are no** Active Resources provisioned via the current definition, the Resource Definition is deleted immediately.  If there **are** Active Resources provisioned via the current definition, the request fails. The response will describe the changes to the affected Active Resources if operation is forced.  The request can take an optional `force` query parameter. If set to `true`, the current Resource Definition is deleted immediately even if there are Active Resources linked to it.   The Resource Definition that has been marked for deletion cannot be used to provision new resources.  With the next deployment, matching criteria for Resources will be re-evaluated, and current Active Resources for the target environment would be either linked to another matching Resource Definition or decommissioned and created using the new or default Resource Definition (when available).
     * Delete a Resource Definition.
     */
    async deleteResourceDefinition(requestParameters: DeleteResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteResourceDefinitionRaw(requestParameters, initOverrides);
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * Delete a Matching Criteria from a Resource Definition.
     */
    async deleteResourceDefinitionCriteriaRaw(requestParameters: DeleteResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling deleteResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['criteriaId'] == null) {
            throw new runtime.RequiredError(
                'criteriaId',
                'Required parameter "criteriaId" was null or undefined when calling deleteResourceDefinitionCriteria().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['force'] != null) {
            queryParameters['force'] = requestParameters['force'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/criteria/{criteriaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))).replace(`{${"criteriaId"}}`, encodeURIComponent(String(requestParameters['criteriaId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * If there **are no** Active Resources that would match to a different Resource Definition when the current Matching Criteria is deleted, the Matching Criteria is deleted immediately.  If there **are** Active Resources that would match to a different Resource Definition, the request fails with HTTP status code 409 (Conflict). The response content will list all of affected Active Resources and their new matches.  The request can take an optional `force` query parameter. If set to `true`, the Matching Criteria is deleted immediately. Referenced Active Resources would match to a different Resource Definition during the next deployment in the target environment.
     * Delete a Matching Criteria from a Resource Definition.
     */
    async deleteResourceDefinitionCriteria(requestParameters: DeleteResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteResourceDefinitionCriteriaRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a Resources Driver.
     */
    async deleteResourceDriverRaw(requestParameters: DeleteResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteResourceDriver().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling deleteResourceDriver().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/drivers/{driverId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"driverId"}}`, encodeURIComponent(String(requestParameters['driverId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Resources Driver.
     */
    async deleteResourceDriver(requestParameters: DeleteResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteResourceDriverRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the role of a User or a Group on an Application
     */
    async deleteUserRoleInAppRaw(requestParameters: DeleteUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteUserRoleInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling deleteUserRoleInApp().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUserRoleInApp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the role of a User or a Group on an Application
     */
    async deleteUserRoleInApp(requestParameters: DeleteUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRoleInAppRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the role of a User on an Environment Type
     */
    async deleteUserRoleInEnvTypeRaw(requestParameters: DeleteUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteUserRoleInEnvType().'
            );
        }

        if (requestParameters['envType'] == null) {
            throw new runtime.RequiredError(
                'envType',
                'Required parameter "envType" was null or undefined when calling deleteUserRoleInEnvType().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUserRoleInEnvType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envType}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envType"}}`, encodeURIComponent(String(requestParameters['envType']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the role of a User on an Environment Type
     */
    async deleteUserRoleInEnvType(requestParameters: DeleteUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRoleInEnvTypeRaw(requestParameters, initOverrides);
    }

    /**
     * Remove the role of a User on an Organization
     */
    async deleteUserRoleInOrgRaw(requestParameters: DeleteUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteUserRoleInOrg().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUserRoleInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove the role of a User on an Organization
     */
    async deleteUserRoleInOrg(requestParameters: DeleteUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRoleInOrgRaw(requestParameters, initOverrides);
    }

    /**
     * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
     * Deletes a specific token associated with a user
     */
    async deleteUserTokenRaw(requestParameters: DeleteUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling deleteUserToken().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteUserToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{userId}/tokens/{tokenId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This endpoint deletes a user\'s session token. The deleted token can no longer be used to access the API. All other tokens for this user can still be used.
     * Deletes a specific token associated with a user
     */
    async deleteUserToken(requestParameters: DeleteUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserTokenRaw(requestParameters, initOverrides);
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * Delete a Workload Profile
     */
    async deleteWorkloadProfileRaw(requestParameters: DeleteWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling deleteWorkloadProfile().'
            );
        }

        if (requestParameters['profileQid'] == null) {
            throw new runtime.RequiredError(
                'profileQid',
                'Required parameter "profileQid" was null or undefined when calling deleteWorkloadProfile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles/{profileQid}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"profileQid"}}`, encodeURIComponent(String(requestParameters['profileQid']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This will also delete all versions of a workload profile.  It is not possible to delete profiles of other organizations.
     * Delete a Workload Profile
     */
    async deleteWorkloadProfile(requestParameters: DeleteWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWorkloadProfileRaw(requestParameters, initOverrides);
    }

    /**
     * Deny the approval requested.
     * Deny the approval request
     */
    async denyPipelineApprovalRequestRaw(requestParameters: DenyPipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineApprovalRequest>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        if (requestParameters['approvalId'] == null) {
            throw new runtime.RequiredError(
                'approvalId',
                'Required parameter "approvalId" was null or undefined when calling denyPipelineApprovalRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}/deny`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))).replace(`{${"approvalId"}}`, encodeURIComponent(String(requestParameters['approvalId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineApprovalRequestFromJSON(jsonValue));
    }

    /**
     * Deny the approval requested.
     * Deny the approval request
     */
    async denyPipelineApprovalRequest(requestParameters: DenyPipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineApprovalRequest> {
        const response = await this.denyPipelineApprovalRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * Get an existing Application
     */
    async getApplicationRaw(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getApplication().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getApplication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific Application in the specified Organization by ID.
     * Get an existing Application
     */
    async getApplication(requestParameters: GetApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationResponse> {
        const response = await this.getApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific Artefact Version.
     * Get an Artefacts Versions.
     */
    async getArtefactVersionRaw(requestParameters: GetArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ArtefactVersion>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getArtefactVersion().'
            );
        }

        if (requestParameters['artefactVersionId'] == null) {
            throw new runtime.RequiredError(
                'artefactVersionId',
                'Required parameter "artefactVersionId" was null or undefined when calling getArtefactVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions/{artefactVersionId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(requestParameters['artefactVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactVersionFromJSON(jsonValue));
    }

    /**
     * Returns a specific Artefact Version.
     * Get an Artefacts Versions.
     */
    async getArtefactVersion(requestParameters: GetArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ArtefactVersion> {
        const response = await this.getArtefactVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a specific Automation Rule for an Environment.
     */
    async getAutomationRuleRaw(requestParameters: GetAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutomationRuleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getAutomationRule().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getAutomationRule().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling getAutomationRule().'
            );
        }

        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling getAutomationRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"ruleId"}}`, encodeURIComponent(String(requestParameters['ruleId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationRuleResponseFromJSON(jsonValue));
    }

    /**
     * Get a specific Automation Rule for an Environment.
     */
    async getAutomationRule(requestParameters: GetAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutomationRuleResponse> {
        const response = await this.getAutomationRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Read the current state of a trigger batch for a Pipeline if one exists
     * Read the current state of a trigger batch
     */
    async getBatchRaw(requestParameters: GetBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Batch>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getBatch().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getBatch().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getBatch().'
            );
        }

        if (requestParameters['batchType'] == null) {
            throw new runtime.RequiredError(
                'batchType',
                'Required parameter "batchType" was null or undefined when calling getBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/batches/{batchType}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"batchType"}}`, encodeURIComponent(String(requestParameters['batchType']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchFromJSON(jsonValue));
    }

    /**
     * Read the current state of a trigger batch for a Pipeline if one exists
     * Read the current state of a trigger batch
     */
    async getBatch(requestParameters: GetBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Batch> {
        const response = await this.getBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the extended profile of the current user
     */
    async getCurrentUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfileExtendedResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/current-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileExtendedResponseFromJSON(jsonValue));
    }

    /**
     * Gets the extended profile of the current user
     */
    async getCurrentUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfileExtendedResponse> {
        const response = await this.getCurrentUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * Fetch an existing Delta
     */
    async getDeltaRaw(requestParameters: GetDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeltaResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling getDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeltaResponseFromJSON(jsonValue));
    }

    /**
     * Fetch an existing Delta
     */
    async getDelta(requestParameters: GetDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeltaResponse> {
        const response = await this.getDeltaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a Dependency Graph by its ID.
     */
    async getDependencyGraphRaw(requestParameters: GetDependencyGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DependencyGraphResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getDependencyGraph().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getDependencyGraph().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling getDependencyGraph().'
            );
        }

        if (requestParameters['graphId'] == null) {
            throw new runtime.RequiredError(
                'graphId',
                'Required parameter "graphId" was null or undefined when calling getDependencyGraph().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graphs/{graphId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"graphId"}}`, encodeURIComponent(String(requestParameters['graphId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DependencyGraphResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a Dependency Graph by its ID.
     */
    async getDependencyGraph(requestParameters: GetDependencyGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DependencyGraphResponse> {
        const response = await this.getDependencyGraphRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * Get a specific Deployment.
     */
    async getDeploymentRaw(requestParameters: GetDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeploymentResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getDeployment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getDeployment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling getDeployment().'
            );
        }

        if (requestParameters['deployId'] == null) {
            throw new runtime.RequiredError(
                'deployId',
                'Required parameter "deployId" was null or undefined when calling getDeployment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"deployId"}}`, encodeURIComponent(String(requestParameters['deployId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeploymentResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific Deployment in an Application and an Environment.
     * Get a specific Deployment.
     */
    async getDeployment(requestParameters: GetDeploymentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeploymentResponse> {
        const response = await this.getDeploymentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * Get a specific Image Object
     */
    async getDeprecatedImageRaw(requestParameters: GetDeprecatedImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getDeprecatedImage().'
            );
        }

        if (requestParameters['imageId'] == null) {
            throw new runtime.RequiredError(
                'imageId',
                'Required parameter "imageId" was null or undefined when calling getDeprecatedImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/images/{imageId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"imageId"}}`, encodeURIComponent(String(requestParameters['imageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageResponseFromJSON(jsonValue));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response includes a list of Image Builds as well as some metadata about the Image such as its Image Source.  Note, `imageId` may not be the same as the container name. `imageId` is determined by the system making notifications about new builds.
     * Get a specific Image Object
     */
    async getDeprecatedImage(requestParameters: GetDeprecatedImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageResponse> {
        const response = await this.getDeprecatedImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the difference between 2 Deployment Sets
     */
    async getDiffRaw(requestParameters: GetDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlainDeltaResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getDiff().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getDiff().'
            );
        }

        if (requestParameters['setId'] == null) {
            throw new runtime.RequiredError(
                'setId',
                'Required parameter "setId" was null or undefined when calling getDiff().'
            );
        }

        if (requestParameters['sourceSetId'] == null) {
            throw new runtime.RequiredError(
                'sourceSetId',
                'Required parameter "sourceSetId" was null or undefined when calling getDiff().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/sets/{setId}/diff/{sourceSetId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"setId"}}`, encodeURIComponent(String(requestParameters['setId']))).replace(`{${"sourceSetId"}}`, encodeURIComponent(String(requestParameters['sourceSetId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlainDeltaResponseFromJSON(jsonValue));
    }

    /**
     * Get the difference between 2 Deployment Sets
     */
    async getDiff(requestParameters: GetDiffRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlainDeltaResponse> {
        const response = await this.getDiffRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific Environment in an Application.
     * Get a specific Environment.
     */
    async getEnvironmentRaw(requestParameters: GetEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getEnvironment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getEnvironment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling getEnvironment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific Environment in an Application.
     * Get a specific Environment.
     */
    async getEnvironment(requestParameters: GetEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentResponse> {
        const response = await this.getEnvironmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * Get an Environment Type
     */
    async getEnvironmentTypeRaw(requestParameters: GetEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentTypeResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getEnvironmentType().'
            );
        }

        if (requestParameters['envTypeId'] == null) {
            throw new runtime.RequiredError(
                'envTypeId',
                'Required parameter "envTypeId" was null or undefined when calling getEnvironmentType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envTypeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envTypeId"}}`, encodeURIComponent(String(requestParameters['envTypeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentTypeResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific Environment Type within an Organization.
     * Get an Environment Type
     */
    async getEnvironmentType(requestParameters: GetEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentTypeResponse> {
        const response = await this.getEnvironmentTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the latest pipeline schema
     */
    async getLatestPipelineDefinitionSchemaRaw(requestParameters: GetLatestPipelineDefinitionSchemaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getLatestPipelineDefinitionSchema().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/pipeline-schemas/latest`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Gets the latest pipeline schema
     */
    async getLatestPipelineDefinitionSchema(requestParameters: GetLatestPipelineDefinitionSchemaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getLatestPipelineDefinitionSchemaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Latest version of the given workload profile with optional constraint.
     * @deprecated
     */
    async getLatestWorkloadProfileVersionRaw(requestParameters: GetLatestWorkloadProfileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadProfileVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getLatestWorkloadProfileVersion().'
            );
        }

        if (requestParameters['profileQid'] == null) {
            throw new runtime.RequiredError(
                'profileQid',
                'Required parameter "profileQid" was null or undefined when calling getLatestWorkloadProfileVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles/{profileQid}/versions/latest`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"profileQid"}}`, encodeURIComponent(String(requestParameters['profileQid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadProfileVersionResponseFromJSON(jsonValue));
    }

    /**
     * Latest version of the given workload profile with optional constraint.
     * @deprecated
     */
    async getLatestWorkloadProfileVersion(requestParameters: GetLatestWorkloadProfileVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadProfileVersionResponse> {
        const response = await this.getLatestWorkloadProfileVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the specified Organization.
     */
    async getOrganizationRaw(requestParameters: GetOrganizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrganizationResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getOrganization().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrganizationResponseFromJSON(jsonValue));
    }

    /**
     * Get the specified Organization.
     */
    async getOrganization(requestParameters: GetOrganizationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrganizationResponse> {
        const response = await this.getOrganizationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Pipeline within an Application.
     */
    async getPipelineRaw(requestParameters: GetPipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Pipeline>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipeline().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipeline().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipeline().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineFromJSON(jsonValue));
    }

    /**
     * Get a Pipeline within an Application.
     */
    async getPipeline(requestParameters: GetPipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Pipeline> {
        const response = await this.getPipelineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an approval request.
     * Get an approval request
     */
    async getPipelineApprovalRequestRaw(requestParameters: GetPipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineApprovalRequest>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        if (requestParameters['approvalId'] == null) {
            throw new runtime.RequiredError(
                'approvalId',
                'Required parameter "approvalId" was null or undefined when calling getPipelineApprovalRequest().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/approvals/{approvalId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))).replace(`{${"approvalId"}}`, encodeURIComponent(String(requestParameters['approvalId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineApprovalRequestFromJSON(jsonValue));
    }

    /**
     * Get an approval request.
     * Get an approval request
     */
    async getPipelineApprovalRequest(requestParameters: GetPipelineApprovalRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineApprovalRequest> {
        const response = await this.getPipelineApprovalRequestRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the Pipeline Criteria with the given id.
     */
    async getPipelineCriteriaRaw(requestParameters: GetPipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineCriteria>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipelineCriteria().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipelineCriteria().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipelineCriteria().'
            );
        }

        if (requestParameters['criteriaId'] == null) {
            throw new runtime.RequiredError(
                'criteriaId',
                'Required parameter "criteriaId" was null or undefined when calling getPipelineCriteria().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/criteria/{criteriaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"criteriaId"}}`, encodeURIComponent(String(requestParameters['criteriaId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineCriteriaFromJSON(jsonValue));
    }

    /**
     * Get the Pipeline Criteria with the given id.
     */
    async getPipelineCriteria(requestParameters: GetPipelineCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineCriteria> {
        const response = await this.getPipelineCriteriaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a pipeline schema.
     */
    async getPipelineDefinitionRaw(requestParameters: GetPipelineDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipelineDefinition().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipelineDefinition().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipelineDefinition().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['Accept'] != null) {
            headerParameters['Accept'] = String(requestParameters['Accept']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/schema`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get a pipeline schema.
     */
    async getPipelineDefinition(requestParameters: GetPipelineDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getPipelineDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the details of a Job including Step information
     */
    async getPipelineJobRaw(requestParameters: GetPipelineJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineJob>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipelineJob().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipelineJob().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipelineJob().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling getPipelineJob().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling getPipelineJob().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineJobFromJSON(jsonValue));
    }

    /**
     * List the details of a Job including Step information
     */
    async getPipelineJob(requestParameters: GetPipelineJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineJob> {
        const response = await this.getPipelineJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a run within an pipeline.
     */
    async getPipelineRunRaw(requestParameters: GetPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineRun>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPipelineRun().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getPipelineRun().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling getPipelineRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling getPipelineRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineRunFromJSON(jsonValue));
    }

    /**
     * Get a run within an pipeline.
     */
    async getPipelineRun(requestParameters: GetPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineRun> {
        const response = await this.getPipelineRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a single public key associated to an organization.
     */
    async getPublicKeyRaw(requestParameters: GetPublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PublicKey>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getPublicKey().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getPublicKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/keys/{keyId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PublicKeyFromJSON(jsonValue));
    }

    /**
     * Retrieve a single public key associated to an organization.
     */
    async getPublicKey(requestParameters: GetPublicKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PublicKey> {
        const response = await this.getPublicKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Resource Account.
     */
    async getResourceAccountRaw(requestParameters: GetResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceAccountResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getResourceAccount().'
            );
        }

        if (requestParameters['accId'] == null) {
            throw new runtime.RequiredError(
                'accId',
                'Required parameter "accId" was null or undefined when calling getResourceAccount().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts/{accId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"accId"}}`, encodeURIComponent(String(requestParameters['accId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceAccountResponseFromJSON(jsonValue));
    }

    /**
     * Get a Resource Account.
     */
    async getResourceAccount(requestParameters: GetResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceAccountResponse> {
        const response = await this.getResourceAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get resource class by ID.
     */
    async getResourceClassRaw(requestParameters: GetResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceClassResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getResourceClass().'
            );
        }

        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling getResourceClass().'
            );
        }

        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling getResourceClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/types/{typeId}/classes/{classId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"typeId"}}`, encodeURIComponent(String(requestParameters['typeId']))).replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceClassResponseFromJSON(jsonValue));
    }

    /**
     * Get resource class by ID.
     */
    async getResourceClass(requestParameters: GetResourceClassRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceClassResponse> {
        const response = await this.getResourceClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * If the resource is marked as deleted it is not shown in the response, unless specified via `deleted` query parameter.
     * Get a Resource Definition.
     */
    async getResourceDefinitionRaw(requestParameters: GetResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getResourceDefinition().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling getResourceDefinition().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deleted'] != null) {
            queryParameters['deleted'] = requestParameters['deleted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * If the resource is marked as deleted it is not shown in the response, unless specified via `deleted` query parameter.
     * Get a Resource Definition.
     */
    async getResourceDefinition(requestParameters: GetResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceDefinitionResponse> {
        const response = await this.getResourceDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Resource Definition Version.
     */
    async getResourceDefinitionVersionRaw(requestParameters: GetResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceDefinitionVersion>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling getResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defVersionId'] == null) {
            throw new runtime.RequiredError(
                'defVersionId',
                'Required parameter "defVersionId" was null or undefined when calling getResourceDefinitionVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/versions/{defVersionId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))).replace(`{${"defVersionId"}}`, encodeURIComponent(String(requestParameters['defVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceDefinitionVersionFromJSON(jsonValue));
    }

    /**
     * Get a Resource Definition Version.
     */
    async getResourceDefinitionVersion(requestParameters: GetResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceDefinitionVersion> {
        const response = await this.getResourceDefinitionVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * Get a Resource Driver.
     */
    async getResourceDriverRaw(requestParameters: GetResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DriverDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getResourceDriver().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling getResourceDriver().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/drivers/{driverId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"driverId"}}`, encodeURIComponent(String(requestParameters['driverId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DriverDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * # Only drivers that belongs to the given organization or registered as `public` are accessible through this endpoint
     * Get a Resource Driver.
     */
    async getResourceDriver(requestParameters: GetResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DriverDefinitionResponse> {
        const response = await this.getResourceDriverRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Runtime info are fetched from the cluster provisioned by the Orchestrator with Resource Id `k8s-cluster-runtime`. If no cluster with that id is found, the system fetches information from a cluster provisioned with the default Resource Id  `k8s-cluster`.
     * Get Runtime information about the environment.
     */
    async getRuntimeRaw(requestParameters: GetRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuntimeInfoResponseV1>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getRuntime().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getRuntime().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling getRuntime().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuntimeInfoResponseV1FromJSON(jsonValue));
    }

    /**
     * Runtime info are fetched from the cluster provisioned by the Orchestrator with Resource Id `k8s-cluster-runtime`. If no cluster with that id is found, the system fetches information from a cluster provisioned with the default Resource Id  `k8s-cluster`.
     * Get Runtime information about the environment.
     */
    async getRuntime(requestParameters: GetRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuntimeInfoResponseV1> {
        const response = await this.getRuntimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Deployment Set
     */
    async getSetRaw(requestParameters: GetSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSet200Response>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getSet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getSet().'
            );
        }

        if (requestParameters['setId'] == null) {
            throw new runtime.RequiredError(
                'setId',
                'Required parameter "setId" was null or undefined when calling getSet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['diff'] != null) {
            queryParameters['diff'] = requestParameters['diff'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/sets/{setId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"setId"}}`, encodeURIComponent(String(requestParameters['setId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a Deployment Set
     */
    async getSet(requestParameters: GetSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSet200Response> {
        const response = await this.getSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Resource Inputs for the given Deployment Set
     */
    async getSetResourceInputsRaw(requestParameters: GetSetResourceInputsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceInputsResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getSetResourceInputs().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getSetResourceInputs().'
            );
        }

        if (requestParameters['setId'] == null) {
            throw new runtime.RequiredError(
                'setId',
                'Required parameter "setId" was null or undefined when calling getSetResourceInputs().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/sets/{setId}/resources`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"setId"}}`, encodeURIComponent(String(requestParameters['setId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceInputsResponseFromJSON));
    }

    /**
     * Get Resource Inputs for the given Deployment Set
     */
    async getSetResourceInputs(requestParameters: GetSetResourceInputsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceInputsResponse>> {
        const response = await this.getSetResourceInputsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the role of a User or a Group on an Application
     */
    async getUserRoleInAppRaw(requestParameters: GetUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getUserRoleInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling getUserRoleInApp().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getUserRoleInApp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Get the role of a User or a Group on an Application
     */
    async getUserRoleInApp(requestParameters: GetUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.getUserRoleInAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the role of a User or a Group on an Environment Type
     */
    async getUserRoleInEnvTypeRaw(requestParameters: GetUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getUserRoleInEnvType().'
            );
        }

        if (requestParameters['envType'] == null) {
            throw new runtime.RequiredError(
                'envType',
                'Required parameter "envType" was null or undefined when calling getUserRoleInEnvType().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getUserRoleInEnvType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envType}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envType"}}`, encodeURIComponent(String(requestParameters['envType']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Get the role of a User or a Group on an Environment Type
     */
    async getUserRoleInEnvType(requestParameters: GetUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.getUserRoleInEnvTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the role of a User on an Organization
     */
    async getUserRoleInOrgRaw(requestParameters: GetUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getUserRoleInOrg().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getUserRoleInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Get the role of a User on an Organization
     */
    async getUserRoleInOrg(requestParameters: GetUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.getUserRoleInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets a specific token associated with a user
     */
    async getUserTokenRaw(requestParameters: GetUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenInfoResponse>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling getUserToken().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getUserToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{userId}/tokens/{tokenId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenInfoResponseFromJSON(jsonValue));
    }

    /**
     * Gets a specific token associated with a user
     */
    async getUserToken(requestParameters: GetUserTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenInfoResponse> {
        const response = await this.getUserTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * Get the Humanitec module definition of this Workload Artefact Version as a deployment set
     */
    async getWorkloadArtefactVersionDeploymentSetRaw(requestParameters: GetWorkloadArtefactVersionDeploymentSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadArtefactVersionDeploymentSet>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getWorkloadArtefactVersionDeploymentSet().'
            );
        }

        if (requestParameters['artefactVersionId'] == null) {
            throw new runtime.RequiredError(
                'artefactVersionId',
                'Required parameter "artefactVersionId" was null or undefined when calling getWorkloadArtefactVersionDeploymentSet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['Accept'] != null) {
            headerParameters['Accept'] = String(requestParameters['Accept']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-deployment-set`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(requestParameters['artefactVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadArtefactVersionDeploymentSetFromJSON(jsonValue));
    }

    /**
     * Returns the Humanitec workload module of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * Get the Humanitec module definition of this Workload Artefact Version as a deployment set
     */
    async getWorkloadArtefactVersionDeploymentSet(requestParameters: GetWorkloadArtefactVersionDeploymentSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadArtefactVersionDeploymentSet> {
        const response = await this.getWorkloadArtefactVersionDeploymentSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * Get the spec of this Workload Artefact Version
     */
    async getWorkloadArtefactVersionSpecRaw(requestParameters: GetWorkloadArtefactVersionSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: any; }>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getWorkloadArtefactVersionSpec().'
            );
        }

        if (requestParameters['artefactVersionId'] == null) {
            throw new runtime.RequiredError(
                'artefactVersionId',
                'Required parameter "artefactVersionId" was null or undefined when calling getWorkloadArtefactVersionSpec().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['Accept'] != null) {
            headerParameters['Accept'] = String(requestParameters['Accept']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions/{artefactVersionId}/workload-spec`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactVersionId"}}`, encodeURIComponent(String(requestParameters['artefactVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns the spec of this Artefact Version if it is of type workload. An error will be returned if it is not. 
     * Get the spec of this Workload Artefact Version
     */
    async getWorkloadArtefactVersionSpec(requestParameters: GetWorkloadArtefactVersionSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: any; }> {
        const response = await this.getWorkloadArtefactVersionSpecRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a Workload Profile
     */
    async getWorkloadProfileRaw(requestParameters: GetWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadProfileResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling getWorkloadProfile().'
            );
        }

        if (requestParameters['profileQid'] == null) {
            throw new runtime.RequiredError(
                'profileQid',
                'Required parameter "profileQid" was null or undefined when calling getWorkloadProfile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles/{profileQid}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"profileQid"}}`, encodeURIComponent(String(requestParameters['profileQid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadProfileResponseFromJSON(jsonValue));
    }

    /**
     * Get a Workload Profile
     */
    async getWorkloadProfile(requestParameters: GetWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadProfileResponse> {
        const response = await this.getWorkloadProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Active Resources provisioned via a specific Resource Definition.
     */
    async listActiveResourceByDefinitionRaw(requestParameters: ListActiveResourceByDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ActiveResourceResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listActiveResourceByDefinition().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling listActiveResourceByDefinition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/resources`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActiveResourceResponseFromJSON));
    }

    /**
     * List Active Resources provisioned via a specific Resource Definition.
     */
    async listActiveResourceByDefinition(requestParameters: ListActiveResourceByDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ActiveResourceResponse>> {
        const response = await this.listActiveResourceByDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Active Resources provisioned in an environment.
     */
    async listActiveResourcesRaw(requestParameters: ListActiveResourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ActiveResourceResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listActiveResources().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listActiveResources().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling listActiveResources().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['scheduled_deletion'] != null) {
            queryParameters['scheduled_deletion'] = requestParameters['scheduled_deletion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ActiveResourceResponseFromJSON));
    }

    /**
     * List Active Resources provisioned in an environment.
     */
    async listActiveResources(requestParameters: ListActiveResourcesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ActiveResourceResponse>> {
        const response = await this.listActiveResourcesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the agents in an Organization.
     */
    async listAgentsRaw(requestParameters: ListAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Agent>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listAgents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fingerprint'] != null) {
            queryParameters['fingerprint'] = requestParameters['fingerprint'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/agents`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AgentFromJSON));
    }

    /**
     * List all the agents in an Organization.
     */
    async listAgents(requestParameters: ListAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Agent>> {
        const response = await this.listAgentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * List all Applications in an Organization.
     */
    async listApplicationsRaw(requestParameters: ListApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApplicationResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listApplications().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApplicationResponseFromJSON));
    }

    /**
     * Listing or lists of all Applications that exist within a specific Organization.
     * List all Applications in an Organization.
     */
    async listApplications(requestParameters: ListApplicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApplicationResponse>> {
        const response = await this.listApplicationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefact Versions of an Artefact.
     */
    async listArtefactVersionsRaw(requestParameters: ListArtefactVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ArtefactVersion>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listArtefactVersions().'
            );
        }

        if (requestParameters['artefactId'] == null) {
            throw new runtime.RequiredError(
                'artefactId',
                'Required parameter "artefactId" was null or undefined when calling listArtefactVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['reference'] != null) {
            queryParameters['reference'] = requestParameters['reference'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/artefacts/{artefactId}/versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters['artefactId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ArtefactVersionFromJSON));
    }

    /**
     * Returns the Artefact Versions of a specified Artefact registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefact Versions of an Artefact.
     */
    async listArtefactVersions(requestParameters: ListArtefactVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ArtefactVersion>> {
        const response = await this.listArtefactVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefacts Versions in the org.
     */
    async listArtefactVersionsInOrgRaw(requestParameters: ListArtefactVersionsInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ArtefactVersion>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listArtefactVersionsInOrg().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['reference'] != null) {
            queryParameters['reference'] = requestParameters['reference'];
        }

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/artefact-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ArtefactVersionFromJSON));
    }

    /**
     * Returns the Artefact Versions registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefacts Versions in the org.
     */
    async listArtefactVersionsInOrg(requestParameters: ListArtefactVersionsInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ArtefactVersion>> {
        const response = await this.listArtefactVersionsInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefacts.
     */
    async listArtefactsRaw(requestParameters: ListArtefactsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ArtefactResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listArtefacts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/artefacts`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ArtefactResponseFromJSON));
    }

    /**
     * Returns the Artefacts registered with your organization. If no elements are found, an empty list is returned.
     * List all Artefacts.
     */
    async listArtefacts(requestParameters: ListArtefactsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ArtefactResponse>> {
        const response = await this.listArtefactsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
     * List audit log entries by Organization
     */
    async listAuditLogEntriesRaw(requestParameters: ListAuditLogEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AuditLogEntry>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listAuditLogEntries().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['from'] != null) {
            queryParameters['from'] = (requestParameters['from'] as any).toISOString();
        }

        if (requestParameters['to'] != null) {
            queryParameters['to'] = (requestParameters['to'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/audit-logs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditLogEntryFromJSON));
    }

    /**
     * List all available audit log entries in the Organization that match the specified filters. This API returns entries from newest to oldest and is paginated. Only successful create, modify, or delete requests are stored in  the audit log. This API may return a lot of data, depending on the size of the Organization, so it is  recommended to use the \"to\" and \"from\" query parameters to limit the returned data to the time window of interest. Each response contains at most 32 days worth of data for performance reasons and may be empty if no records exist within that time range. Pagination links in the \'Link\' header should always be followed when present. This API requires administrator permissions in the Organization. 
     * List audit log entries by Organization
     */
    async listAuditLogEntries(requestParameters: ListAuditLogEntriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AuditLogEntry>> {
        const response = await this.listAuditLogEntriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all Automation Rules in an Environment.
     */
    async listAutomationRulesRaw(requestParameters: ListAutomationRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AutomationRuleResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listAutomationRules().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listAutomationRules().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling listAutomationRules().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AutomationRuleResponseFromJSON));
    }

    /**
     * List all Automation Rules in an Environment.
     */
    async listAutomationRules(requestParameters: ListAutomationRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AutomationRuleResponse>> {
        const response = await this.listAutomationRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Deltas in an Application
     */
    async listDeltasRaw(requestParameters: ListDeltasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DeltaResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listDeltas().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listDeltas().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['archived'] != null) {
            queryParameters['archived'] = requestParameters['archived'];
        }

        if (requestParameters['env'] != null) {
            queryParameters['env'] = requestParameters['env'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeltaResponseFromJSON));
    }

    /**
     * List Deltas in an Application
     */
    async listDeltas(requestParameters: ListDeltasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DeltaResponse>> {
        const response = await this.listDeltasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List errors that occurred in a Deployment.
     */
    async listDeploymentErrorsRaw(requestParameters: ListDeploymentErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DeploymentErrorResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listDeploymentErrors().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listDeploymentErrors().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling listDeploymentErrors().'
            );
        }

        if (requestParameters['deployId'] == null) {
            throw new runtime.RequiredError(
                'deployId',
                'Required parameter "deployId" was null or undefined when calling listDeploymentErrors().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys/{deployId}/errors`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"deployId"}}`, encodeURIComponent(String(requestParameters['deployId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeploymentErrorResponseFromJSON));
    }

    /**
     * List errors that occurred in a Deployment.
     */
    async listDeploymentErrors(requestParameters: ListDeploymentErrorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DeploymentErrorResponse>> {
        const response = await this.listDeploymentErrorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * List Deployments in an Environment.
     */
    async listDeploymentsRaw(requestParameters: ListDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DeploymentResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listDeployments().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listDeployments().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling listDeployments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pipelineRunId'] != null) {
            queryParameters['pipelineRunId'] = requestParameters['pipelineRunId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/deploys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DeploymentResponseFromJSON));
    }

    /**
     * List all of the Deployments that have been carried out in the current Environment. Deployments are returned with the newest first.
     * List Deployments in an Environment.
     */
    async listDeployments(requestParameters: ListDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DeploymentResponse>> {
        const response = await this.listDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * Lists all the Builds of an Image
     */
    async listDeprecatedImageBuildsRaw(requestParameters: ListDeprecatedImageBuildsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ImageBuildResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listDeprecatedImageBuilds().'
            );
        }

        if (requestParameters['imageId'] == null) {
            throw new runtime.RequiredError(
                'imageId',
                'Required parameter "imageId" was null or undefined when calling listDeprecatedImageBuilds().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/images/{imageId}/builds`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"imageId"}}`, encodeURIComponent(String(requestParameters['imageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ImageBuildResponseFromJSON));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  The response lists all available Image Builds of an Image.
     * Lists all the Builds of an Image
     */
    async listDeprecatedImageBuilds(requestParameters: ListDeprecatedImageBuildsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ImageBuildResponse>> {
        const response = await this.listDeprecatedImageBuildsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * List all Container Images
     */
    async listDeprecatedImagesRaw(requestParameters: ListDeprecatedImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ImageResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listDeprecatedImages().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/images`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ImageResponseFromJSON));
    }

    /**
     * DEPRECATED: This endpoint exists for historical compatibility and should not be used. Please use the [Artefact API](https://api-docs.humanitec.com/#tag/Artefact) instead.  Lists all of the Container Images registered for this organization.
     * List all Container Images
     */
    async listDeprecatedImages(requestParameters: ListDeprecatedImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ImageResponse>> {
        const response = await this.listDeprecatedImagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all Environment Types in an Organization.
     * List all Environment Types
     */
    async listEnvironmentTypesRaw(requestParameters: ListEnvironmentTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EnvironmentTypeResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listEnvironmentTypes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnvironmentTypeResponseFromJSON));
    }

    /**
     * Lists all Environment Types in an Organization.
     * List all Environment Types
     */
    async listEnvironmentTypes(requestParameters: ListEnvironmentTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EnvironmentTypeResponse>> {
        const response = await this.listEnvironmentTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all of the Environments in the Application.
     * List all Environments.
     */
    async listEnvironmentsRaw(requestParameters: ListEnvironmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EnvironmentResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listEnvironments().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listEnvironments().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnvironmentResponseFromJSON));
    }

    /**
     * Lists all of the Environments in the Application.
     * List all Environments.
     */
    async listEnvironments(requestParameters: ListEnvironmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EnvironmentResponse>> {
        const response = await this.listEnvironmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List users in a group.
     */
    async listGroupUsersRaw(requestParameters: ListGroupUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserProfileResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listGroupUsers().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling listGroupUsers().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/groups/{groupId}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"groupId"}}`, encodeURIComponent(String(requestParameters['groupId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserProfileResponseFromJSON));
    }

    /**
     * List users in a group.
     */
    async listGroupUsers(requestParameters: ListGroupUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserProfileResponse>> {
        const response = await this.listGroupUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the public keys Humanitec shares with an organization.
     */
    async listHumanitecPublicKeysRaw(requestParameters: ListHumanitecPublicKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<HumanitecPublicKey>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listHumanitecPublicKeys().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['active'] != null) {
            queryParameters['active'] = requestParameters['active'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/humanitec-keys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(HumanitecPublicKeyFromJSON));
    }

    /**
     * List all the public keys Humanitec shares with an organization.
     */
    async listHumanitecPublicKeys(requestParameters: ListHumanitecPublicKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<HumanitecPublicKey>> {
        const response = await this.listHumanitecPublicKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the invites issued for the organization.
     */
    async listInvitesInOrgRaw(requestParameters: ListInvitesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserInviteResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listInvitesInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/invitations`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserInviteResponseFromJSON));
    }

    /**
     * List the invites issued for the organization.
     */
    async listInvitesInOrg(requestParameters: ListInvitesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserInviteResponse>> {
        const response = await this.listInvitesInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all the keys registered under an Agent in an Organization.
     */
    async listKeysInAgentRaw(requestParameters: ListKeysInAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Key>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listKeysInAgent().'
            );
        }

        if (requestParameters['agentId'] == null) {
            throw new runtime.RequiredError(
                'agentId',
                'Required parameter "agentId" was null or undefined when calling listKeysInAgent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/agents/{agentId}/keys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters['agentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(KeyFromJSON));
    }

    /**
     * List all the keys registered under an Agent in an Organization.
     */
    async listKeysInAgent(requestParameters: ListKeysInAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Key>> {
        const response = await this.listKeysInAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List active organizations the user has access to.
     */
    async listOrganizationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OrganizationResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OrganizationResponseFromJSON));
    }

    /**
     * List active organizations the user has access to.
     */
    async listOrganizations(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OrganizationResponse>> {
        const response = await this.listOrganizationsRaw(initOverrides);
        return await response.value();
    }

    /**
     * List of the approval requests with in an app. 
     * List of the approval requests
     */
    async listPipelineApprovalRequestsRaw(requestParameters: ListPipelineApprovalRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineApprovalRequest>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineApprovalRequests().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineApprovalRequests().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pipeline'] != null) {
            queryParameters['pipeline'] = requestParameters['pipeline'];
        }

        if (requestParameters['run'] != null) {
            queryParameters['run'] = requestParameters['run'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/approvals`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineApprovalRequestFromJSON));
    }

    /**
     * List of the approval requests with in an app. 
     * List of the approval requests
     */
    async listPipelineApprovalRequests(requestParameters: ListPipelineApprovalRequestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineApprovalRequest>> {
        const response = await this.listPipelineApprovalRequestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
     * List the trigger matching criteria defined for Pipelines in this Application.
     */
    async listPipelineCriteriaInAppRaw(requestParameters: ListPipelineCriteriaInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineCriteria>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineCriteriaInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineCriteriaInApp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['pipeline'] != null) {
            queryParameters['pipeline'] = requestParameters['pipeline'];
        }

        if (requestParameters['match'] != null) {
            queryParameters['match'] = requestParameters['match'];
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipeline-criteria`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineCriteriaFromJSON));
    }

    /**
     * Lists the trigger matching criteria defined for Pipelines in this Application. Trigger matching criteria link requests in an environment to the appropriate Pipeline based on the trigger and inputs. 
     * List the trigger matching criteria defined for Pipelines in this Application.
     */
    async listPipelineCriteriaInApp(requestParameters: ListPipelineCriteriaInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineCriteria>> {
        const response = await this.listPipelineCriteriaInAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List the details of the jobs within a pipeline run.
     */
    async listPipelineJobsRaw(requestParameters: ListPipelineJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineJobPartial>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineJobs().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineJobs().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling listPipelineJobs().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling listPipelineJobs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineJobPartialFromJSON));
    }

    /**
     * List the details of the jobs within a pipeline run.
     */
    async listPipelineJobs(requestParameters: ListPipelineJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineJobPartial>> {
        const response = await this.listPipelineJobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List runs within a pipeline ordered newest to oldest.
     */
    async listPipelineRunsRaw(requestParameters: ListPipelineRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineRun>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineRuns().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineRuns().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling listPipelineRuns().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['env'] != null) {
            queryParameters['env'] = requestParameters['env'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['completed'] != null) {
            queryParameters['completed'] = requestParameters['completed'];
        }

        if (requestParameters['created_after'] != null) {
            queryParameters['created_after'] = (requestParameters['created_after'] as any).toISOString();
        }

        if (requestParameters['created_before'] != null) {
            queryParameters['created_before'] = (requestParameters['created_before'] as any).toISOString();
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineRunFromJSON));
    }

    /**
     * List runs within a pipeline ordered newest to oldest.
     */
    async listPipelineRuns(requestParameters: ListPipelineRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineRun>> {
        const response = await this.listPipelineRunsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all pipeline runs within the Org ordered newest to oldest. This can be filtered by app, pipeline, and status.
     */
    async listPipelineRunsByOrgRaw(requestParameters: ListPipelineRunsByOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineRun>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineRunsByOrg().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['app'] != null) {
            queryParameters['app'] = requestParameters['app'];
        }

        if (requestParameters['pipeline'] != null) {
            queryParameters['pipeline'] = requestParameters['pipeline'];
        }

        if (requestParameters['env'] != null) {
            queryParameters['env'] = requestParameters['env'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['completed'] != null) {
            queryParameters['completed'] = requestParameters['completed'];
        }

        if (requestParameters['created_after'] != null) {
            queryParameters['created_after'] = (requestParameters['created_after'] as any).toISOString();
        }

        if (requestParameters['created_before'] != null) {
            queryParameters['created_before'] = (requestParameters['created_before'] as any).toISOString();
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/pipeline-runs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineRunFromJSON));
    }

    /**
     * List all pipeline runs within the Org ordered newest to oldest. This can be filtered by app, pipeline, and status.
     */
    async listPipelineRunsByOrg(requestParameters: ListPipelineRunsByOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineRun>> {
        const response = await this.listPipelineRunsByOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a page of log output for a given step within a job.
     */
    async listPipelineStepLogsRaw(requestParameters: ListPipelineStepLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineStepLog>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        if (requestParameters['stepIndex'] == null) {
            throw new runtime.RequiredError(
                'stepIndex',
                'Required parameter "stepIndex" was null or undefined when calling listPipelineStepLogs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/jobs/{jobId}/steps/{stepIndex}/logs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))).replace(`{${"stepIndex"}}`, encodeURIComponent(String(requestParameters['stepIndex']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineStepLogFromJSON));
    }

    /**
     * Get a page of log output for a given step within a job.
     */
    async listPipelineStepLogs(requestParameters: ListPipelineStepLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineStepLog>> {
        const response = await this.listPipelineStepLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all versions of the pipeline
     */
    async listPipelineVersionsRaw(requestParameters: ListPipelineVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PipelineVersion>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelineVersions().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelineVersions().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling listPipelineVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineVersionFromJSON));
    }

    /**
     * List all versions of the pipeline
     */
    async listPipelineVersions(requestParameters: ListPipelineVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PipelineVersion>> {
        const response = await this.listPipelineVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Pipelines within an Application.
     */
    async listPipelinesRaw(requestParameters: ListPipelinesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Pipeline>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelines().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listPipelines().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['trigger'] != null) {
            queryParameters['trigger'] = requestParameters['trigger'];
        }

        if (requestParameters['metadata'] != null) {
            queryParameters['metadata'] = requestParameters['metadata'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineFromJSON));
    }

    /**
     * List Pipelines within an Application.
     */
    async listPipelines(requestParameters: ListPipelinesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Pipeline>> {
        const response = await this.listPipelinesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all Pipelines within an Organization. This can be filtered by Application.
     */
    async listPipelinesInOrgRaw(requestParameters: ListPipelinesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Pipeline>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPipelinesInOrg().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['app'] != null) {
            queryParameters['app'] = requestParameters['app'];
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['trigger'] != null) {
            queryParameters['trigger'] = requestParameters['trigger'];
        }

        if (requestParameters['metadata'] != null) {
            queryParameters['metadata'] = requestParameters['metadata'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/pipelines`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PipelineFromJSON));
    }

    /**
     * List all Pipelines within an Organization. This can be filtered by Application.
     */
    async listPipelinesInOrg(requestParameters: ListPipelinesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Pipeline>> {
        const response = await this.listPipelinesInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all public keys associated to an organization.
     */
    async listPublicKeysRaw(requestParameters: ListPublicKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PublicKey>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listPublicKeys().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fingerprint'] != null) {
            queryParameters['fingerprint'] = requestParameters['fingerprint'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/keys`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PublicKeyFromJSON));
    }

    /**
     * List all public keys associated to an organization.
     */
    async listPublicKeys(requestParameters: ListPublicKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PublicKey>> {
        const response = await this.listPublicKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Resource Account Types available to the organization.
     */
    async listResourceAccountTypesRaw(requestParameters: ListResourceAccountTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AccountTypeResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceAccountTypes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/account-types`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountTypeResponseFromJSON));
    }

    /**
     * List Resource Account Types available to the organization.
     */
    async listResourceAccountTypes(requestParameters: ListResourceAccountTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AccountTypeResponse>> {
        const response = await this.listResourceAccountTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Resource Accounts in the organization.
     */
    async listResourceAccountsRaw(requestParameters: ListResourceAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceAccountResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceAccounts().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceAccountResponseFromJSON));
    }

    /**
     * List Resource Accounts in the organization.
     */
    async listResourceAccounts(requestParameters: ListResourceAccountsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceAccountResponse>> {
        const response = await this.listResourceAccountsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List resource classes.
     */
    async listResourceClassesRaw(requestParameters: ListResourceClassesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceClassResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceClasses().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/classes`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceClassResponseFromJSON));
    }

    /**
     * List resource classes.
     */
    async listResourceClasses(requestParameters: ListResourceClassesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceClassResponse>> {
        const response = await this.listResourceClassesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * First 50 Versions are kept along with all the Versions referenced by an Active Resource.   To obtain Versions of a deleted Resource Definition, the `deleted` parameter needs to be used.
     * Get Versions of a Resource Definition.
     */
    async listResourceDefinitionVersionsRaw(requestParameters: ListResourceDefinitionVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceDefinitionVersion>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceDefinitionVersions().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling listResourceDefinitionVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deleted'] != null) {
            queryParameters['deleted'] = requestParameters['deleted'];
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceDefinitionVersionFromJSON));
    }

    /**
     * First 50 Versions are kept along with all the Versions referenced by an Active Resource.   To obtain Versions of a deleted Resource Definition, the `deleted` parameter needs to be used.
     * Get Versions of a Resource Definition.
     */
    async listResourceDefinitionVersions(requestParameters: ListResourceDefinitionVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceDefinitionVersion>> {
        const response = await this.listResourceDefinitionVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank. Resources marked as deleted are not listed in the response, unless specified via `deleted` query parameter.
     * List Resource Definitions.
     */
    async listResourceDefinitionsRaw(requestParameters: ListResourceDefinitionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceDefinitionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceDefinitions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['app'] != null) {
            queryParameters['app'] = requestParameters['app'];
        }

        if (requestParameters['env'] != null) {
            queryParameters['env'] = requestParameters['env'];
        }

        if (requestParameters['env_type'] != null) {
            queryParameters['env_type'] = requestParameters['env_type'];
        }

        if (requestParameters['res'] != null) {
            queryParameters['res'] = requestParameters['res'];
        }

        if (requestParameters['res_type'] != null) {
            queryParameters['res_type'] = requestParameters['res_type'];
        }

        if (requestParameters['_class'] != null) {
            queryParameters['class'] = requestParameters['_class'];
        }

        if (requestParameters['deleted'] != null) {
            queryParameters['deleted'] = requestParameters['deleted'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceDefinitionResponseFromJSON));
    }

    /**
     * Filter criteria can be applied to obtain all the resource definitions that could match the filters, grouped by type and sorted by matching rank. Resources marked as deleted are not listed in the response, unless specified via `deleted` query parameter.
     * List Resource Definitions.
     */
    async listResourceDefinitions(requestParameters: ListResourceDefinitionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceDefinitionResponse>> {
        const response = await this.listResourceDefinitionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Resource Drivers.
     */
    async listResourceDriversRaw(requestParameters: ListResourceDriversRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DriverDefinitionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceDrivers().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/drivers`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(DriverDefinitionResponseFromJSON));
    }

    /**
     * List Resource Drivers.
     */
    async listResourceDrivers(requestParameters: ListResourceDriversRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DriverDefinitionResponse>> {
        const response = await this.listResourceDriversRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Resource Types.
     */
    async listResourceTypesRaw(requestParameters: ListResourceTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ResourceTypeResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listResourceTypes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/types`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ResourceTypeResponseFromJSON));
    }

    /**
     * List Resource Types.
     */
    async listResourceTypes(requestParameters: ListResourceTypesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ResourceTypeResponse>> {
        const response = await this.listResourceTypesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Runtime information about specific multiple environments.
     */
    async listRuntimeRaw(requestParameters: ListRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EnvironmentRuntimeInfoResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listRuntime().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listRuntime().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/runtime`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EnvironmentRuntimeInfoResponseFromJSON));
    }

    /**
     * Get Runtime information about specific multiple environments.
     */
    async listRuntime(requestParameters: ListRuntimeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EnvironmentRuntimeInfoResponse>> {
        const response = await this.listRuntimeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all Deployment Sets
     */
    async listSetsRaw(requestParameters: ListSetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SetResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listSets().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listSets().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/sets`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SetResponseFromJSON));
    }

    /**
     * Get all Deployment Sets
     */
    async listSets(requestParameters: ListSetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SetResponse>> {
        const response = await this.listSetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the groups in an organization a user belongs to.
     */
    async listUserGroupsInOrgRaw(requestParameters: ListUserGroupsInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Group>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listUserGroupsInOrg().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling listUserGroupsInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/users/{userId}/groups`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupFromJSON));
    }

    /**
     * Get the groups in an organization a user belongs to.
     */
    async listUserGroupsInOrg(requestParameters: ListUserGroupsInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Group>> {
        const response = await this.listUserGroupsInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Users or Groups with roles in an App
     */
    async listUserRolesInAppRaw(requestParameters: ListUserRolesInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRoleResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listUserRolesInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling listUserRolesInApp().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRoleResponseFromJSON));
    }

    /**
     * List Users or Groups with roles in an App
     */
    async listUserRolesInApp(requestParameters: ListUserRolesInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRoleResponse>> {
        const response = await this.listUserRolesInAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Users with roles in an Environment Type
     */
    async listUserRolesInEnvTypeRaw(requestParameters: ListUserRolesInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRoleResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listUserRolesInEnvType().'
            );
        }

        if (requestParameters['envType'] == null) {
            throw new runtime.RequiredError(
                'envType',
                'Required parameter "envType" was null or undefined when calling listUserRolesInEnvType().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envType}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envType"}}`, encodeURIComponent(String(requestParameters['envType']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRoleResponseFromJSON));
    }

    /**
     * List Users with roles in an Environment Type
     */
    async listUserRolesInEnvType(requestParameters: ListUserRolesInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRoleResponse>> {
        const response = await this.listUserRolesInEnvTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Users and Groups with roles in an Organization
     */
    async listUserRolesInOrgRaw(requestParameters: ListUserRolesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserRoleResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listUserRolesInOrg().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/users`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserRoleResponseFromJSON));
    }

    /**
     * List Users and Groups with roles in an Organization
     */
    async listUserRolesInOrg(requestParameters: ListUserRolesInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserRoleResponse>> {
        const response = await this.listUserRolesInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists tokens associated with a user
     */
    async listUserTokensRaw(requestParameters: ListUserTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TokenInfoResponse>>> {
        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling listUserTokens().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{userId}/tokens`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenInfoResponseFromJSON));
    }

    /**
     * Lists tokens associated with a user
     */
    async listUserTokens(requestParameters: ListUserTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TokenInfoResponse>> {
        const response = await this.listUserTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all Workload Profile Chart Versions for the given organization.
     * Workload Profile Chart Versions for the given organization.
     */
    async listWorkloadProfileChartVersionsRaw(requestParameters: ListWorkloadProfileChartVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkloadProfileChartVersionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listWorkloadProfileChartVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profile-chart-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkloadProfileChartVersionResponseFromJSON));
    }

    /**
     * Returns all Workload Profile Chart Versions for the given organization.
     * Workload Profile Chart Versions for the given organization.
     */
    async listWorkloadProfileChartVersions(requestParameters: ListWorkloadProfileChartVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkloadProfileChartVersionResponse>> {
        const response = await this.listWorkloadProfileChartVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List workload profile features available to the organization.
     */
    async listWorkloadProfileFeaturesRaw(requestParameters: ListWorkloadProfileFeaturesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkloadProfileFeatureResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listWorkloadProfileFeatures().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profile-features`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkloadProfileFeatureResponseFromJSON));
    }

    /**
     * List workload profile features available to the organization.
     */
    async listWorkloadProfileFeatures(requestParameters: ListWorkloadProfileFeaturesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkloadProfileFeatureResponse>> {
        const response = await this.listWorkloadProfileFeaturesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List versions of the given workload profile.
     */
    async listWorkloadProfileVersionsRaw(requestParameters: ListWorkloadProfileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkloadProfileVersionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listWorkloadProfileVersions().'
            );
        }

        if (requestParameters['profileQid'] == null) {
            throw new runtime.RequiredError(
                'profileQid',
                'Required parameter "profileQid" was null or undefined when calling listWorkloadProfileVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles/{profileQid}/versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"profileQid"}}`, encodeURIComponent(String(requestParameters['profileQid']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkloadProfileVersionResponseFromJSON));
    }

    /**
     * List versions of the given workload profile.
     */
    async listWorkloadProfileVersions(requestParameters: ListWorkloadProfileVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkloadProfileVersionResponse>> {
        const response = await this.listWorkloadProfileVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List workload profiles available to the organization.
     */
    async listWorkloadProfilesRaw(requestParameters: ListWorkloadProfilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WorkloadProfileResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling listWorkloadProfiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deprecated'] != null) {
            queryParameters['deprecated'] = requestParameters['deprecated'];
        }

        if (requestParameters['per_page'] != null) {
            queryParameters['per_page'] = requestParameters['per_page'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WorkloadProfileResponseFromJSON));
    }

    /**
     * List workload profiles available to the organization.
     */
    async listWorkloadProfiles(requestParameters: ListWorkloadProfilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WorkloadProfileResponse>> {
        const response = await this.listWorkloadProfilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get container log entries for the environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdLogsGetRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdLogsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<OutputEntryResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdLogsGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdLogsGet().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdLogsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['workload_id'] != null) {
            queryParameters['workload_id'] = requestParameters['workload_id'];
        }

        if (requestParameters['container_id'] != null) {
            queryParameters['container_id'] = requestParameters['container_id'];
        }

        if (requestParameters['deployment_id'] != null) {
            queryParameters['deployment_id'] = requestParameters['deployment_id'];
        }

        if (requestParameters['timestamp_from'] != null) {
            queryParameters['timestamp_from'] = requestParameters['timestamp_from'];
        }

        if (requestParameters['timestamp_to'] != null) {
            queryParameters['timestamp_to'] = requestParameters['timestamp_to'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['asc'] != null) {
            queryParameters['asc'] = requestParameters['asc'];
        }

        if (requestParameters['invert'] != null) {
            queryParameters['invert'] = requestParameters['invert'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/logs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OutputEntryResponseFromJSON));
    }

    /**
     * Get container log entries for the environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdLogsGet(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdLogsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<OutputEntryResponse>> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdLogsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * List Value Set Versions in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ValueSetVersionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['key_changed'] != null) {
            queryParameters['key_changed'] = requestParameters['key_changed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ValueSetVersionResponseFromJSON));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the an Environment of an App. In case this environment has no overrides the response is the same as the App level endpoint.
     * List Value Set Versions in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGet(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ValueSetVersionResponse>> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single Value Set Version in an Environment of an App. The zero version id (00000000-0000-0000-0000-000000000000) will return the latest Value Set Version.
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Get a single Value Set Version in an Environment of an App. The zero version id (00000000-0000-0000-0000-000000000000) will return the latest Value Set Version.
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGet(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * Purge the value of a specific Shared Value from the App Environment Version history.
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/purge/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * Purge the value of a specific Shared Value from the App Environment Version history.
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdPurgeKeyPostRaw(requestParameters, initOverrides);
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a specific key from the Value Set Version in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Restore the values of a single Shared Value in an Environment from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a specific key from the Value Set Version in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestoreKeyPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a Value Set Version in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/value-set-versions/{valueSetVersionId}/restore`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Restore the values of all Shared Values in an environment from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a Value Set Version in an Environment of an App
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValueSetVersionsValueSetVersionIdRestorePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * Delete all Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * Delete all Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesDelete(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * List Shared Values in an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesGetRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ValueResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesGet().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ValueResponseFromJSON));
    }

    /**
     * The returned values will be the base Application values with the Environment overrides where applicable. The `source` field will specify the level from which the value is from.
     * List Shared Values in an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesGet(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ValueResponse>> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * Delete Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * Delete Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDelete(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch().'
            );
        }

        if (requestParameters['ValuePatchPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValuePatchPayloadRequest',
                'Required parameter "ValuePatchPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ValuePatchPayloadRequestToJSON(requestParameters['ValuePatchPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatch(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut().'
            );
        }

        if (requestParameters['ValueEditPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueEditPayloadRequest',
                'Required parameter "ValueEditPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ValueEditPayloadRequestToJSON(requestParameters['ValueEditPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPut(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesKeyPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * Create a Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesPostRaw(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesPost().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesPost().'
            );
        }

        if (requestParameters['ValueCreatePayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueCreatePayloadRequest',
                'Required parameter "ValueCreatePayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdEnvsEnvIdValuesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueCreatePayloadRequestToJSON(requestParameters['ValueCreatePayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * The Shared Value created will only be available to the specific Environment.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * Create a Shared Value for an Environment
     */
    async orgsOrgIdAppsAppIdEnvsEnvIdValuesPost(requestParameters: OrgsOrgIdAppsAppIdEnvsEnvIdValuesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdEnvsEnvIdValuesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes all Jobs for the Application
     */
    async orgsOrgIdAppsAppIdJobsDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdJobsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdJobsDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdJobsDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/jobs`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes all Jobs for the Application
     */
    async orgsOrgIdAppsAppIdJobsDelete(requestParameters: OrgsOrgIdAppsAppIdJobsDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdJobsDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * List Value Set Versions in the App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsGetRaw(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ValueSetVersionResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['key_changed'] != null) {
            queryParameters['key_changed'] = requestParameters['key_changed'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/value-set-versions`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ValueSetVersionResponseFromJSON));
    }

    /**
     * A new Value Set Version is created on every modification of a Value inside the app.
     * List Value Set Versions in the App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsGet(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ValueSetVersionResponse>> {
        const response = await this.orgsOrgIdAppsAppIdValueSetVersionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a single Value Set Version from the App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRaw(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Get a single Value Set Version from the App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGet(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * Purge the value of a specific Shared Value from the App Version history.
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRaw(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/purge/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Purging permanently removes the value of a specific Shared Value in an Application. A purged value is no longer accessible, can\'t be restored and can\'t be used by deployments referencing a Value Set Version where the value was present.  Learn more about purging in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#purge). 
     * Purge the value of a specific Shared Value from the App Version history.
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPost(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdPurgeKeyPostRaw(requestParameters, initOverrides);
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a specific key from the Value Set Version in an App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRaw(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Restore the values of a single Shared Value in an application from a specific version.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a specific key from the Value Set Version in an App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPost(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestoreKeyPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a Value Set Version in an App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRaw(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueSetVersionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['valueSetVersionId'] == null) {
            throw new runtime.RequiredError(
                'valueSetVersionId',
                'Required parameter "valueSetVersionId" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        if (requestParameters['ValueSetActionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueSetActionPayloadRequest',
                'Required parameter "ValueSetActionPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/value-set-versions/{valueSetVersionId}/restore`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"valueSetVersionId"}}`, encodeURIComponent(String(requestParameters['valueSetVersionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueSetActionPayloadRequestToJSON(requestParameters['ValueSetActionPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueSetVersionResponseFromJSON(jsonValue));
    }

    /**
     * Restore the values of all Shared Values in an application from a specific version. Keys not existing in the selected version are deleted.  Learn more about reverting in our [docs](https://docs.humanitec.com/reference/concepts/app-config/shared-app-values#revert). 
     * Restore a Value Set Version in an App
     */
    async orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePost(requestParameters: OrgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueSetVersionResponse> {
        const response = await this.orgsOrgIdAppsAppIdValueSetVersionsValueSetVersionIdRestorePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * Delete all Shared Value for an App
     */
    async orgsOrgIdAppsAppIdValuesDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdValuesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * All Shared Values will be deleted. If the Shared Values are marked as a secret, they will also be deleted.
     * Delete all Shared Value for an App
     */
    async orgsOrgIdAppsAppIdValuesDelete(requestParameters: OrgsOrgIdAppsAppIdValuesDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdValuesDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * List Shared Values in an Application
     */
    async orgsOrgIdAppsAppIdValuesGetRaw(requestParameters: OrgsOrgIdAppsAppIdValuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ValueResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ValueResponseFromJSON));
    }

    /**
     * The returned values will be the \"base\" values for the Application. The overridden value for the Environment can be retrieved via the `/orgs/{orgId}/apps/{appId}/envs/{envId}/values` endpoint.
     * List Shared Values in an Application
     */
    async orgsOrgIdAppsAppIdValuesGet(requestParameters: OrgsOrgIdAppsAppIdValuesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ValueResponse>> {
        const response = await this.orgsOrgIdAppsAppIdValuesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * Delete Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdValuesKeyDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyDelete().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * The specified Shared Value will be permanently deleted. If the Shared Value is marked as a secret, it will also be permanently deleted.
     * Delete Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyDelete(requestParameters: OrgsOrgIdAppsAppIdValuesKeyDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdValuesKeyDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyPatchRaw(requestParameters: OrgsOrgIdAppsAppIdValuesKeyPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPatch().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPatch().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPatch().'
            );
        }

        if (requestParameters['ValuePatchPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValuePatchPayloadRequest',
                'Required parameter "ValuePatchPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ValuePatchPayloadRequestToJSON(requestParameters['ValuePatchPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyPatch(requestParameters: OrgsOrgIdAppsAppIdValuesKeyPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdValuesKeyPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyPutRaw(requestParameters: OrgsOrgIdAppsAppIdValuesKeyPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPut().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPut().'
            );
        }

        if (requestParameters['key'] == null) {
            throw new runtime.RequiredError(
                'key',
                'Required parameter "key" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPut().'
            );
        }

        if (requestParameters['ValueEditPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueEditPayloadRequest',
                'Required parameter "ValueEditPayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValuesKeyPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values/{key}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters['key']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ValueEditPayloadRequestToJSON(requestParameters['ValueEditPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * Update the value or description of the Shared Value. Shared Values marked as secret can also be updated.
     * Update Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesKeyPut(requestParameters: OrgsOrgIdAppsAppIdValuesKeyPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdValuesKeyPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * Create a Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesPostRaw(requestParameters: OrgsOrgIdAppsAppIdValuesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ValueResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdValuesPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdValuesPost().'
            );
        }

        if (requestParameters['ValueCreatePayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'ValueCreatePayloadRequest',
                'Required parameter "ValueCreatePayloadRequest" was null or undefined when calling orgsOrgIdAppsAppIdValuesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/values`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ValueCreatePayloadRequestToJSON(requestParameters['ValueCreatePayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ValueResponseFromJSON(jsonValue));
    }

    /**
     * The Shared Value created will be available to all Environments in that Application.  If a Value is marked as a secret, it will be securely stored. It will not be possible to retrieve the value again through the API. The value of the secret can however be updated.
     * Create a Shared Value for an Application
     */
    async orgsOrgIdAppsAppIdValuesPost(requestParameters: OrgsOrgIdAppsAppIdValuesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ValueResponse> {
        const response = await this.orgsOrgIdAppsAppIdValuesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Webhooks
     */
    async orgsOrgIdAppsAppIdWebhooksGetRaw(requestParameters: OrgsOrgIdAppsAppIdWebhooksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<WebhookResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/webhooks`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WebhookResponseFromJSON));
    }

    /**
     * List Webhooks
     */
    async orgsOrgIdAppsAppIdWebhooksGet(requestParameters: OrgsOrgIdAppsAppIdWebhooksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<WebhookResponse>> {
        const response = await this.orgsOrgIdAppsAppIdWebhooksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdDeleteRaw(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdDelete().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdDelete().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdDelete(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdAppsAppIdWebhooksJobIdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdGetRaw(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WebhookResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdGet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdGet().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookResponseFromJSON(jsonValue));
    }

    /**
     * Get a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdGet(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WebhookResponse> {
        const response = await this.orgsOrgIdAppsAppIdWebhooksJobIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdPatchRaw(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WebhookUpdateResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdPatch().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdPatch().'
            );
        }

        if (requestParameters['jobId'] == null) {
            throw new runtime.RequiredError(
                'jobId',
                'Required parameter "jobId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdPatch().'
            );
        }

        if (requestParameters['WebhookRequest'] == null) {
            throw new runtime.RequiredError(
                'WebhookRequest',
                'Required parameter "WebhookRequest" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksJobIdPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/webhooks/{jobId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"jobId"}}`, encodeURIComponent(String(requestParameters['jobId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: WebhookRequestToJSON(requestParameters['WebhookRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookUpdateResponseFromJSON(jsonValue));
    }

    /**
     * Update a Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksJobIdPatch(requestParameters: OrgsOrgIdAppsAppIdWebhooksJobIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WebhookUpdateResponse> {
        const response = await this.orgsOrgIdAppsAppIdWebhooksJobIdPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksPostRaw(requestParameters: OrgsOrgIdAppsAppIdWebhooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WebhookResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksPost().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksPost().'
            );
        }

        if (requestParameters['WebhookRequest'] == null) {
            throw new runtime.RequiredError(
                'WebhookRequest',
                'Required parameter "WebhookRequest" was null or undefined when calling orgsOrgIdAppsAppIdWebhooksPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/webhooks`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WebhookRequestToJSON(requestParameters['WebhookRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookResponseFromJSON(jsonValue));
    }

    /**
     * Create a new Webhook
     */
    async orgsOrgIdAppsAppIdWebhooksPost(requestParameters: OrgsOrgIdAppsAppIdWebhooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WebhookResponse> {
        const response = await this.orgsOrgIdAppsAppIdWebhooksPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List Events
     */
    async orgsOrgIdEventsGetRaw(requestParameters: OrgsOrgIdEventsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<EventResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdEventsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/events`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(EventResponseFromJSON));
    }

    /**
     * List Events
     */
    async orgsOrgIdEventsGet(requestParameters: OrgsOrgIdEventsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<EventResponse>> {
        const response = await this.orgsOrgIdEventsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists available registries for the organization.
     */
    async orgsOrgIdRegistriesGetRaw(requestParameters: OrgsOrgIdRegistriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RegistryResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/registries`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RegistryResponseFromJSON));
    }

    /**
     * Lists available registries for the organization.
     */
    async orgsOrgIdRegistriesGet(requestParameters: OrgsOrgIdRegistriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RegistryResponse>> {
        const response = await this.orgsOrgIdRegistriesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new registry record.
     */
    async orgsOrgIdRegistriesPostRaw(requestParameters: OrgsOrgIdRegistriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegistryResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesPost().'
            );
        }

        if (requestParameters['RegistryRequest'] == null) {
            throw new runtime.RequiredError(
                'RegistryRequest',
                'Required parameter "RegistryRequest" was null or undefined when calling orgsOrgIdRegistriesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/registries`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegistryRequestToJSON(requestParameters['RegistryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegistryResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new registry record.
     */
    async orgsOrgIdRegistriesPost(requestParameters: OrgsOrgIdRegistriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegistryResponse> {
        const response = await this.orgsOrgIdRegistriesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns current account credentials or secret details for the registry.
     */
    async orgsOrgIdRegistriesRegIdCredsGetRaw(requestParameters: OrgsOrgIdRegistriesRegIdCredsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegistryCredsResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesRegIdCredsGet().'
            );
        }

        if (requestParameters['regId'] == null) {
            throw new runtime.RequiredError(
                'regId',
                'Required parameter "regId" was null or undefined when calling orgsOrgIdRegistriesRegIdCredsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/registries/{regId}/creds`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"regId"}}`, encodeURIComponent(String(requestParameters['regId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegistryCredsResponseFromJSON(jsonValue));
    }

    /**
     * Returns current account credentials or secret details for the registry.
     */
    async orgsOrgIdRegistriesRegIdCredsGet(requestParameters: OrgsOrgIdRegistriesRegIdCredsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegistryCredsResponse> {
        const response = await this.orgsOrgIdRegistriesRegIdCredsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * _Deletions are currently irreversible._
     * Deletes an existing registry record and all associated credentials and secrets.
     */
    async orgsOrgIdRegistriesRegIdDeleteRaw(requestParameters: OrgsOrgIdRegistriesRegIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesRegIdDelete().'
            );
        }

        if (requestParameters['regId'] == null) {
            throw new runtime.RequiredError(
                'regId',
                'Required parameter "regId" was null or undefined when calling orgsOrgIdRegistriesRegIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/registries/{regId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"regId"}}`, encodeURIComponent(String(requestParameters['regId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * _Deletions are currently irreversible._
     * Deletes an existing registry record and all associated credentials and secrets.
     */
    async orgsOrgIdRegistriesRegIdDelete(requestParameters: OrgsOrgIdRegistriesRegIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdRegistriesRegIdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Loads a registry record details.
     */
    async orgsOrgIdRegistriesRegIdGetRaw(requestParameters: OrgsOrgIdRegistriesRegIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegistryResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesRegIdGet().'
            );
        }

        if (requestParameters['regId'] == null) {
            throw new runtime.RequiredError(
                'regId',
                'Required parameter "regId" was null or undefined when calling orgsOrgIdRegistriesRegIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/registries/{regId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"regId"}}`, encodeURIComponent(String(requestParameters['regId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegistryResponseFromJSON(jsonValue));
    }

    /**
     * Loads a registry record details.
     */
    async orgsOrgIdRegistriesRegIdGet(requestParameters: OrgsOrgIdRegistriesRegIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegistryResponse> {
        const response = await this.orgsOrgIdRegistriesRegIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates (patches) an existing registry record.
     */
    async orgsOrgIdRegistriesRegIdPatchRaw(requestParameters: OrgsOrgIdRegistriesRegIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegistryResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdRegistriesRegIdPatch().'
            );
        }

        if (requestParameters['regId'] == null) {
            throw new runtime.RequiredError(
                'regId',
                'Required parameter "regId" was null or undefined when calling orgsOrgIdRegistriesRegIdPatch().'
            );
        }

        if (requestParameters['RegistryRequest'] == null) {
            throw new runtime.RequiredError(
                'RegistryRequest',
                'Required parameter "RegistryRequest" was null or undefined when calling orgsOrgIdRegistriesRegIdPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/registries/{regId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"regId"}}`, encodeURIComponent(String(requestParameters['regId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RegistryRequestToJSON(requestParameters['RegistryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegistryResponseFromJSON(jsonValue));
    }

    /**
     * Updates (patches) an existing registry record.
     */
    async orgsOrgIdRegistriesRegIdPatch(requestParameters: OrgsOrgIdRegistriesRegIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegistryResponse> {
        const response = await this.orgsOrgIdRegistriesRegIdPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of Secret Stores for the given organization.
     */
    async orgsOrgIdSecretstoresGetRaw(requestParameters: OrgsOrgIdSecretstoresGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SecretStoreResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdSecretstoresGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/secretstores`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SecretStoreResponseFromJSON));
    }

    /**
     * Get list of Secret Stores for the given organization.
     */
    async orgsOrgIdSecretstoresGet(requestParameters: OrgsOrgIdSecretstoresGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SecretStoreResponse>> {
        const response = await this.orgsOrgIdSecretstoresGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a Secret Store for the given organization.
     */
    async orgsOrgIdSecretstoresPostRaw(requestParameters: OrgsOrgIdSecretstoresPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecretStoreResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdSecretstoresPost().'
            );
        }

        if (requestParameters['CreateSecretStorePayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'CreateSecretStorePayloadRequest',
                'Required parameter "CreateSecretStorePayloadRequest" was null or undefined when calling orgsOrgIdSecretstoresPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/secretstores`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSecretStorePayloadRequestToJSON(requestParameters['CreateSecretStorePayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SecretStoreResponseFromJSON(jsonValue));
    }

    /**
     * Create a Secret Store for the given organization.
     */
    async orgsOrgIdSecretstoresPost(requestParameters: OrgsOrgIdSecretstoresPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecretStoreResponse> {
        const response = await this.orgsOrgIdSecretstoresPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdDeleteRaw(requestParameters: OrgsOrgIdSecretstoresStoreIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdDelete().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/secretstores/{storeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdDelete(requestParameters: OrgsOrgIdSecretstoresStoreIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.orgsOrgIdSecretstoresStoreIdDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdGetRaw(requestParameters: OrgsOrgIdSecretstoresStoreIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecretStoreResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdGet().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/secretstores/{storeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SecretStoreResponseFromJSON(jsonValue));
    }

    /**
     * Get the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdGet(requestParameters: OrgsOrgIdSecretstoresStoreIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecretStoreResponse> {
        const response = await this.orgsOrgIdSecretstoresStoreIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdPatchRaw(requestParameters: OrgsOrgIdSecretstoresStoreIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecretStoreResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdPatch().'
            );
        }

        if (requestParameters['storeId'] == null) {
            throw new runtime.RequiredError(
                'storeId',
                'Required parameter "storeId" was null or undefined when calling orgsOrgIdSecretstoresStoreIdPatch().'
            );
        }

        if (requestParameters['UpdateSecretStorePayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateSecretStorePayloadRequest',
                'Required parameter "UpdateSecretStorePayloadRequest" was null or undefined when calling orgsOrgIdSecretstoresStoreIdPatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/secretstores/{storeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"storeId"}}`, encodeURIComponent(String(requestParameters['storeId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateSecretStorePayloadRequestToJSON(requestParameters['UpdateSecretStorePayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SecretStoreResponseFromJSON(jsonValue));
    }

    /**
     * Update the Secret Store.
     */
    async orgsOrgIdSecretstoresStoreIdPatch(requestParameters: OrgsOrgIdSecretstoresStoreIdPatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecretStoreResponse> {
        const response = await this.orgsOrgIdSecretstoresStoreIdPatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the description of an Agent.
     */
    async patchAgentRaw(requestParameters: PatchAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Agent>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchAgent().'
            );
        }

        if (requestParameters['agentId'] == null) {
            throw new runtime.RequiredError(
                'agentId',
                'Required parameter "agentId" was null or undefined when calling patchAgent().'
            );
        }

        if (requestParameters['AgentPatchBody'] == null) {
            throw new runtime.RequiredError(
                'AgentPatchBody',
                'Required parameter "AgentPatchBody" was null or undefined when calling patchAgent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/agents/{agentId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters['agentId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AgentPatchBodyToJSON(requestParameters['AgentPatchBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AgentFromJSON(jsonValue));
    }

    /**
     * Update the description of an Agent.
     */
    async patchAgent(requestParameters: PatchAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Agent> {
        const response = await this.patchAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update metadata of an existing Application in the specified Organization.
     * Update metadata of an existing Application
     */
    async patchApplicationRaw(requestParameters: PatchApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchApplication().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling patchApplication().'
            );
        }

        if (requestParameters['ApplicationPatchPayload'] == null) {
            throw new runtime.RequiredError(
                'ApplicationPatchPayload',
                'Required parameter "ApplicationPatchPayload" was null or undefined when calling patchApplication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ApplicationPatchPayloadToJSON(requestParameters['ApplicationPatchPayload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationResponseFromJSON(jsonValue));
    }

    /**
     * Update metadata of an existing Application in the specified Organization.
     * Update metadata of an existing Application
     */
    async patchApplication(requestParameters: PatchApplicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationResponse> {
        const response = await this.patchApplicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * Update Version of an Artefact.
     */
    async patchArtefactVersionRaw(requestParameters: PatchArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ArtefactVersion>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchArtefactVersion().'
            );
        }

        if (requestParameters['artefactId'] == null) {
            throw new runtime.RequiredError(
                'artefactId',
                'Required parameter "artefactId" was null or undefined when calling patchArtefactVersion().'
            );
        }

        if (requestParameters['versionId'] == null) {
            throw new runtime.RequiredError(
                'versionId',
                'Required parameter "versionId" was null or undefined when calling patchArtefactVersion().'
            );
        }

        if (requestParameters['UpdateArtefactVersionPayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateArtefactVersionPayloadRequest',
                'Required parameter "UpdateArtefactVersionPayloadRequest" was null or undefined when calling patchArtefactVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/artefacts/{artefactId}/versions/{versionId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"artefactId"}}`, encodeURIComponent(String(requestParameters['artefactId']))).replace(`{${"versionId"}}`, encodeURIComponent(String(requestParameters['versionId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateArtefactVersionPayloadRequestToJSON(requestParameters['UpdateArtefactVersionPayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ArtefactVersionFromJSON(jsonValue));
    }

    /**
     * Update the version of a specified Artefact registered with your organization\".
     * Update Version of an Artefact.
     */
    async patchArtefactVersion(requestParameters: PatchArtefactVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ArtefactVersion> {
        const response = await this.patchArtefactVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an existing Delta
     */
    async patchDeltaRaw(requestParameters: PatchDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeltaResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling patchDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling patchDelta().'
            );
        }

        if (requestParameters['DeltaRequest'] == null) {
            throw new runtime.RequiredError(
                'DeltaRequest',
                'Required parameter "DeltaRequest" was null or undefined when calling patchDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['DeltaRequest']!.map(DeltaRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeltaResponseFromJSON(jsonValue));
    }

    /**
     * Update an existing Delta
     */
    async patchDelta(requestParameters: PatchDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeltaResponse> {
        const response = await this.patchDeltaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set number of replicas for an environment\'s modules.
     */
    async patchReplicasRaw(requestParameters: PatchReplicasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchReplicas().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling patchReplicas().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling patchReplicas().'
            );
        }

        if (requestParameters['request_body'] == null) {
            throw new runtime.RequiredError(
                'request_body',
                'Required parameter "request_body" was null or undefined when calling patchReplicas().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/replicas`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request_body'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set number of replicas for an environment\'s modules.
     */
    async patchReplicas(requestParameters: PatchReplicasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchReplicasRaw(requestParameters, initOverrides);
    }

    /**
     * Update a Resource Account.
     */
    async patchResourceAccountRaw(requestParameters: PatchResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceAccountResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchResourceAccount().'
            );
        }

        if (requestParameters['accId'] == null) {
            throw new runtime.RequiredError(
                'accId',
                'Required parameter "accId" was null or undefined when calling patchResourceAccount().'
            );
        }

        if (requestParameters['UpdateResourceAccountRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateResourceAccountRequestRequest',
                'Required parameter "UpdateResourceAccountRequestRequest" was null or undefined when calling patchResourceAccount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        if (requestParameters['check_credential'] != null) {
            queryParameters['check_credential'] = requestParameters['check_credential'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/accounts/{accId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"accId"}}`, encodeURIComponent(String(requestParameters['accId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateResourceAccountRequestRequestToJSON(requestParameters['UpdateResourceAccountRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceAccountResponseFromJSON(jsonValue));
    }

    /**
     * Update a Resource Account.
     */
    async patchResourceAccount(requestParameters: PatchResourceAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceAccountResponse | null | undefined > {
        const response = await this.patchResourceAccountRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Update a Resource Definition.
     */
    async patchResourceDefinitionRaw(requestParameters: PatchResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling patchResourceDefinition().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling patchResourceDefinition().'
            );
        }

        if (requestParameters['PatchResourceDefinitionRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'PatchResourceDefinitionRequestRequest',
                'Required parameter "PatchResourceDefinitionRequestRequest" was null or undefined when calling patchResourceDefinition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchResourceDefinitionRequestRequestToJSON(requestParameters['PatchResourceDefinitionRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Update a Resource Definition.
     */
    async patchResourceDefinition(requestParameters: PatchResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceDefinitionResponse> {
        const response = await this.patchResourceDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pin Active Resource to a target Resource Definition Version.
     */
    async pinActiveResourceRaw(requestParameters: PinActiveResourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveResourceResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling pinActiveResource().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling pinActiveResource().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling pinActiveResource().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling pinActiveResource().'
            );
        }

        if (requestParameters['resId'] == null) {
            throw new runtime.RequiredError(
                'resId',
                'Required parameter "resId" was null or undefined when calling pinActiveResource().'
            );
        }

        if (requestParameters['ActiveResourceTargetDefinitionRequest'] == null) {
            throw new runtime.RequiredError(
                'ActiveResourceTargetDefinitionRequest',
                'Required parameter "ActiveResourceTargetDefinitionRequest" was null or undefined when calling pinActiveResource().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/{type}/{resId}/actions/pin`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))).replace(`{${"resId"}}`, encodeURIComponent(String(requestParameters['resId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ActiveResourceTargetDefinitionRequestToJSON(requestParameters['ActiveResourceTargetDefinitionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveResourceResponseFromJSON(jsonValue));
    }

    /**
     * Pin Active Resource to a target Resource Definition Version.
     */
    async pinActiveResource(requestParameters: PinActiveResourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveResourceResponse> {
        const response = await this.pinActiveResourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Promote the Resource Definition Version as active.
     */
    async promoteResourceDefinitionVersionRaw(requestParameters: PromoteResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling promoteResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling promoteResourceDefinitionVersion().'
            );
        }

        if (requestParameters['defVersionId'] == null) {
            throw new runtime.RequiredError(
                'defVersionId',
                'Required parameter "defVersionId" was null or undefined when calling promoteResourceDefinitionVersion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/versions/{defVersionId}/actions/promote`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))).replace(`{${"defVersionId"}}`, encodeURIComponent(String(requestParameters['defVersionId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Promote the Resource Definition Version as active.
     */
    async promoteResourceDefinitionVersion(requestParameters: PromoteResourceDefinitionVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.promoteResourceDefinitionVersionRaw(requestParameters, initOverrides);
    }

    /**
     * Update an existing Delta
     */
    async putDeltaRaw(requestParameters: PutDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling putDelta().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling putDelta().'
            );
        }

        if (requestParameters['deltaId'] == null) {
            throw new runtime.RequiredError(
                'deltaId',
                'Required parameter "deltaId" was null or undefined when calling putDelta().'
            );
        }

        if (requestParameters['DeltaRequest'] == null) {
            throw new runtime.RequiredError(
                'DeltaRequest',
                'Required parameter "DeltaRequest" was null or undefined when calling putDelta().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/deltas/{deltaId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"deltaId"}}`, encodeURIComponent(String(requestParameters['deltaId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DeltaRequestToJSON(requestParameters['DeltaRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update an existing Delta
     */
    async putDelta(requestParameters: PutDeltaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putDeltaRaw(requestParameters, initOverrides);
    }

    /**
     * This endpoint is deprecated. Use `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graphs` instead.
     * Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @deprecated
     */
    async queryResourceGraphRaw(requestParameters: QueryResourceGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<NodeBodyResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling queryResourceGraph().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling queryResourceGraph().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling queryResourceGraph().'
            );
        }

        if (requestParameters['ResourceProvisionRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'ResourceProvisionRequestRequest',
                'Required parameter "ResourceProvisionRequestRequest" was null or undefined when calling queryResourceGraph().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graph`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['ResourceProvisionRequestRequest']!.map(ResourceProvisionRequestRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(NodeBodyResponseFromJSON));
    }

    /**
     * This endpoint is deprecated. Use `/orgs/{orgId}/apps/{appId}/envs/{envId}/resources/graphs` instead.
     * Lists the resource objects that hold the information needed to provision the resources specified in the request and the resources they depend on.
     * @deprecated
     */
    async queryResourceGraph(requestParameters: QueryResourceGraphRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<NodeBodyResponse>> {
        const response = await this.queryResourceGraphRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * Rebase to a different Deployment.
     */
    async rebaseEnvironmentRaw(requestParameters: RebaseEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling rebaseEnvironment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling rebaseEnvironment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling rebaseEnvironment().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling rebaseEnvironment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/from_deploy_id`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Rebasing an Environment means that the next Deployment to the Environment will be based on the Deployment specified in the rebase rather than the last one in the Environment. The Deployment to rebase to can either be current or a previous Deployment. The Deployment can be from any Environment of the same Application.  _Running code will only be affected on the next Deployment to the Environment._  Common use cases for rebasing an Environment:  * _Rollback_: Rebasing to a previous Deployment in the current Environment and then Deploying without additional changes will execute a rollback to the previous Deployment state.  * _Clone_: Rebasing to the current Deployment in a different Environment and then deploying without additional changes will clone all of the configuration of the other Environment into the current one. (NOTE: External Resources will not be cloned in the process - the current External Resources of the Environment will remain unchanged and will be used by the deployed Application in the Environment.
     * Rebase to a different Deployment.
     */
    async rebaseEnvironment(requestParameters: RebaseEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.rebaseEnvironmentRaw(requestParameters, initOverrides);
    }

    /**
     * Attempts to copy and restart the specified Run. The run must be in a completed state. 
     * Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
     */
    async restartPipelineRunRaw(requestParameters: RestartPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PipelineRun>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling restartPipelineRun().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling restartPipelineRun().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling restartPipelineRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling restartPipelineRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['Idempotency_Key'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['Idempotency_Key']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}/runs/{runId}/restart`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))).replace(`{${"runId"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineRunFromJSON(jsonValue));
    }

    /**
     * Attempts to copy and restart the specified Run. The run must be in a completed state. 
     * Restart a Run within an Pipeline by cloning it with the same trigger and inputs.
     */
    async restartPipelineRun(requestParameters: RestartPipelineRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PipelineRun> {
        const response = await this.restartPipelineRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * Update an existing Automation Rule for an Environment.
     */
    async updateAutomationRuleRaw(requestParameters: UpdateAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutomationRuleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateAutomationRule().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updateAutomationRule().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling updateAutomationRule().'
            );
        }

        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling updateAutomationRule().'
            );
        }

        if (requestParameters['AutomationRuleRequest'] == null) {
            throw new runtime.RequiredError(
                'AutomationRuleRequest',
                'Required parameter "AutomationRuleRequest" was null or undefined when calling updateAutomationRule().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/rules/{ruleId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))).replace(`{${"ruleId"}}`, encodeURIComponent(String(requestParameters['ruleId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationRuleRequestToJSON(requestParameters['AutomationRuleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationRuleResponseFromJSON(jsonValue));
    }

    /**
     * Items marked as deprecated are still supported (however not recommended) for use and are incompatible with properties of the latest api version. In particular an error is raised if  `images_filter` (deprecated) and `artefacts_filter` are used in the same payload. The same is true for `exclude_images_filter` (deprecated) and `exclude_artefacts_filter`. `match` and `update_to` are still supported but will trigger an error if combined with `match_ref`.
     * Update an existing Automation Rule for an Environment.
     */
    async updateAutomationRule(requestParameters: UpdateAutomationRuleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutomationRuleResponse> {
        const response = await this.updateAutomationRuleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the extended profile of the current user.
     */
    async updateCurrentUserRaw(requestParameters: UpdateCurrentUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfileExtendedResponse>> {
        if (requestParameters['UserProfileExtendedRequest'] == null) {
            throw new runtime.RequiredError(
                'UserProfileExtendedRequest',
                'Required parameter "UserProfileExtendedRequest" was null or undefined when calling updateCurrentUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/current-user`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UserProfileExtendedRequestToJSON(requestParameters['UserProfileExtendedRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileExtendedResponseFromJSON(jsonValue));
    }

    /**
     * Updates the extended profile of the current user.
     */
    async updateCurrentUser(requestParameters: UpdateCurrentUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfileExtendedResponse> {
        const response = await this.updateCurrentUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a specific Environment in an Application.
     * Update a specific Environment.
     */
    async updateEnvironmentRaw(requestParameters: UpdateEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateEnvironment().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updateEnvironment().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling updateEnvironment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: EnvironmentBaseUpdateRequestToJSON(requestParameters['EnvironmentBaseUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentResponseFromJSON(jsonValue));
    }

    /**
     * Update a specific Environment in an Application.
     * Update a specific Environment.
     */
    async updateEnvironment(requestParameters: UpdateEnvironmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentResponse> {
        const response = await this.updateEnvironmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates Environment Type.
     * Updates Environment Type
     */
    async updateEnvironmentTypeRaw(requestParameters: UpdateEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnvironmentTypeResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateEnvironmentType().'
            );
        }

        if (requestParameters['envTypeId'] == null) {
            throw new runtime.RequiredError(
                'envTypeId',
                'Required parameter "envTypeId" was null or undefined when calling updateEnvironmentType().'
            );
        }

        if (requestParameters['UpdateEnvironmentTypePayloadRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateEnvironmentTypePayloadRequest',
                'Required parameter "UpdateEnvironmentTypePayloadRequest" was null or undefined when calling updateEnvironmentType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envTypeId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envTypeId"}}`, encodeURIComponent(String(requestParameters['envTypeId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEnvironmentTypePayloadRequestToJSON(requestParameters['UpdateEnvironmentTypePayloadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnvironmentTypeResponseFromJSON(jsonValue));
    }

    /**
     * Updates Environment Type.
     * Updates Environment Type
     */
    async updateEnvironmentType(requestParameters: UpdateEnvironmentTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnvironmentTypeResponse> {
        const response = await this.updateEnvironmentTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * Pause / Resume an environment.
     */
    async updatePausedRaw(requestParameters: UpdatePausedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updatePaused().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updatePaused().'
            );
        }

        if (requestParameters['envId'] == null) {
            throw new runtime.RequiredError(
                'envId',
                'Required parameter "envId" was null or undefined when calling updatePaused().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updatePaused().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/envs/{envId}/runtime/paused`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"envId"}}`, encodeURIComponent(String(requestParameters['envId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * On pause requests, all the Kubernetes Deployment resources are scaled down to 0 replicas. On resume requests, all the Kubernetes Deployment resources are scaled up to the number of replicas running before the environment was paused. When an environment is paused, it is not possible to:```   - Deploy the environment within Humanitec.   - Scale the number of replicas running of any workload. ```
     * Pause / Resume an environment.
     */
    async updatePaused(requestParameters: UpdatePausedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updatePausedRaw(requestParameters, initOverrides);
    }

    /**
     * update a Pipeline within an Application.
     */
    async updatePipelineRaw(requestParameters: UpdatePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Pipeline>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updatePipeline().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updatePipeline().'
            );
        }

        if (requestParameters['pipelineId'] == null) {
            throw new runtime.RequiredError(
                'pipelineId',
                'Required parameter "pipelineId" was null or undefined when calling updatePipeline().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updatePipeline().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['dry_run'] != null) {
            queryParameters['dry_run'] = requestParameters['dry_run'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/x-yaml';

        if (requestParameters['If_Match'] != null) {
            headerParameters['If-Match'] = String(requestParameters['If_Match']);
        }

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/pipelines/{pipelineId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"pipelineId"}}`, encodeURIComponent(String(requestParameters['pipelineId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PipelineFromJSON(jsonValue));
    }

    /**
     * update a Pipeline within an Application.
     */
    async updatePipeline(requestParameters: UpdatePipelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Pipeline | null | undefined > {
        const response = await this.updatePipelineRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Update a resource class description.
     */
    async updateResourceClassRaw(requestParameters: UpdateResourceClassOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceClassResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateResourceClass().'
            );
        }

        if (requestParameters['typeId'] == null) {
            throw new runtime.RequiredError(
                'typeId',
                'Required parameter "typeId" was null or undefined when calling updateResourceClass().'
            );
        }

        if (requestParameters['classId'] == null) {
            throw new runtime.RequiredError(
                'classId',
                'Required parameter "classId" was null or undefined when calling updateResourceClass().'
            );
        }

        if (requestParameters['UpdateResourceClassRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateResourceClassRequest',
                'Required parameter "UpdateResourceClassRequest" was null or undefined when calling updateResourceClass().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/types/{typeId}/classes/{classId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"typeId"}}`, encodeURIComponent(String(requestParameters['typeId']))).replace(`{${"classId"}}`, encodeURIComponent(String(requestParameters['classId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateResourceClassRequestToJSON(requestParameters['UpdateResourceClassRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceClassResponseFromJSON(jsonValue));
    }

    /**
     * Update a resource class description.
     */
    async updateResourceClass(requestParameters: UpdateResourceClassOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceClassResponse> {
        const response = await this.updateResourceClassRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Resource Definition.
     */
    async updateResourceDefinitionRaw(requestParameters: UpdateResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResourceDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateResourceDefinition().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling updateResourceDefinition().'
            );
        }

        if (requestParameters['UpdateResourceDefinitionRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateResourceDefinitionRequestRequest',
                'Required parameter "UpdateResourceDefinitionRequestRequest" was null or undefined when calling updateResourceDefinition().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateResourceDefinitionRequestRequestToJSON(requestParameters['UpdateResourceDefinitionRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResourceDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Update a Resource Definition.
     */
    async updateResourceDefinition(requestParameters: UpdateResourceDefinitionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResourceDefinitionResponse> {
        const response = await this.updateResourceDefinitionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * Update all Matching Criteria of a Resource Definition.
     */
    async updateResourceDefinitionCriteriaRaw(requestParameters: UpdateResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MatchingCriteriaResponse>>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['defId'] == null) {
            throw new runtime.RequiredError(
                'defId',
                'Required parameter "defId" was null or undefined when calling updateResourceDefinitionCriteria().'
            );
        }

        if (requestParameters['MatchingCriteriaRuleRequest'] == null) {
            throw new runtime.RequiredError(
                'MatchingCriteriaRuleRequest',
                'Required parameter "MatchingCriteriaRuleRequest" was null or undefined when calling updateResourceDefinitionCriteria().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/defs/{defId}/criteria`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"defId"}}`, encodeURIComponent(String(requestParameters['defId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['MatchingCriteriaRuleRequest']!.map(MatchingCriteriaRuleRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MatchingCriteriaResponseFromJSON));
    }

    /**
     * Matching Criteria are combined with Resource Type to select a specific definition. Matching Criteria can be set for any combination of Application ID, Environment ID, Environment Type, and Resource ID. In the event of multiple matches, the most specific match is chosen.  For example, given 3 sets of matching criteria for the same type:  ```  1. {\"env_type\":\"test\"}  2. {\"env_type\":\"development\"}  3. {\"env_type\":\"test\", \"app_id\":\"my-app\"} ```  If, a resource of that type was needed in an Application `my-app`, Environment `qa-team` with Type `test` and Resource ID `modules.my-module-externals.my-resource`, there would be two resource definitions matching the criteria: #1 & #3. Definition #3 will be chosen because its matching criteria is the most specific.
     * Update all Matching Criteria of a Resource Definition.
     */
    async updateResourceDefinitionCriteria(requestParameters: UpdateResourceDefinitionCriteriaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MatchingCriteriaResponse>> {
        const response = await this.updateResourceDefinitionCriteriaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Resource Driver.
     */
    async updateResourceDriverRaw(requestParameters: UpdateResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DriverDefinitionResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateResourceDriver().'
            );
        }

        if (requestParameters['driverId'] == null) {
            throw new runtime.RequiredError(
                'driverId',
                'Required parameter "driverId" was null or undefined when calling updateResourceDriver().'
            );
        }

        if (requestParameters['UpdateDriverRequestRequest'] == null) {
            throw new runtime.RequiredError(
                'UpdateDriverRequestRequest',
                'Required parameter "UpdateDriverRequestRequest" was null or undefined when calling updateResourceDriver().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/resources/drivers/{driverId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"driverId"}}`, encodeURIComponent(String(requestParameters['driverId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateDriverRequestRequestToJSON(requestParameters['UpdateDriverRequestRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DriverDefinitionResponseFromJSON(jsonValue));
    }

    /**
     * Update a Resource Driver.
     */
    async updateResourceDriver(requestParameters: UpdateResourceDriverRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DriverDefinitionResponse> {
        const response = await this.updateResourceDriverRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Apply a Deployment Delta to a Deployment Set
     */
    async updateSetRaw(requestParameters: UpdateSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateSet().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updateSet().'
            );
        }

        if (requestParameters['setId'] == null) {
            throw new runtime.RequiredError(
                'setId',
                'Required parameter "setId" was null or undefined when calling updateSet().'
            );
        }

        if (requestParameters['DeltaRequest'] == null) {
            throw new runtime.RequiredError(
                'DeltaRequest',
                'Required parameter "DeltaRequest" was null or undefined when calling updateSet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/sets/{setId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"setId"}}`, encodeURIComponent(String(requestParameters['setId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeltaRequestToJSON(requestParameters['DeltaRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Apply a Deployment Delta to a Deployment Set
     */
    async updateSet(requestParameters: UpdateSetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.updateSetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the role of a User or a Group on an Application
     */
    async updateUserRoleInAppRaw(requestParameters: UpdateUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateUserRoleInApp().'
            );
        }

        if (requestParameters['appId'] == null) {
            throw new runtime.RequiredError(
                'appId',
                'Required parameter "appId" was null or undefined when calling updateUserRoleInApp().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling updateUserRoleInApp().'
            );
        }

        if (requestParameters['RoleRequest'] == null) {
            throw new runtime.RequiredError(
                'RoleRequest',
                'Required parameter "RoleRequest" was null or undefined when calling updateUserRoleInApp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/apps/{appId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"appId"}}`, encodeURIComponent(String(requestParameters['appId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RoleRequestToJSON(requestParameters['RoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Update the role of a User or a Group on an Application
     */
    async updateUserRoleInApp(requestParameters: UpdateUserRoleInAppRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.updateUserRoleInAppRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the role of a User or a Group on an Environment Type
     */
    async updateUserRoleInEnvTypeRaw(requestParameters: UpdateUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateUserRoleInEnvType().'
            );
        }

        if (requestParameters['envType'] == null) {
            throw new runtime.RequiredError(
                'envType',
                'Required parameter "envType" was null or undefined when calling updateUserRoleInEnvType().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling updateUserRoleInEnvType().'
            );
        }

        if (requestParameters['RoleRequest'] == null) {
            throw new runtime.RequiredError(
                'RoleRequest',
                'Required parameter "RoleRequest" was null or undefined when calling updateUserRoleInEnvType().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/env-types/{envType}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"envType"}}`, encodeURIComponent(String(requestParameters['envType']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RoleRequestToJSON(requestParameters['RoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Update the role of a User or a Group on an Environment Type
     */
    async updateUserRoleInEnvType(requestParameters: UpdateUserRoleInEnvTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.updateUserRoleInEnvTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the role of a User on an Organization
     */
    async updateUserRoleInOrgRaw(requestParameters: UpdateUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserRoleResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateUserRoleInOrg().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling updateUserRoleInOrg().'
            );
        }

        if (requestParameters['RoleRequest'] == null) {
            throw new runtime.RequiredError(
                'RoleRequest',
                'Required parameter "RoleRequest" was null or undefined when calling updateUserRoleInOrg().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/users/{userId}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: RoleRequestToJSON(requestParameters['RoleRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserRoleResponseFromJSON(jsonValue));
    }

    /**
     * Update the role of a User on an Organization
     */
    async updateUserRoleInOrg(requestParameters: UpdateUserRoleInOrgRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserRoleResponse> {
        const response = await this.updateUserRoleInOrgRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a Workload Profile
     */
    async updateWorkloadProfileRaw(requestParameters: UpdateWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WorkloadProfileResponse>> {
        if (requestParameters['orgId'] == null) {
            throw new runtime.RequiredError(
                'orgId',
                'Required parameter "orgId" was null or undefined when calling updateWorkloadProfile().'
            );
        }

        if (requestParameters['profileQid'] == null) {
            throw new runtime.RequiredError(
                'profileQid',
                'Required parameter "profileQid" was null or undefined when calling updateWorkloadProfile().'
            );
        }

        if (requestParameters['WorkloadProfileUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'WorkloadProfileUpdateRequest',
                'Required parameter "WorkloadProfileUpdateRequest" was null or undefined when calling updateWorkloadProfile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/orgs/{orgId}/workload-profiles/{profileQid}`.replace(`{${"orgId"}}`, encodeURIComponent(String(requestParameters['orgId']))).replace(`{${"profileQid"}}`, encodeURIComponent(String(requestParameters['profileQid']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: WorkloadProfileUpdateRequestToJSON(requestParameters['WorkloadProfileUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WorkloadProfileResponseFromJSON(jsonValue));
    }

    /**
     * Update a Workload Profile
     */
    async updateWorkloadProfile(requestParameters: UpdateWorkloadProfileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WorkloadProfileResponse> {
        const response = await this.updateWorkloadProfileRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
